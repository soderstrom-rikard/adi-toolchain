Take endian-ness from build system rather than toolchain so we don't
have to deal with differences between BSD/Linux/etc... for endian
detection.

--- linux/cramfs_fs.h
+++ linux/cramfs_fs.h
@@ -12,8 +12,17 @@
 
 #else /* not __KERNEL__ */
 
+#ifdef __linux__
 #include <byteswap.h>
-#include <endian.h>
+#endif
+#ifndef bswap_16
+# define bswap_16(x) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8))
+#endif
+#ifndef bswap_32
+# define bswap_32(x) \
+     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) | \
+      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
+#endif
 
 typedef unsigned char u8;
 typedef unsigned short u16;
@@ -106,18 +115,7 @@
  * Since cramfs is little-endian, provide macros to swab the bitfields.
  */
 
-#ifndef __BYTE_ORDER
-#if defined(__LITTLE_ENDIAN) && !defined(__BIG_ENDIAN)
-#define __BYTE_ORDER __LITTLE_ENDIAN
-#elif defined(__BIG_ENDIAN) && !defined(__LITTLE_ENDIAN)
-#define __BYTE_ORDER __BIG_ENDIAN
-#else
-#error "unable to define __BYTE_ORDER"
-#endif
-#endif /* not __BYTE_ORDER */
-
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-#warning  "__BYTE_ORDER == __LITTLE_ENDIAN"
+#if defined(CRAMFS_LITTLE_ENDIAN)
 #define CRAMFS_16(x)	(x)
 #define CRAMFS_24(x)	(x)
 #define CRAMFS_32(x)	(x)
@@ -125,8 +123,7 @@
 #define CRAMFS_GET_OFFSET(x)	((x)->offset)
 #define CRAMFS_SET_OFFSET(x,y)	((x)->offset = (y))
 #define CRAMFS_SET_NAMELEN(x,y)	((x)->namelen = (y))
-#elif __BYTE_ORDER == __BIG_ENDIAN
-#warning "__BYTE_ORDER == __BIG_ENDIAN"
+#elif defined(CRAMFS_BIG_ENDIAN)
 #ifdef __KERNEL__
 #define CRAMFS_16(x)	swab16(x)
 #define CRAMFS_24(x)	((swab32(x)) >> 8)
--- detectendian.sh
+++ detectendian.sh
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+cat > .endian.c << EOCP
+short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+short ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+void _ascii() { char* s = (char*) ascii_mm; s = (char*) ascii_ii; }
+short ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+short ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+void _ebcdic() { char* s = (char*) ebcdic_mm; s = (char*) ebcdic_ii; }
+int main() { _ascii (); _ebcdic (); return 0; }
+EOCP
+
+if ${CC:-gcc} ${CFLAGS} ${CPPFLAGS} -c .endian.c -o .endian.o ; then
+	if grep -qs BIGenDianSyS .endian.o ; then
+		echo -DCRAMFS_BIG_ENDIAN
+	elif grep -qs LiTTleEnDian .endian.o ; then
+		echo -DCRAMFS_LITTLE_ENDIAN
+	fi
+fi
+
+rm -f .endian.[co]
