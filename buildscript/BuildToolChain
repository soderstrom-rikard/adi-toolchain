#!/bin/sh
#Build Script - Rohit Makasana ( rohit.makasana@rrap-software.com )
#             - Modified by Bernd Schmidt (   )
#             - Modified by Robin Getz (rgetz@blackfin.uclinux.org)
#             - Modified by Jie Zhang (jie.zhang@analog.com)
#
#             - parts of this borrowed from the build-uclinux-tools.sh
#               written by David McCullough, Heiko Degenhardt,
#               Berndardo Innocenti, and Steve Miller
#
# This file is not an official part of GCC.
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
###############################################################

APP_NAME=$0
DIR_BOARDS=$(cd $(dirname $APP_NAME) && pwd)/boards/
APP_NAME=${APP_NAME#.}
APP_NAME=${APP_NAME#/}
START=$(date +%s)

#Uncomment only one of these
#TIMESTAMP=`date +%Y-%b-%d-%H-%M` # is YYYY_MMM_DD_HH_MM
TIMESTAMP=`date +%Y%m%d`       # is YYYY_MMM_DD

PREREQ_FILE="autoconf automake awk /bin/sh bison cp echo flex gcc gettext grep ln m4 make makeinfo mkdir msgfmt mv rm sed tail wc which pkg-config"
PREREQ_HW_TESTS=" ping rsh rcp"
PREREQ_HW_SIM_TESTS=" bc kill killall pstree runtest Xvfb"
BINUTILS_VERSION=2.17
GCC_VERSIONS=
NUM_JOBS=0
SKIP_DEV_CHECKS=false
WITHOUT_X=false
RESUME_BUILD=false
CBUILD= # the system we are compiling on
CHOST=  # the system the final compiler will run on

while getopts b:B:c:C:dDfH:hj:k:K:l:m:o:O:pP:r:s:StT:u:U:vwX parameter
do
    case $parameter in
        p)
            CHECK_PRE=true
            ;;
        m)
            MAKE=$OPTARG
            ;;
        w)
            WARN=1
            echo "Warnings being set to seperate log file"
            ;;
        d)
            DATE_STAMP=1
            echo "Outputfiles being date stamped"
            ;;
        D)
            SKIP_DEV_CHECKS=true
            ;;
        v)
            VERBOSE=1
            echo "Verbose output"
            ;;
        t)
            CHECK_ON_SIMULATOR=true
            ;;
        r)
            if [ ! -d $OPTARG ] ; then
                echo "Can't find old test results in $OPTARG"
                exit 1
            fi
            RESULTS2COMPARE=$OPTARG
            ;;
        S)
            SKIP_ELF=true
            ;;
        T)
            TARGET_IPADDR=`expr "$OPTARG" : "\([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\)"`
            if [ "x$TARGET_IPADDR" = "x" ] ; then
                echo "Target ip address in wrong format"
                exit 1
            fi
            CHECK_ON_HARDWARE=true
            ;;

        s)
            if [ -d $OPTARG ] ; then
                DIR_SOURCE=$OPTARG
                DIR_SOURCE=${DIR_SOURCE%/}
            else
                echo "Invalid Source Path"
                exit 1
            fi
            ;;
        l)
            TMP=`echo $OPTARG | grep c`
            if [ -n "$TMP" ] ; then
                TMP=`echo $OPTARG | sed {s/\,/\ /}`
                for RUN in $TMP
                do
                    if [ "$RUN" = "c" ] ; then
                         BFIN_LANGS=" --enable-languages=$OPTARG"
                    fi
                done
                if [ -z $BFIN_LANGS ] ; then
                    echo  "Must Build C Compiler $OPTARG"
                    exit 1
                fi
            else
                echo "Can't understand Language argument $OPTARG"
                exit 1
            fi
            ;;
        B)
            BINUTILS_VERSION="$OPTARG"
            ;;
        P)
            PKGVERSION="$OPTARG"
            ;;

        c)
            GCC_VERSIONS="$GCC_VERSIONS $OPTARG"
            ;;
        H)
            CHOST="$OPTARG"
            ;;
        k)
            KERNEL_SOURCE=$OPTARG
            if [ ! -d $KERNEL_SOURCE/arch/blackfin ] ; then
                echo "Can't find $KERNEL_SOURCE/arch/blackfin"
                exit 1
            fi
            ;;
        K)
            KERNEL_SOURCE=$OPTARG
            DIR_KBUILD_OUTPUT=$OPTARG
            if [ ! -d $KERNEL_SOURCE/usr/include/linux ] ; then
                echo "Can't find kernel headers"
                exit 1
            fi
            ;;
        u)
            if [ -f $OPTARG/tools/mkimage.c ] ; then
                DIR_UBOOT=$OPTARG
            else
                echo "Invalid U-Boot Path"
                exit 1
            fi
            ;;
        b)
            if [ -d $OPTARG ] ; then
                DIR_BUILD=$OPTARG
                DIR_BUILD=${DIR_BUILD%/}
            else
                DIR_BUILD=$OPTARG
                DIR_BUILD=${DIR_BUILD%/}
            fi
            ;;
        C)
            UCLIBC_CONFIG_FILE=$OPTARG
            ;;
        o)
            DIR_ELF_OUTPUT=$OPTARG-elf
            DIR_uC_OUTPUT=$OPTARG-uclinux
            DIR_LINUX_OUTPUT=$OPTARG-linux-uclibc
            ;;
        O)
            DIR_ELF_OUTPUT=$OPTARG
            DIR_uC_OUTPUT=$OPTARG
            DIR_LINUX_OUTPUT=$OPTARG
            ;;
        j)
            NUM_JOBS=$OPTARG
            ;;
        X)
            WITHOUT_X=true
            ;;
        f)
            STACK_CHECKING=true
            ;;
        U)
            UCLIBC_CFLAGS=$OPTARG
            ;;
        h)
# We don't document the -S option - it's for advanced users who know what
# they are doing.  For maximum reproducibility, not using it is better.
             echo "Usage : $APP_NAME -s SOURCE [-b BUILD]
-B BINUTILS_VER  Binutils version (default 2.17).  Can be given once.
-b BUILD         Build directory (leave blank to use current dir)
-C FILE          Use FILE as uClibc config file, rather than the default.
-c GCC_VERSION   GCC version (default 4.1).  Can be given multiple times.
-d               Date Stamp all output files
-D               Don't check libraries/headers -- assume all is OK
-f               Add stack checking to all tests
-h               Help
-H HOST          Build toolchain to run on HOST.
-j NUM           Pass -j NUM to make (default is 2x num of CPUs)
-K SOURCE        Kernel Header directory (may be specified instead of source)
-k SOURCE        Kernel Source directory    (builds bfin-uclinux-gcc)
-l LANGS         Only build specified gcc languages.
-m MAKE          Default make (leave blank to use system make)
-O OUTPUT        Output directory (leave blank to use build dir)
-o OUTPUT        Output directory prefix (leave blank to use build dir)
-p               Check prerequisites
-P STRING        Use STRING as the package version (instead of svn revision)
-r RESULTS_DIR   Compare current tests to old results
-s SOURCE        Toolchain Source directory (builds bfin-elf-gcc)"
# -S               Skip building elf compiler - don't print this out
echo "-T TARGET_IPADDR Test components on hardware
-t               Test components on simulator
-u SOURCE        Uboot Source directory"
# -U               uClibc CFLAGS - don't print this out
echo "-v               Verbose
-w               Warnings to be sent to a different log file
-X               Disable all graphical utilities
"
             exit 0
             ;;
        *)
             echo "unknown option $parameter"
             echo "Try \`$APP_NAME -h' for more information."
             exit 1
    esac
done

############ Check and error if I can't find the things I need #

resume_check()
{
	[ "${BTC_RESUME}" != "yesplease" ] && return 1
	__RESUME_FILE="$DIR_LOG/.resume.$(echo $1 | tr '[/]' '_')"
	[ -e "${__RESUME_FILE}" ]
}
resume_save()
{
	[ -n "${__RESUME_FILE}" ] && touch "${__RESUME_FILE}"
}
resume_clear()
{
	rm -f "$DIR_LOG"/.resume.*
}

check_cc_options() {
        if `${1} ${2} -S -o /dev/null -xc /dev/null > /dev/null 2>&1` ; then 
                return 1
        else
                return 0
        fi
}

check_header() {
	local header=$1
	printf "#include <$header>\n" | gcc -E - >/dev/null
}

check_lib() {
	local lib=$1 temp_file
	# Old Linux installations keep X in /usr/X11R6.
	temp_file=$(mktemp || echo "${TMPDIR-/tmp}/conftest.o")
	echo "int main(){}" | gcc -x c - -L/usr/X11R6/lib -L/sw/lib -l${lib} -o ${temp_file} >/dev/null
	local ret=$?
	rm -f "${temp_file}"
	return ${ret}
}

# check_group(package name, header list, library list)
check_source_group() {
	local pkg=$1
	local h headers=$2
	local l libs=$3
	local fail=0

	for h in ${headers} ; do
		check_header ${h} || fail=1
	done
	for l in ${libs} ; do
		check_lib ${l} || fail=1
	done

	if [ -n "${pkg}" ] && [ ${fail} -eq 1 ] ; then
		cat <<-EOF 1>&2
		
		You need to install some packages before building the toolchain.
		
		Your system lacks the development packages for:
		    ${pkg}
		
		The headers you need:
		    ${headers}
		
		The libs you need:
		    ${libs}
		
		EOF
		exit 1
	fi

	return ${fail}
}

check_source_packages() {
	echo "Checking for development packages (skip checks with the -D option)"
	check_source_group "zlib" "zlib.h" "z"
	check_source_group "curses" "ncurses.h" "ncurses"
	if ! check_source_group "" "X11/Xlib.h" "X11" ; then
		echo "X development packages were not found, disabling gui packages such as insight" 1>&2
		WITHOUT_X=true
	fi
}

${SKIP_DEV_CHECKS} || check_source_packages

if [ -n "$CHECK_PRE" ] ; then
    echo "Check http://gcc.gnu.org/install/prerequisites.html for more information"
    for file in $PREREQ_FILE $PREREQ_HW_TESTS $PREREQ_HW_SIM_TESTS
    do
        RUN=`which -a $file 2>/dev/null| wc -w`
        if [ $RUN -eq 0 ] ; then
            echo "!! $file: could not be found"
            for tmp in $PREREQ_FILE
            do
                if [ "$file" = "$tmp" ]; then
                    echo "!! you need to install package which includes ${file} before building the toolchain will be sucessful"
                fi
            done
        else
            tmp1=`echo $file | awk -F \/ '{print $NF}'`
            RUN=`type $tmp1 | grep "shell builtin" | wc -l`
            if [ $RUN -eq 1 ] ; then
                echo "   $file seems to be a shell builtin"
                continue
            fi
            for VER in --version -version -V
            do
                 tmp=`$file $VER < /dev/null 2>&1 | grep -ie "\<$tmp1\>" | grep -vi "option" | grep -vi "Usage" | grep -vi "\-v"`
                 if [ -n "$tmp" ] ; then
                     echo "  " $tmp
                     break
                 fi
            done
            if [ -n "$tmp" ] ; then
                continue
            fi

            for VER in --version -version -V
            do
                tmp=`$file $VER < /dev/null 2>&1 | grep -ie "version " | grep -vi "option" | grep -vi "Usage" | grep -vi "\-v"`
                if [ -n "$tmp" ] ; then
                    echo "  " $tmp
                    break
                fi
            done
            if [ -n "$tmp" ] ; then
                continue
            fi
            file=$(which $file)
            echo "** Could not find version of $file"
            while [ -L "$file" ] ; do
                printf " * "
                file $file
                lfile=$(readlink $file)
                [ "${lfile#/}" = "${lfile}" ] \
                    && file="${file%/*}/${lfile}" \
                    || file="${lfile}"
            done
            printf " * "
            file "${file}"
        fi
    done
    echo "   SHELL = $SHELL"
    echo "Done checking for prerequisites"
    exit 0
fi

if [ -n "$CHECK_ON_HARDWARE" ] ; then
    PREREQ_FILE=${PREREQ_FILE}${PREREQ_HW_TEST}
fi
if [ -n "$CHECK_ON_SIMULATOR" -o -n "$CHECK_ON_HARDWARE" ] ; then
    PREREQ_FILE=${PREREQ_FILE}${PREREQ_HW_SIM_TESTS}
fi

for PREREQ in $PREREQ_FILE $MAKE
do
    RUN=`which -a $PREREQ | wc -w`
    if [ $RUN -eq 0 ] ; then
        echo "Cannot find $PREREQ"
        exit 1
    else if [ $RUN -gt 1 ] ; then
        printf "Found multiple versions of $PREREQ, using the one at "
        which $PREREQ
        fi
    fi
done

############ Done checking - lets get on to building ###################3

if [ "${WITHOUT_X}" = "true" ] ; then
    BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-gdbtk"
    echo "Disabling gdbtk (insight)"
fi

if [ -z "$GCC_VERSIONS" ]; then
    GCC_VERSIONS=4.1
fi
printf "Building gcc versions $GCC_VERSIONS "

if [ -z "$BFIN_LANGS" ] ; then 
    # Don't set a default here ... let the build system
    # figure out the defaults by loading all languages.
    #BFIN_LANGS=" --enable-languages=c,c++"
    echo
else
    echo $BFIN_LANGS
fi

############ CHECK MAKE SET #####################################
if [ ! "$MAKE" ] ; then
    MAKE=make
fi
if [ "$NUM_JOBS" -eq "0" ] ; then
	NUM_JOBS=`grep -sc "^processor" /proc/cpuinfo`
	if [ -n "$NUM_JOBS" ] ; then
		NUM_JOBS=`expr $NUM_JOBS '*' 2`
	else
		NUM_JOBS=2
	fi
fi
export MAKEFLAGS="-j$NUM_JOBS $MAKEFLAGS"
echo "Utilizing make: $MAKE $MAKEFLAGS"

##### Check to make sure a old version of bfin-elf is not here
##### Unless we are cross-compiling our toolchain, then we need the
##### old toolchain in our PATH ...
ORG_PATH=$PATH
NEW_PATH=""
RUN=`echo $PATH | sed 's/:/ /g'`
FOUND=0
for SEARCH in $RUN
do
    if [ -d $SEARCH ] ; then
        FIND=`find $SEARCH/ -maxdepth 1 -name bfin-elf-gcc -o -name bfin-uclinux-gcc -o -name bfin-linux-uclibc-gcc | wc -c`
        if [ $FIND -gt 1 ] ; then
            FOUND=1
            if [ -z "$CHOST" ] ; then
                echo "Removing $SEARCH from the PATH"
            fi
        else
            if [ $NEW_PATH ] ; then
                NEW_PATH=$NEW_PATH:$SEARCH
            else
                NEW_PATH=$SEARCH
            fi
        fi
    fi
done
if [ -z "$CHOST" ] ; then
    NEW_PATH=$NEW_PATH:
    PATH=$NEW_PATH
elif [ "$FOUND" = "0" ] ; then
    echo "You need an existing Blackfin cross-compiler"
    echo " in order to cross-compile a cross-compiler."
    exit 1
else
    PATH=$ORG_PATH
    NEW_PATH=$ORG_PATH
fi

############ SOURCE MUST PROVIDED WITH COMMAND LINE ARGUMENT ###
if [ ! $DIR_SOURCE ] ; then
    echo "Usage : $APP_NAME -s SOURCE [-b BUILD]"
    echo "                  -h for help"
    exit 1
fi

############ ABSOLUTE PATH TO SOURCE DIRECTORIES ################

if [ -d /.$DIR_SOURCE ] ; then
    printf "Toolchain source is at      "
    echo $DIR_SOURCE
else
    echo "Invalid Toolchain Source Path"
    echo $DIR_SOURCE
    exit 1
fi
if [ $KERNEL_SOURCE ] ; then
    if [ -d /.$KERNEL_SOURCE ] ; then
        printf "Kernel source is at         "
        echo $KERNEL_SOURCE
    else
        echo "Invalid Kernel Source Path"
        echo $DIR_SOURCE
        exit 1
    fi
fi

############ ABSOLUTE PATH TO BUILD DIRECTORIES ################

if [ $DIR_BUILD ] ; then
    if [ -d /.$DIR_BUILD ] ; then
        printf "Build will be done in       "
        echo $DIR_BUILD
    else
        mkdir -p $DIR_BUILD
        if [ ! -d /.$DIR_BUILD ] ; then
            echo "Invalid Build Path, must be relative to the root dir"
            exit 1
        fi
    fi
else
    printf "Build will be done in       "
    echo ${DIR_BUILD=`pwd`}
fi

mk_output_dir()
{
    printf "%-28s%s\n" "Path to $1 output dir " "$2"
    if [ ! -d $2 ] ; then
        mkdir -p $2
        if [ ! -d /.$2 ] ; then
            echo "Invalid output directory, must be relative to the root dir"
            exit 1
        fi
    else
        if [ ! -d /.$2 ] ; then
            echo "Invalid Output Path, must be relative to the root dir"
            exit 1
        fi

        if [ "x$3" = "x" ] && ! ${RESUME_BUILD} ; then
            echo "$2 already exists - cleaning"
            rm -rf $2/*
        fi
    fi
}

############ RELATIVE PATH TO SOURCE DIRECTORIES ################
if [ ! $DIR_ELF_OUTPUT ] ; then
    DIR_ELF_OUTPUT=$DIR_BUILD/bfin-elf
fi
mk_output_dir "elf" $DIR_ELF_OUTPUT $SKIP_ELF

DIR_LOG=$DIR_BUILD/logs
if [ ! -d $DIR_LOG ] ; then
    mkdir $DIR_LOG
elif ! ${RESUME_BUILD} ; then
    rm -rf $DIR_LOG/*
    resume_clear
fi

# make sure we arent running on a case insensitive filesystem
cd $DIR_BUILD
rm -rf .case.test .CASE.test
echo case > .case.test
case=$(cat .CASE.test 2>/dev/null)
if [ "$case" = "case" ] ; then
	echo "ERROR: you must use a case sensitive filesystem"
	exit 1
fi
rm -rf .case.test .CASE.test

if [ "x$CHECK_ON_SIMULATOR" != "x" -o "x$CHECK_ON_HARDWARE" != "x" ] ; then
    echo "Path for test results       "
    DIR_TEST_RESULTS=$DIR_BUILD/tests
    if [ ! -d $DIR_TEST_RESULTS ] ; then
        mkdir $DIR_TEST_RESULTS
    fi
fi

if [ -n "$CHECK_ON_SIMULATOR" ] ; then
    if [ $DATE_STAMP ] ; then
        DIR_TEST_SIM_RESULTS=$DIR_TEST_RESULTS/simulator-$TIMESTAMP
    else
        DIR_TEST_SIM_RESULTS=$DIR_TEST_RESULTS/simulator
    fi
    if [ ! -d $DIR_TEST_SIM_RESULTS ] ; then
        mkdir $DIR_TEST_SIM_RESULTS
    else
        rm -rf $DIR_TEST_SIM_RESULTS/*
    fi
    echo "  on simulator: $DIR_TEST_SIM_RESULTS"
    if [ -n "$RESULTS2COMPARE" ] ; then
        if [ ! -d $RESULTS2COMPARE/simulator ] ; then
            echo "Can't find simulator results in $RESULTS2COMPARE/simulator"
            exit 1
        else
            if [ ! -d /.$RESULTS2COMPARE ] ; then
                echo "Invalid results path, must be relative to the root dir"
                exit 1
            fi
            echo "    checking simulator results against $RESULTS2COMPARE/simulator"
        fi
        for GCC_VERSION in $GCC_VERSIONS; do
            if [ ! -f $DIR_SOURCE/gcc-$GCC_VERSION/contrib/compare_tests ] ; then
                echo "Can't find $DIR_SOURCE/gcc-$GCC_VERSION/contrib/compare_tests"
                exit 1
            fi
        done
    fi
fi

if [ $CHECK_ON_HARDWARE ] ; then
    # stop if there are any Xvfb or rsh processes, which might be lurking around from old runs
    RUN=`ps aux | grep Xvfb | grep -v grep | wc -l`
    if [ $RUN -gt 0 ] ; then
        echo "Found $RUN old Xvfb process(s), before running, kill them"
        echo " so the hardware tests don't get confused"
        ps aux | grep Xvfb | grep -v grep ; killall -9 Xvfb
    fi
    RUN=`ps aux | grep rsh | grep -v grep | wc -l`
    if [ $RUN -gt 0 ] ; then
        echo "Found $RUN old rsh process(s), before running, kill them"
        echo " so the hardware tests don't get confused"
        ps aux | grep rsh | grep -v grep ; killall -9 rsh
    fi

    if [ $DATE_STAMP ] ; then
        DIR_TEST_HW_RESULTS=$DIR_TEST_RESULTS/hardware-flat-$TIMESTAMP
        DIR_TEST_HW2_RESULTS=$DIR_TEST_RESULTS/hardware-fdpic-$TIMESTAMP
    else
        DIR_TEST_HW_RESULTS=$DIR_TEST_RESULTS/hardware-flat
        DIR_TEST_HW2_RESULTS=$DIR_TEST_RESULTS/hardware-fdpic
    fi
    if [ ! -d $DIR_TEST_HW_RESULTS ] ; then
        mkdir $DIR_TEST_HW_RESULTS
    else
        rm -rf $DIR_TEST_HW_RESULTS/*
    fi
    if [ ! -d $DIR_TEST_HW2_RESULTS ] ; then
        mkdir $DIR_TEST_HW2_RESULTS
    else
        rm -rf $DIR_TEST_HW2_RESULTS/*
    fi
    echo "  on hardware ($TARGET_IPADDR): $DIR_TEST_HW_RESULTS, $DIR_TEST_HW2_RESULTS"

    # Check if target board is available using ping, rcp and rsh.
    RUN=`ping -n -c 1 $TARGET_IPADDR | grep -i Unreachable`
    if [ "x$RUN" != "x" ] ; then
        echo "Could not ping $TARGET_IPADDR - check network settings"
        exit 1
    fi
    RUN=`rsh -l root $TARGET_IPADDR /bin/ls / 2>/dev/null | wc -l`
    if [ $RUN -eq 0 ] ; then
        echo "Can't rsh to $TARGET_IPADDR, check rsh client on host, and inet on target"
        exit 1
    fi
    RUN=`rcp root@$TARGET_IPADDR:/bin/gdbserver $DIR_TEST_HW_RESULTS/gdbserver`
    if [ "x$RUN" != "x" ] ; then
        echo "Check gdbserver is available on the target, and you can rcp"
        exit 1
    fi
    if [ -f $DIR_TEST_HW_RESULTS/gdbserver ] ; then
        FDPIC_TARGET=`file $DIR_TEST_HW_RESULTS/gdbserver | grep ELF | wc -l`
        rm -f $DIR_TEST_HW_RESULTS/gdbserver
    fi
    RUN=`rsh -l root $TARGET_IPADDR "cat /proc/maps" | grep \/ | wc -l`
    FDPIC_TARGET=`expr $FDPIC_TARGET + $RUN`
    # Check if the tcp connections are recycled on both
    # target and host, which is needed to prevent the rsh
    # and rcp connection failures.

    printf "    checking host   /proc/sys/net/ipv4/tcp_tw_recycle : "
    RUN=`cat /proc/sys/net/ipv4/tcp_tw_recycle 2>/dev/null`
    if [ "x$RUN" = "x" ] ; then
        echo "NOT exist"
        echo "   Your host kernel does NOT support Sysctl"
        exit 1
    fi
    if [ "x$RUN" = "x0" ] ; then
        echo "0"
        echo "   Please run \"echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle\" as root"
        exit 1
    else
        echo "1 - looks OK"
    fi

    printf "    checking target /proc/sys/net/ipv4/tcp_tw_recycle : "
    RUN=`rsh -l root $TARGET_IPADDR cat /proc/sys/net/ipv4/tcp_tw_recycle 2>/dev/null`
    if [ "x$RUN" = "x" ] ; then
        echo "NOT exist"
        echo "   Please enable Sysctl when configure the kernel"
        exit 1
    fi
    if [ "x$RUN" = "x0" ] ; then
       printf "0. setting to 1 "
       rsh -l root $TARGET_IPADDR echo 1 \> /proc/sys/net/ipv4/tcp_tw_recycle
       RUN=`rsh -l root $TARGET_IPADDR cat /proc/sys/net/ipv4/tcp_tw_recycle 2>/dev/null`
       if [ "x$RUN" = "x0" ] ; then
	   echo "Failure"
           echo "Could not set target $TARGET_IPADDR /proc/sys/net/ipv4/tcp_tw_recycle to 1"
           exit 1
       else
           echo "Sucess"
       fi
    else
        echo "1 - looks OK"
    fi

    RUN=`rsh -l root $TARGET_IPADDR cat /proc/cpuinfo | grep vendor_id | head -1 | awk -F: '{print $2}' | sed 's/^ *//'`
    if [ "$RUN" != "Analog Devices" ] ; then
        echo "Target $TARGET_IPADDR doesn't appear to be a Blackfin - sorry"
        exit 1
    fi
    CPU_TYPE_REV=`rsh -l root $TARGET_IPADDR cat /proc/cpuinfo | grep model | awk '{print $4}' | sed 's/ADSP-//' | sed 's/BF/bf/'`
    RUN=`rsh -l root $TARGET_IPADDR cat /proc/cpuinfo | grep stepping | awk '{print $3}'`
    CPU_TYPE_REV=${CPU_TYPE_REV}-0.${RUN}
    echo "    Target $TARGET_IPADDR is $CPU_TYPE_REV, using that for testing multilib"

    if [ -n "$RESULTS2COMPARE" ] ; then
        if [ ! -d $RESULTS2COMPARE/hardware ] ; then
            echo "Can't find hardware results in $RESULTS2COMPARE/hardware"
            exit 1
        else
            echo "    checking hardware results against $RESULTS2COMPARE/hardware"
        fi
        for GCC_VERSION in $GCC_VERSIONS; do
            if [ ! -f $DIR_SOURCE/gcc-$GCC_VERSION/contrib/compare_tests ] ; then
                echo "Can't find $DIR_SOURCE/gcc-$GCC_VERSION/contrib/compare_tests"
                exit 1
            fi
        done
    fi
    if [ $STACK_CHECKING ] ; then
        echo "    Hardware tests will be compiled with optional stack overflow checking"
    fi
    if [ $FDPIC_TARGET -eq 0 ] ; then
        echo "    Looks like flat userspace - I'll check /lib/*.so are the same when testing"
    else
	echo "    Your Target looks like it is running FDPIC userspace - I can't test on fdpic targets. Stopping"
	exit 1
    fi

    RUN=`rsh -l root $TARGET_IPADDR "ps | grep syslog | grep -v grep | grep -v \"l 6\" | wc -l"`
    if [ $RUN = 1 ] ; then
        echo "    Board at ${TARGET_IPADDR} being set so syslog doesn't fill /var/log/messages"
        rsh -l root $TARGET_IPADDR "sed -i 's/^slog.*$/slog:unknown:\/sbin\/syslogd -n -l 6/' /etc/inittab"
        rsh -l root $TARGET_IPADDR "kill -HUP 1"
    fi
    rcp root@$TARGET_IPADDR:/var/log/messages $DIR_TEST_RESULTS/messages.boot
    rsh -l root $TARGET_IPADDR "rm /var/log/messages"
    rsh -l root $TARGET_IPADDR "touch /var/log/messages"
    rsh -l root $TARGET_IPADDR "kill -HUP 1"

    RUN=`rsh -l root $TARGET_IPADDR "ps" | grep -v " ps" | grep -v "/rshd" |
        grep -v "\[" | grep -v telnetd | grep -v "/init" | grep -v " inetd" |
        grep -v " PID " | grep -v "[ /]sh" | grep -v " /s*bin/.*d" | sed '/^[[:space:]]*$/d'`
    if [ ${#RUN} -gt 0 ] ; then
        echo " ** looks like random processes are running on the $TARGET_IPADDR already "
        echo " ** ${RUN}"
        echo " ** Aborting, since I get confused when this happens"
        exit 1
    fi
fi

printf "Path to binutils dir        "
DIR_BINUTILS_SOURCE=$DIR_SOURCE/binutils-$BINUTILS_VERSION
echo $DIR_BINUTILS_SOURCE
if [ ! -d $DIR_BINUTILS_SOURCE ] ; then
    echo "Can't find binutils source at $DIR_BINUTILS_SOURCE"
    exit 1
fi
CBUILD=$($DIR_BINUTILS_SOURCE/config.guess)
BUILD_TARGET="--build=${CBUILD}"
: ${CHOST:=${CBUILD}}
HOST_TARGET="--host=${CHOST}"

# libintl / libiconv handling in binutils-2.17 is broken for
# extraneous hosts ... it's been fixed in binutils-2.18, so
# once we update to that, we should be able to re-enable NLS
UCLIBC_HOSTUTILS="PASS"
case ${CHOST} in
    *mingw*)  BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-nls"; UCLIBC_HOSTUTILS="XFAIL";;
    *darwin*) BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-nls"; UCLIBC_HOSTUTILS="XFAIL";;
esac
# warnings with gcc-4.3 cause build failures
BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-werror"

for GCC_VER in $GCC_VERSIONS; do
    printf "Path to gcc-${GCC_VER} dir         "
    if [ -d $DIR_SOURCE/gcc-$GCC_VER ] ; then
        echo $DIR_SOURCE/gcc-$GCC_VER
    else
        echo missing
        exit 1
    fi
done

printf "Path to elf2flt dir         "
DIR_ELF2FLT_SOURCE=$DIR_SOURCE/elf2flt
echo $DIR_ELF2FLT_SOURCE
if [ ! -d $DIR_ELF2FLT_SOURCE ] ; then
    echo "Can't find elf2flt source at $DIR_ELF2FLT_SOURCE"
    exit 1
fi

printf "Path to uClibc dir          "
UCLIBC_SOURCE=$DIR_SOURCE/uClibc
echo $UCLIBC_SOURCE
if [ ! -d $UCLIBC_SOURCE ] ; then
    echo "Can't find uClibc source at $UCLIBC_SOURCE"
    exit 1
fi

if [ -z "$UCLIBC_CFLAGS" ] ; then
    UCLIBC_CFLAGS='-g -O2'
fi

printf "    uClibc CFLAGS           "
#We test (and warn) if any of the CFLAGS for uClibc don't work on the host compiler
for opt in $UCLIBC_CFLAGS
do
    check_cc_options gcc $opt
    if [ "$?" -eq "1" ] ; then
      printf "%s " "$opt"
    else
      printf "%s(bfin only?) " "$opt"
    fi
done
echo

printf "Path to genext2fs           "
DIR_GENEXT2FS_SOURCE=$DIR_SOURCE/genext2fs
echo $DIR_GENEXT2FS_SOURCE
if [ ! -d $DIR_GENEXT2FS_SOURCE ] ; then
    echo "Can't find genext2fs source at $DIR_GENEXT2FS_SOURCE"
    exit 1
fi

printf "Path to cramfs-tools        "
DIR_CRAMFS_SOURCE=$DIR_SOURCE/cramfs
echo $DIR_CRAMFS_SOURCE
if [ ! -d $DIR_CRAMFS_SOURCE ] ; then
    echo "Can't find cramfs source at $DIR_CRAMFS_SOURCE"
    exit 1
fi

printf "Path to ldr-utils           "
DIR_LDR_UTILS_SOURCE=$DIR_SOURCE/ldr-utils
echo $DIR_LDR_UTILS_SOURCE
if [ ! -d $DIR_LDR_UTILS_SOURCE ] ; then
    echo "Can't find ldr-utils source at $DIR_LDR_UTILS_SOURCE"
    exit 1
fi

printf "Path to gdbproxy            "
DIR_GDBPROXY_SOURCE=$DIR_SOURCE/gdbproxy
echo $DIR_GDBPROXY_SOURCE
if [ ! -d $DIR_GDBPROXY_SOURCE ] ; then
    echo "Can't find gdbproxy source at $DIR_GDBPROXY_SOURCE"
    exit 1
fi

printf "Path to libftdi             "
DIR_LIBFTDI_SOURCE=$DIR_SOURCE/libftdi
echo $DIR_LIBFTDI_SOURCE
if [ ! -d $DIR_LIBFTDI_SOURCE ] ; then
    echo "Can't find libftdi source at $DIR_LIBFTDI_SOURCE"
    exit 1
fi

printf "Path to jtag                "
DIR_JTAG_SOURCE=$DIR_SOURCE/jtag
echo $DIR_JTAG_SOURCE
if [ ! -d $DIR_JTAG_SOURCE ] ; then
    echo "Can't find jtag source at $DIR_JTAG_SOURCE"
    exit 1
fi

if [ $KERNEL_SOURCE ] ; then
    if [ ! $DIR_uC_OUTPUT ] ; then
        DIR_uC_OUTPUT=$DIR_BUILD/bfin-uclinux
        DIR_LINUX_OUTPUT=$DIR_BUILD/bfin-linux-uclibc
    fi
    mk_output_dir "uClinux" $DIR_uC_OUTPUT ""
    mk_output_dir "linux-uClibc" $DIR_LINUX_OUTPUT ""
    if [ ! $DIR_KBUILD_OUTPUT ] ; then
        DIR_KBUILD_OUTPUT=$DIR_BUILD/kernel_build
        mk_output_dir "kernel" $DIR_KBUILD_OUTPUT ""
    fi
    if [ $DIR_UBOOT ] ; then
      printf "Path to U-Boot Source       "
      echo $DIR_UBOOT
    else
      echo "U-Boot Source not specified: addon utilties (like 'mkimage') will not be built"
    fi
    if [ -z "$UCLIBC_CONFIG_FILE" ]; then
      echo "Path to uClibc Config files $UCLIBC_SOURCE/extra/Configs/"
    else
      if [ -f $UCLIBC_CONFIG_FILE ]; then
        echo "Path to uClibc config files $UCLIBC_CONFIG_FILE"
      else
        echo "Can't find uClibc config file at $UCLIBC_CONFIG_FILE"
        exit 1
      fi
    fi
fi

###################### set up log file ###########################

if [ $DATE_STAMP ] ; then
    echo "Creating log file           $DIR_LOG/log.$TIMESTAMP"
    if [ $VERBOSE ]; then
        LOGFILE="| tee -a $DIR_LOG/log.$TIMESTAMP"
        ACTUAL_LOGFILE=$DIR_LOG/log.$TIMESTAMP
    else
        if [ $WARN ] ; then
            echo "*** Warnings going to $DIR_LOG/warn.$TIMESTAMP"
            LOGFILE=">> $DIR_LOG/log.$TIMESTAMP 2>> $DIR_LOG/warn.$TIMESTAMP"
            ACTUAL_LOGFILE=$DIR_LOG/warn.$TIMESTAMP
        else
            LOGFILE=">> $DIR_LOG/log.$TIMESTAMP 2>&1"
            ACTUAL_LOGFILE=$DIR_LOG/log.$TIMESTAMP
        fi
    fi
else
    echo "Creating log file           $DIR_LOG/log"
    if [ $VERBOSE ]; then
        LOGFILE="| tee -a $DIR_LOG/log"
        ACTUAL_LOGFILE=$DIR_LOG/log
    else
        if [ $WARN ] ; then
            echo "*** Warnings going to $DIR_LOG/warn"
            LOGFILE=">> $DIR_LOG/log 2>> $DIR_LOG/warn"
            ACTUAL_LOGFILE=$DIR_LOG/warn
        else
            LOGFILE=">> $DIR_LOG/log 2>&1"
            ACTUAL_LOGFILE=$DIR_LOG/log
        fi
    fi
fi

############ RELATIVE PATH TO BUILD DIR ################

DIR_BINUTILS_BUILD=$DIR_BUILD/binutils_build
DIR_ELF2FLT_BUILD=$DIR_BUILD/elf2flt_build
DIR_GENEXT2FS_BUILD=$DIR_BUILD/genext2fs_build

# Add output dir so when building uclibc, it can find the toolchain
export PATH=$NEW_PATH:/$DIR_ELF_OUTPUT/bin:/$DIR_uC_OUTPUT/bin:/$DIR_LINUX_OUTPUT/bin

#################################################################
############## DONOT CHANGE ANYTHING BELOW THIS LINE ############
#################################################################

# Some helpful functions
requote() { printf "'%s' " "$@"; }

print_stop_time ()
{
    END=$(date +%s)
    DIFF=$(( $END - $START ))
    hours=$(( $DIFF / 3600 ))
    min=$(( ($DIFF - ( $hours * 3600 ) ) / 60))
    sec=$(( $DIFF - $min * 60 - $hours * 3600))
    if [ "$hours" -eq "0" ] ; then
        printf " $min:$sec "
    else
        printf " $hours:$min:$sec "
    fi

}
die_with_log ()
{
    [ -n "$*" ] && echo "$*"
    echo "Please report an error to http://blackfin.uclinux.org/gf/project/toolchain"
    printf " Build error " ; date
    printf "  occurred"
    print_stop_time
    echo "into script"

    # Create a single file so users can email it to us,
    # we sleep, so things can finish writing to the log file
    sleep 1
    tar -jhcf $DIR_LOG/config.logs.tbz2 `find $DIR_BUILD -name "config.log"` $ACTUAL_LOGFILE

    if [ "$NUM_JOBS" -eq "1" ]; then
        echo "When reporting issue, we may ask for $DIR_LOG/config.logs.tbz2"
        echo " Last logfile entries:"
        tail -10 $ACTUAL_LOGFILE
    else
        echo "Since the build was done in parallel, I'm not sure where the"
        echo "happened. The best thing to do is add a '-j 1' option to this"
        echo "BuildToolChain script, and try again."
    fi

    exit 1
}

log_it()
{
    # Note: embedded single quotes will break this
    eval "printf '###\n%s\n\n' '$*'" ${LOGFILE}
}

run_cmd()
{
    log_it "$@"
    # since logfile might contain redirection, we need to `eval`
    # since args might contain whitespace, we need to requote
    eval \($(requote "$@")\) ${LOGFILE} || die_with_log
}

check_installed_files()
{
    local pkg=$1 ; shift
    local pfx=$1 ; shift
    local f
    for f in "$@" ; do
        f="${pfx}${f}${EXEEXT}"
        if [ ! -f "${f}" ] ; then
            die_with_log "${pkg} did not build properly : Missing ${f}"
        fi
    done
}

change_dir()
{
    log_it cd "$@"
    cd "$@" || die_with_log
}
change_clean_dir()
{
    cd /
    rm -rf "$@"
    mkdir -p "$@"
    change_dir "$@"
}

echo_date()
{
    # if we can fit the msg on one line, then do it.  else,
    # try and split it on word boundaries.  if all else fails,
    # give it its own line.
    local recurse
    case $1 in
        -[rR]) recurse=$1; shift;;
    esac
    local date="$(date)"
    local msg="$*"
    local bytes_for_msg=$((${COLUMNS:-80} - ${#date} - 5))

    if [ -n "${recurse}" ] || [ ${#msg} -le ${bytes_for_msg} ] ; then
        local banner="***" full
        if [ -n "${recurse}" ] ; then
            [ ${#msg} -eq 0 ] && return 1
            [ "${recurse}" = "-r" ] && banner="   " date=""
        fi
        [ ${#msg} -gt ${bytes_for_msg} ] && full=${msg} msg=""
        if [ -n "${msg}" ] || [ "${recurse}" = "-R" ] ; then
            printf "%s %-${bytes_for_msg}s %s\n" "${banner}" "${msg}" "${date}"
        fi
        [ -n "${full}" ] && echo "   " ${full}
    else
        local split word
        recurse="-R"
        for word in ${msg} ; do
            if [ $((${#split} + ${#word})) -ge ${bytes_for_msg} ] ; then
                echo_date ${recurse} ${split} && recurse="-r"
                split=""
            fi
            split="${split} ${word}"
        done
        echo_date ${recurse} ${split}
        recurse=""
    fi

    [ -z "${recurse}" ] && log_it "${msg}"
    return 0
}

build_gcc ()
{
    resume_check bfin-$2.gcc-$1 && return 0

    DIR_GCC_SOURCE=$DIR_SOURCE/gcc-$1

    DIR_GCC_BUILD=$DIR_BUILD/gcc_build-$1
    change_clean_dir $DIR_GCC_BUILD

    # When doing a canadian cross, we have to use the toolchain on the host.
    # Since gcc is very picky about being compiled by another version, make
    # sure we compile this version with the same version on the host.
    if [ "${CBUILD}" != "${CHOST}" ] ; then
        p=$DIR_GCC_BUILD/.bfin.path
        mkdir $p
        for t in gcc g++ c++ gfortran ; do
            fullt=$(echo `which bfin-$2-$t`-$1.?)
            if [ ! -x "$fullt" ] ; then
                if [ "$t" = "gcc" ] ; then
                    die_with_log "You need to have gcc $1 installed in order to build it"
                else
                    continue
                fi
            fi
            printf '#!/bin/sh\nexec %s "$@"\n' "$fullt" > "$p/bfin-$2-$t"
            chmod a+rx $p/bfin-$2-$t
        done
        save_PATH=$PATH
        export PATH=$p:$PATH
    fi

    rm -f $DIR_GCC_SOURCE/newlib
    rm -f $DIR_GCC_SOURCE/libgloss

    if [ $2 = "elf" ]; then
        echo_date "Linking newlib and libgloss"
        ln -snf $DIR_BINUTILS_SOURCE/newlib $DIR_GCC_SOURCE/
        ln -snf $DIR_BINUTILS_SOURCE/libgloss $DIR_GCC_SOURCE/
        # check to make sure the copies were made
        if [ ! -d $DIR_GCC_SOURCE/newlib -o ! -d $DIR_GCC_SOURCE/libgloss ] ; then
            echo "*** ERROR : cannot link newlib or libgloss in $DIR_GCC_SOURCE"
            printf "*** ERROR : running as user "
            whoami
            ls -ld $DIR_GCC_SOURCE
            exit 1
        fi
        EXTRA_GCC_CONF="--enable-languages=c,c++"
    else
        EXTRA_GCC_CONF=""
    fi

    LOCALE="--enable-clocale=generic"
    if [ -n "$UCLIBC_CONFIG_FILE" ]; then
	if grep -qs UCLIBC_HAS_LOCALE=y $UCLIBC_CONFIG_FILE; then
	    LOCALE="--enable-clocale=uclibc"
	fi
    fi
    if [ -d "$DIR_GCC_SOURCE/.svn" ] ; then
        eval $(svn info "$DIR_GCC_SOURCE" 2>/dev/null | \
            sed -n \
                -e '/^URL:/s:.* .*/trunk/.*:SCM_URL=trunk:p' \
                -e '/^URL:/s:.* .*/branches/toolchain_\(.*\)_branch/.*:SCM_URL=\1:p' \
                -e '/^Last Changed Rev:/s:.* :SCM_REV=:p' \
        )
        [ -n "$SCM_REV" ] && SCM_REV="svn-${SCM_REV}"
    elif [ -d "$DIR_GCC_SOURCE/../.git" ] ; then
        eval $(cd "$DIR_GCC_SOURCE"; \
            SCM_URL=$(git branch | awk '$1 == "*" { sub(/^[*][[:space:]]*/, ""); gsub(/[()]/, ""); gsub(/[[:space:]]/, "-"); print; }')
            echo SCM_URL=${SCM_URL}
            echo SCM_REV=$(git rev-parse --short --verify HEAD)
        )
        [ -n "$SCM_REV" ] && SCM_REV="git-${SCM_REV}"
    fi
    [ -n "$SCM_URL" ] && SCM_URL="-${SCM_URL}"
    [ -n "$SCM_REV" ] && SCM_REV="/${SCM_REV}"
    [ -z "$PKGVERSION" ] && PKGVERSION="ADI${SCM_URL}${SCM_REV}"
    echo_date "Configuring GCC ($1)"
    RUN="$DIR_GCC_SOURCE/configure $BUILD_TARGET $HOST_TARGET --target=bfin-$2 \
      --prefix=$3 $4 --disable-libstdcxx-pch $BFIN_LANGS $EXTRA_GCC_CONF \
      --disable-symvers --disable-libssp --disable-libffi $LOCALE \
      --enable-version-specific-runtime-libs --enable-__cxa_atexit \
      --with-bugurl=URL:http://blackfin.uclinux.org/gf/project/toolchain/tracker \
      --with-pkgversion=${PKGVERSION}"
    run_cmd $RUN

    echo_date "Building GCC"
    run_cmd $MAKE

    eval `grep ^EXEEXT= $DIR_GCC_BUILD/gcc/config.log`
    FILE="cc1 collect2 gcov xgcc"
    if echo $BFIN_LANGS | grep -q c++ ; then
        FILE="${FILE} cc1plus cpp g++"
    fi
    check_installed_files gcc "$DIR_GCC_BUILD/gcc/" $FILE

    echo_date "Installing GCC"
    run_cmd $MAKE -j1 install

    # some basic sanity checks
    FILE="addr2line ar as c++filt gcov ld nm objdump \
          objcopy ranlib readelf size strings strip \
          gdb run \
          cpp gcc"
    if echo $BFIN_LANGS | grep -q c++ ; then
        FILE="${FILE} g++ c++"
    fi
    if [ "${WITHOUT_X}" = "false" ] ; then
        FILE="${FILE} insight"
    fi
    check_installed_files toolchain "$3/bin/bfin-$2-" $FILE

    if [ -e $DIR_GCC_SOURCE/gcc/BASE-VER ] ; then
        VERSION=`cat $DIR_GCC_SOURCE/gcc/BASE-VER`
    else
        VERSION=`$3/bin/bfin-$2-gcc -v 2>&1 | grep gcc.vers | sed -e 's,gcc.version.,,' -e 's, .ADI.*$,,'`
    fi
    if [ -e $3/bin/bfin-$2-g++$EXEEXT ]; then
        ln $3/bin/bfin-$2-g++$EXEEXT $3/bin/bfin-$2-g++-$VERSION$EXEEXT
        ln $3/bin/bfin-$2-c++$EXEEXT $3/bin/bfin-$2-c++-$VERSION$EXEEXT
    fi
    if [ -e $3/bin/bfin-$2-gfortran$EXEEXT ]; then
        ln $3/bin/bfin-$2-gfortran$EXEEXT $3/bin/bfin-$2-gfortran-$VERSION$EXEEXT
    fi

    # make sure the tcl baggage that comes with insight doesnt pollute our PATH.
    # note this isnt an issue as insight statically links in all of the TCL stuff
    # it actually needs and does not use these binaries at runtime.
	if ! ${WITHOUT_X} ; then
        (
        prefix=$3
        cd "${prefix}"/bin     && rm -f tclsh* wish*
        cd "${prefix}"/lib     && rm -f libitcl*.a libitk*.a libtcl*.a libtk*.a
        cd "${prefix}"/include && rm -f itcl*.h itk*.h tcl*.h tk*.h
        cd "${prefix}"/man     && rm -rf mann man1/tclsh.1 man1/wish.1
        grep -sl Tcl/Tk man3/* | xargs rm -f
        cd ..
        rmdir */* *
        ) 2>/dev/null
    fi

    if [ "${CBUILD}" != "${CHOST}" ] ; then
        PATH=$save_PATH
        rm -rf "$DIR_GCC_BUILD/.bfin.path"
    fi

    resume_save
}

# Build up a set of binutils
#  $1 - toolchain prefix (bfin-XXX-gcc)
#  $2 - configure --prefix=XXX
build_binutils()
{
	local target="bfin-$1"
	local prefix="$2"

	resume_check ${target}.binutils && return 0

	change_clean_dir $DIR_BINUTILS_BUILD

	# Blackfin doesn't utilize xml memory maps so disable this for now
	# to avoid the ABI differences between systems
	export ac_cv_libexpat=no

	case ${target} in
		bfin-elf) myconf="--without-newlib";;
		*)        myconf="--with-sysroot=${prefix}/${target}/runtime";;
	esac

	echo_date "Configuring $1 Binutils & GDB"
	run_cmd $DIR_BINUTILS_SOURCE/configure \
		$BUILD_TARGET $HOST_TARGET --target=${target} \
		--prefix=${prefix} ${myconf} $BINUTILS_EXTRA_CONF

	echo_date "Building $1 Binutils & GDB"
	run_cmd $MAKE all-binutils all-gas all-ld all-sim all-gdb

	eval `grep ^EXEEXT= $DIR_BINUTILS_BUILD/binutils/config.log`
	check_installed_files binutils "$DIR_BINUTILS_BUILD/binutils/" \
		addr2line ar cxxfilt nm-new objcopy objdump ranlib \
		readelf size strings strip-new
	check_installed_files gas "$DIR_BINUTILS_BUILD/gas/" as-new
	check_installed_files ld "$DIR_BINUTILS_BUILD/ld/" ld-new

	FILE="gdb"
	if [ "${WITHOUT_X}" = "false" ] ; then
		FILE="${FILE} insight"
	fi
	check_installed_files gdb "$DIR_BINUTILS_BUILD/gdb/" ${FILE}

	change_dir $DIR_BINUTILS_BUILD
	echo_date "Installing $1 Binutils & GDB"
	run_cmd $MAKE install-binutils install-gas install-ld install-sim install-gdb

	resume_save
}

build_elf2flt()
{
	local target="bfin-$1"
	local prefix="$2"

	resume_check ${target}.elf2flt && return 0

	echo_date "Building $1 elf2flt"
	change_clean_dir $DIR_ELF2FLT_BUILD
	touch -r . $DIR_ELF2FLT_SOURCE/* # fix autotool timestamps

	myconf=""
	if [ -e $DIR_BINUTILS_BUILD/intl/libintl.a ] ; then
		myconf="${myconf} --with-libintl=$DIR_BINUTILS_BUILD/intl/libintl.a"
	fi
	run_cmd $DIR_ELF2FLT_SOURCE/configure \
		$BUILD_TARGET $HOST_TARGET --target=${target} \
		--with-libbfd=$DIR_BINUTILS_BUILD/bfd/libbfd.a \
		--with-libiberty=$DIR_BINUTILS_BUILD/libiberty/libiberty.a \
		--with-bfd-include-dir=$DIR_BINUTILS_BUILD/bfd \
		--with-binutils-include-dir=$DIR_BINUTILS_SOURCE/include \
		--prefix=${prefix} --program-suffix= ${myconf}

	echo_date "Make $1 elf2flt"
	run_cmd $MAKE

	eval `grep ^EXEEXT= $DIR_ELF2FLT_BUILD/config.log`
	check_installed_files elf2flt "$DIR_ELF2FLT_BUILD/" elf2flt flthdr

	echo_date "Installing $1 elf2flt"
	run_cmd $MAKE install

	check_installed_files elf2flt "${prefix}/bin/${target}-" \
		elf2flt flthdr

	rm -rf $DIR_ELF2FLT_BUILD/*

	resume_save
}

# Compare two dotted version numbers.  Versions are .0 extended if they
# do not have the same number of components.  Return values are:
#	0 - versions are equal
#	1 - first version is larger
#	2 - second version is larger
compare_version()
{
	local v1=$1 v2=$2
	[ -z "${v1}${v2}" ] && return 0

	local _v1=${v1%%.*} _v2=${v2%%.*}
	: ${_v1:=0} ${_v2:=0}

	if [ ${_v1} -eq ${_v2} ] ; then
		v1=${v1#${_v1}}
		v2=${v2#${_v2}}
		compare_version ${v1#.} ${v2#.}
		return $?
	elif [ ${_v1} -gt ${_v2} ] ; then
		return 1
	elif [ ${_v1} -lt ${_v2} ] ; then
		return 2
	fi
}

# Install all shared libs found in the toolchain path $1 into the sysroot dir
# so that our later tools (like uclinux-dist) can easily find it.  Do not
# execute the target toolchain here so we do not have to worry about ugly
# canadian cross issues.  The toolchain prefix is passed in as $2.
install_all_target_libs()
{
	local dir=$1
	local base_gccdir="$1/lib/gcc/$2"
	local rundir="$1/$2/runtime"
	local reldir="../../../../$2/runtime"

	local readelf
	if [ "${CHOST}" != "${CBUILD}" ] ; then
		readelf=$2-readelf
	else
		readelf=$1/bin/$2-readelf
	fi

	find "${base_gccdir}" -name '*.so' | \
	while read flib ; do
		gccdir=${flib%/*}
		lib=${flib#${base_gccdir}/}
		gver=${lib%%/*}
		lib=${lib#${gver}}
		mdir=${lib%/*}
		mdir=${mdir#/}/
		[ "${mdir}" = "/" ] && mdir=""
		lib=${lib##*/}
		otarg=$(readlink "${flib}")
		ntarg=${otarg}.${gver}
		lver=${ntarg#${lib}.}
		tdir=${rundir}/${mdir}lib
		reltdir=$(echo "${mdir}" | sed 's:[^/]*/:../:g')${reldir}/${mdir}lib
		soname=$(${readelf} -d "${flib}" | sed -n '/(SONAME)/s:.*[[]\(.*\)[]].*:\1:p')

		# see if this library has been moved already ...
		# all symlinks in the gcc libdir should be relative
		# and contain no path elements
		if echo "${otarg}" | grep -q / ; then
			continue
		fi

		local movit=true
		if [ -e "${tdir}/${soname}" ] ; then
			old_lver=$(readlink "${tdir}/${soname}")
			old_lver=${old_lver#${lib}.}
			compare_version ${lver} ${old_lver}
			if [ $? -eq 1 ] ; then
				echo_date "Updating shared ${lib} (${lver})"
				rm "${tdir}/${lib}".*
			else
				movit=false
			fi
		else
			echo_date "Installing shared ${lib} (${lver})"
		fi
		if ${movit} ; then
			mv "${gccdir}/${otarg}" "${tdir}/${ntarg}"
			ln -s "${ntarg}" "${tdir}/${soname}"
		fi
		rm "${flib}"*
		ln -s "${reltdir}/${soname}" "${flib}"
	done
}

# If $1 is newer than $2, return 1. Otherwise, return 0.
is_newer ()
{
    MAJOR1=`echo $1 | sed 's/\([0-9]*\).*/\1/'`
    MINOR1=`echo $1 | sed 's/[0-9]*.\([0-9]*\).*/\1/'`
    PATCH1=`echo $1 | sed 's/[0-9]*.[0-9]*.\([0-9]*\).*/\1/'`
    MAJOR2=`echo $2 | sed 's/\([0-9]*\).*/\1/'`
    MINOR2=`echo $2 | sed 's/[0-9]*.\([0-9]*\).*/\1/'`
    PATCH2=`echo $2 | sed 's/[0-9]*.[0-9]*.\([0-9]*\).*/\1/'`

    if [ -z "$MAJOR1" -o -z "$MINOR1" -o -z "$PATCH1" -o -z "$MAJOR2" -o -z "$MINOR2" -o -z "$PATCH2" ]; then
	return 0;
    fi

    if [ "$MAJOR1" -lt "$MAJOR2" ]; then
	return 0;
    elif [ "$MAJOR1" -gt "$MAJOR2" ]; then
	return 1;
    elif [ "$MINOR1" -lt "$MINOR2" ]; then
	return 0;
    elif [ "$MINOR1" -gt "$MINOR2" ]; then
	return 1;
    elif [ "$PATCH1" -lt "$PATCH2" ]; then
	return 0;
    elif [ "$PATCH1" -gt "$PATCH2" ]; then
	return 1;
    else
	return 0;
    fi
}

# If $1 is compatible with $2, return 1. Otherwise, return 0.
is_compat ()
{
    MAJOR1=`echo $1 | sed 's/\([0-9]*\).*/\1/'`
    MINOR1=`echo $1 | sed 's/[0-9]*.\([0-9]*\).*/\1/'`
    PATCH1=`echo $1 | sed 's/[0-9]*.[0-9]*.\([0-9]*\).*/\1/'`
    MAJOR2=`echo $2 | sed 's/\([0-9]*\).*/\1/'`
    MINOR2=`echo $2 | sed 's/[0-9]*.\([0-9]*\).*/\1/'`
    PATCH2=`echo $2 | sed 's/[0-9]*.[0-9]*.\([0-9]*\).*/\1/'`

    if [ -z "$MAJOR1" -o -z "$MINOR1" -o -z "$PATCH1" -o -z "$MAJOR2" -o -z "$MINOR2" -o -z "$PATCH2" ]; then
	return 0;
    fi

    if [ "$MAJOR1" -eq "$MAJOR2" -a "$MINOR1" -eq "$MINOR2" ]; then
	return 1;
    else
	return 0;
    fi
}

# Install shared libstdc++ libraries into sysroot direcotory
# 1st argument is the toolchain install directory
# 2nd argument is the toolchain name

install_target_libs ()
{
    GCCS2=`find $1 -name bfin-linux-uclibc-gcc-* | tr '\n' ' '`
    GCCS=

    # First, restrict the list to eliminate the compiler versions which
    # don't provide the library at all.
    for GCC in $GCCS2; do
	TARGET_SHLIB=`$GCC --print-file-name=$3.so`

	if [ "$TARGET_SHLIB" != "$3.so" ]; then
	    GCCS="$GCCS $GCC"
	fi
    done

    while [ -n "$GCCS" ]; do
	GCCS2=""
	COMPAT_GCCS=""
	NEWEST_VERSION=""
	NEWEST_GCC=""

	for GCC in $GCCS; do
	    TARGET_SHLIB=`$GCC --print-file-name=$3.so`

	    TARGET_SHLIB=`readlink -f $TARGET_SHLIB`
	    TARGET_SHLIB_DIR=`dirname $TARGET_SHLIB`
	    TARGET_SHLIB_NAME=`basename $TARGET_SHLIB`
	    TARGET_SHLIB_VERSION=`echo $TARGET_SHLIB_NAME | sed s/$3.so.'\([0-9]*.[0-9]*.[0-9]*\).*/\1/'`

	    if [ -z "$NEWEST_VERSION" ]; then
		NEWEST_VERSION=$TARGET_SHLIB_VERSION
		NEWEST_GCC=$GCC
		COMPAT_GCCS=$GCC
		continue
	    fi

	    is_compat $TARGET_SHLIB_VERSION $NEWEST_VERSION
	    if [ $? -eq 1 ]; then
		COMPAT_GCCS="$COMPAT_GCCS $GCC"

		is_newer $TARGET_SHLIB_VERSION $NEWEST_VERSION
		if [ $? -eq 1 ]; then
		    NEWEST_VERSION=$TARGET_SHLIB_VERSION
		    NEWEST_GCC=$GCC
		fi
	    else
		GCCS2="$GCCS2 $GCC"
	    fi
	done

	GCCS=$GCCS2

	echo_date "Installing shared $3 ($NEWEST_VERSION)"

	MULTILIBS=`$NEWEST_GCC --print-multi-lib`

	for ml in $MULTILIBS; do

	    dir=`echo ${ml} | sed -e 's/;.*$//'`
	    flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`
	    if [ "$dir" = "." ]; then
		dir2=
	    else
		dir2=`echo ${dir} | sed -e 's|[^/]*|..|g'`/
	    fi

	    TARGET_SHLIB=`$NEWEST_GCC $flags --print-file-name=$3.so`
	    TARGET_SHLIB=`readlink -f $TARGET_SHLIB`
	    TARGET_SHLIB_DIR=`dirname $TARGET_SHLIB`
	    TARGET_SHLIB_NAME=`basename $TARGET_SHLIB`
	    TARGET_SHLIB_VERSION=`echo $TARGET_SHLIB_NAME | sed s/$3.so.'\([0-9]*.[0-9]*.[0-9]*\).*/\1/'`
	    MAJOR_NUM=`echo $TARGET_SHLIB_VERSION | sed 's/\([0-9]*\).*/\1/'`

	    RUN="cp $TARGET_SHLIB $1/$2/runtime/$dir/lib; \
	    ln -s $TARGET_SHLIB_NAME $1/$2/runtime/$dir/lib/$3.so.$MAJOR_NUM;"
            (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
            (echo "($RUN) $LOGFILE" ) | sh || die_with_log

	    for G in $COMPAT_GCCS; do
		L=`$G $flags --print-file-name=$3.so`
		RUN="rm -f `dirname $L`/$3.so*; \
		ln -s ../../../../$dir2$2/runtime/$dir/lib/$TARGET_SHLIB_NAME `dirname $L`/$3.so;"
                (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
                (echo "($RUN) $LOGFILE" ) | sh || die_with_log

	    done

	done
    done
}

# Install shared libgcc libraries into sysroot direcotory
# 1st argument is the toolchain install directory
# 2nd argument is the toolchain name
# FIXME: Only libgcc_s.so.1 is handled
install_libgccs ()
{
    GCCS=`find $1 -name bfin-linux-uclibc-gcc-* | tr '\n' ' '`

    NEWEST_VERSION=""
    NEWEST_GCC=""
    for GCC in $GCCS; do
	LIBGCC=`$GCC --print-file-name=libgcc_s.so`
	LIBGCC_DIR=`dirname $LIBGCC`
	GCC_VERSION=`basename $LIBGCC_DIR`
	
	if [ -z "$NEWEST_VERSION" ]; then
	   NEWEST_VERSION=$GCC_VERSION
	   NEWEST_GCC=$GCC
	   continue
	fi

	is_newer $GCC_VERSION $NEWEST_VERSION
	if [ $? -eq 1 ]; then
	    NEWEST_VERSION=$GCC_VERSION
	    NEWEST_GCC=$GCC
	fi
    done

    echo_date "Installing libgcc_s"

    MULTILIBS=`$NEWEST_GCC --print-multi-lib`

    for ml in $MULTILIBS; do

	dir=`echo ${ml} | sed -e 's/;.*$//'`
	flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`

	LIBGCC=`$NEWEST_GCC $flags --print-file-name=libgcc_s_$dir.so`
	if [ ! -e $LIBGCC ]; then
	    LIBGCC=`$NEWEST_GCC $flags --print-file-name=libgcc_s.so`
	fi
	if [ ! -e $LIBGCC ]; then
            echo "No libgcc_s.so for $NEWEST_GCC - report an error"
            tail -10 $ACTUAL_LOGFILE
            exit 1
	fi
	    
	LIBGCC=`readlink -f $LIBGCC`
	LIBGCC_DIR=`dirname $LIBGCC`
	LIBGCC_NAME=`basename $LIBGCC`

	run_cmd cp $LIBGCC $1/$2/runtime/$dir/lib

	for G in $GCCS; do
	    L=`$G $flags --print-file-name=libgcc_s_$dir.so`
	    dir2=
	    if [ ! -e $L ]; then
		L=`$G $flags --print-file-name=libgcc_s.so`
		if [ "$dir" != "." ]; then
		    dir2=`echo ${dir} | sed -e 's|[^/]*|..|g'`/
		fi
	    fi
	    RUN="rm -f $L*;\
	    ln -s ../../../../$dir2$2/runtime/$dir/lib/$LIBGCC_NAME $L"
            (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
            (echo "($RUN) $LOGFILE" ) | sh || die_with_log
	done
    done
}

# Some of the tests leave stuff all over the target file system,
# by getting rid of it, we free up lots of memory.
clean_hardware()
{
    hardware=`echo $1 | grep -i hardware`
    if [ -n "$hardware" ] ; then
        RUN=`rsh -l root $TARGET_IPADDR free`
        (echo "echo -e '###\n$RUN\nCleaning\n' $LOGFILE" ) | sh
        rsh -l root $TARGET_IPADDR "rm *" 2>/dev/null
        rsh -l root $TARGET_IPADDR "rm /tmp/*" 2>/dev/null
        RUN=`rsh -l root $TARGET_IPADDR free`
        (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh

        #we dump something onto the console so we can track which application caused a crash
        rsh -l root $TARGET_IPADDR "echo > /dev/console; echo "testing $1 $2" > /dev/console"
    fi

}

copy_test_results()
{
    for SUM in `find ./ -name "*.sum"` ; do
        SUM=${SUM%.sum}
        name=${SUM##*/}
        target=""
        # This loop builds up the target filename. based on the path, 
        # removing names that are pointless
        for SUBDIR in `echo $SUM | sed -e 's:^\./::' -e 's:/testsuite/:/:' -e 's/\// /g'` ; do
            case ${SUBDIR} in *${name}*) continue;; esac
                target=${target}${SUBDIR}-
        done
        target=${target}${name}
        cp ${SUM}.sum $1/${target}-${2}.sum
        cp ${SUM}.log $1/${target}-${2}.log
    done
}

# Get the target hardware ready for testing:
#  - check we can access it
#  - set syslogd & tcp_tw_recycle
#  - copy over all the shared libs to the target /lib dir (for fdpic tests, and if flat userspace)
# prepare_target test_target_dir
prepare_target()
{
    hardware=`basename $1 | grep -i hardware`
    if [ -n "$hardware" ] ; then
        # Check if target board is available using ping
        TIMEOUT=0
        RUN=`ping -n -c 1 $TARGET_IPADDR | grep -i Unreachable`
        while ([ "x$RUN" != "x" ] && [ $TIMEOUT -lt 5 ])
        do
            RUN=`ping -n -c 1 $TARGET_IPADDR | grep -i Unreachable`
            TIMEOUT=`expr $TIMEOUT + 1`
            sleep 60
        done
        if [ "x$RUN" != "x" ] ; then
            echo "Could not ping $TARGET_IPADDR - check network settings"
            exit 1
        fi

        # Just in case we caused the kernel under test to crash, let's do a sanity test
        # make sure syslogd is set to not log rsh/rcp as it will fill /var/log/messages
        RUN=`rsh -l root $TARGET_IPADDR "ps | grep syslog | grep -v grep | grep -v \"l 6\" | wc -l"`
        if [ "$RUN" = "1" ] ; then
            echo " ** Resetting syslogd"
            rsh -l root $TARGET_IPADDR "sed -i 's/^slog.*$/slog:unknown:\/sbin\/syslogd -n -l 6/' /etc/inittab"
            rsh -l root $TARGET_IPADDR "kill -HUP 1"
            #we dump something onto the console so we can track things
            rsh -l root $TARGET_IPADDR "echo > /dev/console; echo "Setting syslogd" > /dev/console"
        fi

        #  checking target /proc/sys/net/ipv4/tcp_tw_recycle
        RUN=`rsh -l root $TARGET_IPADDR cat /proc/sys/net/ipv4/tcp_tw_recycle 2>/dev/null`
        if [ "$RUN" = "0" ] ; then
            echo " ** Setting tcp_tw_recycle"
            rsh -l root $TARGET_IPADDR echo 1 \> /proc/sys/net/ipv4/tcp_tw_recycle
            #we dump something onto the console so we can track things
            rsh -l root $TARGET_IPADDR "echo > /dev/console; echo "Setting tcp_tw_recycle" > /dev/console"
        fi
    fi

    # Make sure all the shared libs are actually on the target, and are the same
    # if we are testing on the hardware
    RUN=`basename $1 | grep hardware-fdpic`
    if ([ -n "$RUN" ] && [ $FDPIC_TARGET -eq 0 ]) ; then

        for GCC_VERSION in $GCC_VERSIONS; do
           GCC_BUILD=$DIR_BUILD/gcc_build-$GCC_VERSION
           break
        done

        mkdir -p $GCC_BUILD/libs_for_target
        rm -f $GCC_BUILD/libs_for_target/*
        rsh -l root ${TARGET_IPADDR} "rm /lib/*so*"
        t=`$GCC_BUILD/gcc/xgcc -mcpu=${CPU_TYPE_REV} -print-file-name=libc.a`
        t=`dirname $t`/../..
        for FILE in $t/lib/*so*
        do
            if ([ -e $FILE ] && [ -h $FILE ]) ; then
		#don't check sym links
                LIB=`readlink $FILE`
                FILE=`basename $FILE`
                LIB=`basename $LIB`
                rsh -l root ${TARGET_IPADDR} "cd /lib; ln -s $LIB $FILE"
            else
                if [ -f $FILE ] ; then
                    LIB=`basename ${FILE}`
                    bfin-linux-uclibc-strip $FILE -o $GCC_BUILD/libs_for_target/${LIB}
                    BOARD_LIB=`rsh -l root ${TARGET_IPADDR} "md5sum /lib/${LIB} | awk '{print $1}'"`
                    TEST_LIB=`md5sum $GCC_BUILD/libs_for_target/${LIB}`
                    if [ "$BOARD_LIB" != "$TEST_LIB" ] ; then
                        echo "Libs on board are different, aborting tests"
                        echo "specifically ${LIB} and ${FILE}"
                        exit 1
                    fi
                fi
            fi
        done
        rm -rf $GCC_BUILD/libs_for_target
    fi

}
# The basic idea is that if things are not progressing at least every 10 minutes
# something is hung, and we should kill it, and tell the user what was stuck
#
check_tests_OK()
{
    PID=$1
    HOST_THRESHOLD=7
    TARGET_THRESHOLD=5
    WAIT=1
    WAIT_TARGET=1
    HARDWARE=`printf "%s" "$3" | grep -i hardware`
    # -n : numeric sort - kill the last process first
    # -A : use ASCII, not UTF-8 or VT100
    # -l : long lines (otherwise it cuts off at 132 char across
    # -p : show pids of children
    NEW=`pstree -n -A -l -p $PID`
    # grep -v "\["     : remove kernel threads
    # grep -v "/init"  : remove the init process
    # grep -v " inetd" : remove initd
    # grep -v "/rshd"  : remove rsh sesions
    # grep -v " ps"    : remove ps processes (so we don't care about us running ps)
    # grep -v " PID "  : remove the top line "  PID  Uid        VSZ Stat Command"
    # grep -v "[ /]sh" : remove shell (sh and /bin/sh) processes 
    # grep -v " /s*bin/.*d" : remove /bin/watchdogd /sbin/klogd /sbin/syslogd
    # sed '/^[[:space:]]*$/d' : remove blank lines
    if [ -n "$HARDWARE" ] ; then
        NEW_TARGET=`rsh -l root $TARGET_IPADDR "ps" | grep -v " ps" | grep -v "/rshd" |
            grep -v "\[" | grep -v telnetd | grep -v "/init" | grep -v " inetd" |
            grep -v " PID " | grep -v "[ /]sh" | grep -v " /s*bin/.*d" | sed '/^[[:space:]]*$/d'`
            if [ ${#NEW_TARGET} -gt 0 ] ; then
               echo " ** looks like random processes are running on the hardware already "
               echo " ** ${NEW_TARGET}"
            fi
    fi
    KILL=99999
    while [ 1 ]
    do
        OLD=$NEW
        OLD_TARGET=$NEW_TARGET
        NEW=`pstree -n -A -l -p $PID`
        if [ -n "$HARDWARE" ] ; then
            NEW_TARGET=`rsh -l root $TARGET_IPADDR "ps" 2>&1 | grep -v " ps" | grep -v "/rshd" |
                grep -v "\[" | grep -v telnetd | grep -v "/init" | grep -v " inetd" | 
                grep -v " PID " | grep -v "[ /]sh" | grep -v " /s*bin/.*d" | sed '/^[[:space:]]*$/d'`
        fi

        # Chedk on the Host - if the test is done - quit
        if [ -z "$NEW" ] ; then
            break;
        fi

        # Check on the Host - are we waiting?
        if [ "$NEW" = "$OLD" ] ; then
           WAIT=`expr $WAIT + 1`
        else
            if [ $WAIT -gt $HOST_THRESHOLD ] ; then
                echo " ** killing process $KILL_PID, seemed to fix things"
                echo " ** $KILL_PS"
                if [ -n "$HARDWARE" ] ; then
                    # make sure the board is not hung
                    RUN=`rsh -l root $TARGET_IPADDR "ls /  1>/dev/null" 2>&1 | wc -l`
                    if [ "$RUN" = "1" ] ; then
                        echo "*** I think the board or networked died during testing - sorry "
                        break
                    fi
                fi
            fi
            WAIT=1
            KILL=99999
        fi

        # Check Hardware
        if [ -n "$HARDWARE" ] ; then
            if [ "$NEW_TARGET" = "$OLD_TARGET" ] ; then
                WAIT_TARGET=`expr $WAIT_TARGET + 1`
            else
                if [ $WAIT_TARGET -gt $TARGET_THRESHOLD ] ; then
                    echo " ** killing processes on board seemed to help"
                fi
                WAIT_TARGET=1
            fi

            if [ $WAIT_TARGET -gt $TARGET_THRESHOLD ] ; then
                # This should catch no route to host, as well as connection refused
                STUCK=`echo ${NEW_TARGET} | grep "^${TARGET_IPADDR}" | wc -l`
                if [ $STUCK -gt 0 ] ; then
                    echo " ** looks like the board has been dead for $TARGET_THRESHOLD minutes"
                    break
                fi
                if [ ${#NEW_TARGET} -gt 0 ] ; then
                    printf " ** looks like "
                    for TARGET_PID in $(echo ${NEW_TARGET} | awk '{print $NF}')
                    do
                        printf "${TARGET_PID} "
                    done
                    echo "on the board is hung"
                    for TARGET_PID in $(echo ${NEW_TARGET} | awk '{print $1}')
                    do
                       rsh -l root $TARGET_IPADDR "kill -9 ${TARGET_PID}"
                    done
                else
                    # the board has been doing nothing for 7 minutes, so let's wait another 7
                    WAIT_TARGET=1
                fi
            fi
        fi

        if [ $WAIT -gt $HOST_THRESHOLD ] ; then
            KILL_PS=""
            TREE=`pstree -n -A -l -p $PID | sed -e 's/-[-+]-/\n/g' -e 's/^[ \t]*//'`
            NEW_KILL=`printf "$TREE" | wc -l`
            if [ $NEW_KILL -lt $KILL ] ; then
                # We add one, so when we subtract one below, it ends up being the correct number
                KILL=`expr $NEW_KILL + 1`
                echo " ** Testing $2 seems stuck, trying to kill some processes"
            fi

            # don't try to kill defunct processes - it is a waste of time
            while [ -z "$KILL_PS" ]
            do
                KILL=`expr $KILL - 1`
                if [ "$KILL" = "0" ] ; then
                    echo "Test did not exit properly"
                    exit 1
                fi

                KILL_PID=`echo "$TREE" | sed -n "${KILL}{p;q}" | awk -F\( '{print $NF}' | awk -F\) '{print $1}'`
                KILL_PS=`ps $KILL_PID | grep -v "^[[:space:]]*PID" | grep -v " Z.*<defunct>"`
            done

            ps aux > $3/${2}.kill-${KILL_PID}
            pstree -n -A -l -p $PID >> $3/${2}.kill-${KILL_PID}
            if [ -n "$HARDWARE" ] ; then
                rsh -l root $TARGET_IPADDR ps >> $3/${2}.kill-${KILL_PID}
            fi
            # if it is an rsh process on the host, it normally means a test is
            # hung on the board, so let's kill that instead
            RUN=`echo $KILL_PS | grep rsh`
            if [ -n "$RUN" ] ; then
                echo " ** This should never happen - board seems OK, but rsh process is stuck?"
                if [ ${#NEW_TARGET} -gt 0 ] ; then
                    printf " ** looks like "
                    for TARGET_PID in $(echo ${NEW_TARGET} | awk '{print $NF}')
                    do
                        printf "${TARGET_PID} "
                    done
                    echo "on the board is hung"
                    for TARGET_PID in $(echo ${NEW_TARGET} | awk '{print $1}')
                    do
                       rsh -l root $TARGET_IPADDR "kill -9 ${TARGET_PID}"
                    done
                else
                    # The board just rebooted ?
                    echo " ** I think I just caused the board to crash/reboot? This needs investigation."
                    prepare_target $3 
                    kill -9 $KILL_PID
                fi
            else
                kill -9 $KILL_PID
            fi
        fi
        sleep 60
    done

    # Tests are complete - so let's copy crashes to test directory
    hardware=`echo $3 | grep -i hardware`
    if [ -n "$hardware" ] ; then
        RUN=`rsh -l root $TARGET_IPADDR ps | grep syslog | grep -v grep | wc -l`
        if [ $RUN = 1 ] ; then
            rcp root@$TARGET_IPADDR:/var/log/messages $3/$2.kernel_log
            rsh -l root $TARGET_IPADDR "rm /var/log/messages"
            rsh -l root $TARGET_IPADDR "touch /var/log/messages"
            rsh -l root $TARGET_IPADDR "kill -HUP 1"
        fi
    fi

    TREE=`pstree -n -A -l -p $PID | sed -e 's/-[-+]-/\n/g' -e 's/^[ \t]*//' -e '/^[[:space:]]*$/d' | awk -F "(" '{print $NF}' | awk -F ")" '{print $1}'`
    if [ ${#TREE} -gt 0 ] ; then
        echo " ** Aborting remaining tests"
        echo $TREE
        for KILL_PS in ${TREE}
        do
            RUN=`ps $KILL_PS | grep -v "^[[:space:]]*PID" | wc -l`
            if [ $RUN -gt 0 ] ; then
               ps $KILL_PS | grep -v "^[[:space:]]*PID"
               kill $KILL_PS
            fi
        done
    fi

}

# run_tests $directory_test_results_go_in name_of_test
run_tests ()
{
    clean_hardware $2 binutils
    prepare_target $2

    echo_date "Running tests on binutils"

    change_dir $DIR_BINUTILS_BUILD
    RUN="$MAKE -k -j 1 maybe-check-binutils maybe-check-gas maybe-check-ld maybe-check-sim"
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh &
    check_tests_OK $! binutils $1

    # make clean the gdb dir before testing since insight cannot run
    # in the build directory. :(
    change_dir $DIR_BINUTILS_BUILD/gdb
    RUN="$MAKE clean"
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh

    # Get rid of old Xvfb & rsh processes, which might be lurking around from old runs
    RUN=`ps aux | grep Xvfb | grep -v grep | wc -l`
    if [ $RUN -gt 0 ] ; then
        echo "Found old Xvfb process, killing it"
        RUN="ps aux | grep Xvfb | grep -v grep ; killall -9 Xvfb"
        (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
        (echo "($RUN) $LOGFILE" ) | sh
    fi
    RUN=`ps aux | grep rsh | grep -v grep | wc -l`
    if [ $RUN -gt 0 ] ; then
        echo "Found old rsh process, killing it"
        RUN="ps aux | grep rsh | grep -v grep ; killall -9 rsh"
        (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
        (echo "($RUN) $LOGFILE" ) | sh
    fi

    clean_hardware $2 gdb
    echo_date "Running tests on gdb"

    RUN="$MAKE -k -j 1 check"
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh &
    check_tests_OK $! gdb $1

    change_dir $DIR_BINUTILS_BUILD
    copy_test_results $1 $BINUTILS_VERSION

    for GCC_VERSION in $GCC_VERSIONS; do
        clean_hardware $2 gcc
        DIR_GCC_BUILD=$DIR_BUILD/gcc_build-$GCC_VERSION
        change_dir $DIR_GCC_BUILD/gcc

        # start the tests
        echo_date "Running tests on gcc $GCC_VERSION"
        RUN="$MAKE -k -j 1 check"
        (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
        (echo $RUN $LOGFILE ; ) | sh &
        check_tests_OK $! gcc $1

	clean_hardware $2 libs
	change_dir $DIR_GCC_BUILD
	echo_date  "Running tests on libs"
        RUN="$MAKE -k -j 1 check-target"
        (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
        (echo $RUN $LOGFILE ; ) | sh &
        check_tests_OK $! libraries $1

        copy_test_results $1 ${GCC_VERSION}
    done
    clean_hardware $2 done

    echo_date "Done testing  - results"
        
    #we dump something onto the console so we can know the test is finished.
    rsh -l root $TARGET_IPADDR "echo > /dev/console; echo "Done testing." > /dev/console"

    for FILE in `find $1 -name "*${BINUTILS_VERSION}.sum" | sort; find $1 -name "*${GCC_VERSION}.sum" | sort`
    do
	echo
	echo ${FILE##*/}
        egrep "=== .*Sum.* ===|^# of" $FILE
        if [ -n "$RESULTS2COMPARE" ] ; then
            COMP=`basename $FILE`
            if [ -f $RESULTS2COMPARE/$2/$COMP ] ; then
                echo "Comparing generated $COMP to master at $RESULTS2COMPARE/$2/$COMP"
                $DIR_SOURCE/gcc-$GCC_VERSION/contrib/compare_tests \
                    $FILE $RESULTS2COMPARE/$2/$COMP
            else
                echo "Could not find $RESULTS2COMPARE/$2/$FILE to compare"
            fi
        fi
    done
    echo
}

build_uClibc()
{
    ARGS="V=1 CROSS=bfin-elf- DEVEL_PREFIX=/usr/ RUNTIME_PREFIX=/ ARCH_CFLAGS='$UCLIBC_CFLAGS'"

    echo_date "Cleaning uClibc"
    run_cmd $MAKE clean $ARGS

    echo_date "Building uClibc"
    if ! grep -qs UCLIBC_HAS_LOCALE=y .config ; then
        # sometimes uClibc dies on parallel build, so lets build it with -j1
        run_cmd $MAKE $ARGS -j 1
    else
        echo_date "Building Locale"
        run_cmd $MAKE headers $ARGS

        change_dir extra/locale
        run_cmd $MAKE clean

        if [ ! -f ./codesets.txt ] ; then
            echo "      Creating codesets.txt"
            find ./charmaps -name "*.pairs" > ./codesets.txt
        fi
        if [ ! -f ./locales.txt ] ; then
            echo "      Creating locales.txt"
            cp ./LOCALES ./locales.txt
        fi

        run_cmd $MAKE $ARGS

        change_dir ../..
        run_cmd $MAKE all $ARGS -j 1
    fi

    echo_date "Installing uClibc"
    run_cmd $MAKE install DESTDIR=$1/runtime SUFFIX=$2 $ARGS

    # Need a way to look at uClibc make system , and see what libs
    # should be created
    EXEEXT=""
    check_installed_files uClibc "$1/runtime/$2/usr/lib/$3/" \
        crt1.o libc.a libcrypt.a libm.a libnsl.a libresolv.a libutil.a
}

###################### Setting up test  ##########################

if [ "x$CHECK_ON_SIMULATOR" != "x" -o "x$CHECK_ON_HARDWARE" != "x" ] ; then
    echo "Setting up site.exp"
    if [ ! -d $DIR_BUILD/boards ] ; then
        mkdir $DIR_BUILD/boards
    fi
    if [ $CHECK_ON_SIMULATOR ] ; then
        cp $DIR_BOARDS/bfin-sim.exp $DIR_BUILD/boards/bfin-sim.exp
    fi
    if [ $CHECK_ON_HARDWARE ] ; then
        if [ $STACK_CHECKING ] ; then
            (cat $DIR_BOARDS/bfin-uclinux.exp.1; \
             echo "set_board_info cflags \" -mstack-check-l1 \""; \
             echo "set_board_info hostname $TARGET_IPADDR"; \
             echo "set_board_info sockethost $TARGET_IPADDR:") > $DIR_BUILD/boards/bfin-uclinux.exp
            (cat $DIR_BOARDS/bfin-linux-uclibc.exp.1; \
             echo "set_board_info cflags \" -mstack-check-l1 \""; \
             echo "set_board_info multilib_flags \"-mcpu=$CPU_TYPE_REV\"";\
             echo "set_board_info hostname $TARGET_IPADDR"; \
             echo "set_board_info sockethost $TARGET_IPADDR:") > $DIR_BUILD/boards/bfin-linux-uclibc.exp
        else
            (cat $DIR_BOARDS/bfin-uclinux.exp.1; \
             echo "set_board_info hostname $TARGET_IPADDR"; \
             echo "set_board_info sockethost $TARGET_IPADDR:") > $DIR_BUILD/boards/bfin-uclinux.exp
            (cat $DIR_BOARDS/bfin-linux-uclibc.exp.1; \
             echo "set_board_info multilib_flags \"-mcpu=$CPU_TYPE_REV\"";\
             echo "set_board_info hostname $TARGET_IPADDR"; \
             echo "set_board_info sockethost $TARGET_IPADDR:") > $DIR_BUILD/boards/bfin-linux-uclibc.exp
        fi
    fi
    (cat $DIR_BOARDS/site.exp.1; \
     echo "lappend boards_dir \"$DIR_BUILD/boards\""; \
     cat $DIR_BOARDS/site.exp.2 ) > $DIR_BUILD/boards/site.exp
    export DEJAGNU=$DIR_BUILD/boards/site.exp
fi

if [ "x$SKIP_ELF" = "x" ]; then

    ################ Step 1 - ELF Toolchain #########################
    build_binutils elf $DIR_ELF_OUTPUT

    for GCC_VERSION in $GCC_VERSIONS; do
      build_gcc $GCC_VERSION elf $DIR_ELF_OUTPUT "--with-newlib"
    done

    build_elf2flt elf $DIR_ELF_OUTPUT

    ########################### Step 2 - done ####################

    if [ $CHECK_ON_SIMULATOR ] ; then
	echo "*** Testing on simulator            "
	run_tests $DIR_TEST_SIM_RESULTS simulator
    fi
fi

for GCC_VERSION in $GCC_VERSIONS; do
    DIR_GCC_BUILD=$DIR_BUILD/gcc_build-$GCC_VERSION
    rm -rf $DIR_GCC_BUILD/*
done

# We cannot remove newlib symlink until the bfin-elf tests finishs.
for GCC_VERSION in $GCC_VERSIONS; do
  DIR_GCC_SOURCE=$DIR_SOURCE/gcc-$GCC_VERSION
  if [ -h $DIR_GCC_SOURCE/newlib ] ; then
      rm $DIR_GCC_SOURCE/newlib
  fi
done

if [ "${CHOST}" = "${CBUILD}" ] ; then
  printf "*** Checking uClibc CFLAGS:"
  #We test (and fail) if any of the CFLAGS for uClibc don't work on the bfin-elf compiler
  for opt in $UCLIBC_CFLAGS
  do
      check_cc_options $DIR_ELF_OUTPUT/bin/bfin-elf-gcc $opt
      if [ "$?" -eq "0" ] ; then
        printf "\n"
        echo "I could not make option $opt work on the bfin-elf compiler, so I can't use it for uClibc"
        printf "halting after "
        print_stop_time
        printf "\n"
        exit
      else
        printf " $opt"
      fi
  done
  printf " OK\n"
fi

####################### Done Step 1  #########################


if [ $KERNEL_SOURCE ] ; then
    if [ "$DIR_KBUILD_OUTPUT" != "$KERNEL_SOURCE" ] && ! resume_check linux-headers ; then
	echo_date "Configuring Linux Kernel"

	change_dir $KERNEL_SOURCE
	run_cmd \
		$MAKE -j1 \
		headers_check headers_install \
		INSTALL_HDR_PATH=$DIR_KBUILD_OUTPUT/usr \
		KBUILD_OUTPUT=$DIR_KBUILD_OUTPUT \
		CROSS_COMPILE=bfin-elf- \
		ARCH=blackfin
	find "$DIR_KBUILD_OUTPUT/usr" -type f -name '.check.*' -print0 | xargs -0 rm -f
	change_dir ..

	resume_save
    fi


    ####################### Step 3 - build uClibc ################

    change_dir $UCLIBC_SOURCE

    if [ -n "$UCLIBC_CONFIG_FILE" ]; then
      cp $UCLIBC_CONFIG_FILE .tmp.config.provided
      mv -f .config .config.bk
      cat .tmp.config.provided | grep -v '^\(# \|\)\(HAVE_NO_SHARED\|HAVE_NO_PIC\|DOPIC\|HAVE_SHARED\|TARGET_SUBARCH\|BUILD_UCLIBC_LDSO\|SUPPORT_LD_DEBUG\|FORCE_SHAREABLE_TEXT_SEGMENTS\|RUNTIME_\|DEVEL_\|MULTILIB\|KERNEL_HEADERS\|LDSO_RUNPATH\|SHARED_LIB_LOADER_PREFIX\|UCLIBC_EXTRA_CFLAGS\)' |grep -v UCLIBC_FORMAT_ >.config.in
      echo 'RUNTIME_PREFIX="/"' >>.config.in
      echo 'DEVEL_PREFIX="/usr/"' >>.config.in
    fi

    MULTILIBS=`bfin-elf-gcc --print-multi-lib`

    for ml in $MULTILIBS; do

	dir=`echo ${ml} | sed -e 's/;.*$//'`
	suffix=`echo ${dir} | sed -e 's/\//_/g'`
	flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`

	if echo "${dir}" | grep -q bf561; then
	    continue
	fi

	resume_check uclibc.${dir} && continue

	echo_date "Configuring uClibc for ${dir}"

	if echo "${flags}" | grep -q mfdpic; then

	    dir2=`echo ${dir} | sed -e 's/mfdpic//' -e 's|/$||'`

	    if [ -z "$UCLIBC_CONFIG_FILE" ]; then
		cp extra/Configs/Config.bfinfdpic.default .config
	    else
		cp .config.in .config
		echo 'FORCE_SHAREABLE_TEXT_SEGMENTS=y' >>.config
		echo 'LDSO_LDD_SUPPORT=y' >>.config
		echo 'LDSO_CACHE_SUPPORT=y' >>.config
		echo '# LDSO_RUNPATH is not set' >>.config
		echo 'HAVE_SHARED=y' >>.config
		echo 'UCLIBC_BUILD_RELRO=y' >>.config
		echo 'UCLIBC_STATIC_LDCONFIG=y' >>.config
		echo 'DOPIC=y' >>.config
		echo 'LDSO_BASE_FILENAME="ld.so"' >>.config
		echo 'SHARED_LIB_LOADER_PREFIX="/lib"' >>.config
		echo 'SUPPORT_LD_DEBUG=y' >>.config
	    fi
	    echo 'UCLIBC_FORMAT_FDPIC_ELF=y' >>.config
	    echo '# UCLIBC_FORMAT_FLAT is not set' >>.config
	    echo '# UCLIBC_FORMAT_SHARED_FLAT is not set' >>.config
	    echo '# UCLIBC_FORMAT_FLAT_SEP_DATA is not set' >>.config
	    echo "KERNEL_HEADERS=\"$DIR_KBUILD_OUTPUT/usr/include\"" >>.config
	    echo "MULTILIB=\"\"" >>.config
	    echo "UCLIBC_EXTRA_CFLAGS=\"${flags}\"" >>.config

	    run_cmd $MAKE oldconfig CROSS=bfin-elf- </dev/null

	    cp .config .config-used-for_${suffix}

	    build_uClibc $DIR_LINUX_OUTPUT/bfin-linux-uclibc "${dir2}" ""

	elif echo "${flags}" | grep -q msep-data; then   

	    if [ -z "$UCLIBC_CONFIG_FILE" ]; then
		cp extra/Configs/Config.bfin.default .config
	    else
		cp .config.in .config
	    fi
	    echo 'UCLIBC_FORMAT_FLAT_SEP_DATA=y' >>.config
	    echo '# UCLIBC_FORMAT_FDPIC_ELF is not set' >>.config
	    echo '# UCLIBC_FORMAT_SHARED_FLAT is not set' >>.config
	    echo '# UCLIBC_FORMAT_FLAT is not set' >>.config
	    echo "KERNEL_HEADERS=\"$DIR_KBUILD_OUTPUT/usr/include\"" >>.config
	    echo "MULTILIB=\"${dir}\"" >>.config
	    echo "UCLIBC_EXTRA_CFLAGS=\"${flags}\"" >>.config

	    run_cmd $MAKE oldconfig CROSS=bfin-elf- </dev/null

	    cp .config .config-used-for_${suffix}

	    build_uClibc $DIR_uC_OUTPUT/bfin-uclinux "" "${dir}"

	elif echo "${flags}" | grep -q mleaf-id-shared-library; then

	    echo "FIXME: leaf-id-shared-library uClibc is not built"

	elif echo "${flags}" | grep -q mid-shared-library; then

	    if [ -z "$UCLIBC_CONFIG_FILE" ]; then
		cp extra/Configs/Config.bfin.default .config
	    else
		cp .config.in .config
	    fi
	    echo 'UCLIBC_FORMAT_SHARED_FLAT=y' >>.config
	    echo '# UCLIBC_FORMAT_FDPIC_ELF is not set' >>.config
	    echo '# UCLIBC_FORMAT_FLAT is not set' >>.config
	    echo '# UCLIBC_FORMAT_FLAT_SEP_DATA is not set' >>.config
	    echo "KERNEL_HEADERS=\"$DIR_KBUILD_OUTPUT/usr/include\"" >>.config
	    echo "MULTILIB=\"${dir}\"" >>.config
	    echo "UCLIBC_EXTRA_CFLAGS=\"${flags}\"" >>.config

	    run_cmd $MAKE oldconfig CROSS=bfin-elf- </dev/null

	    cp .config .config-used-for_${suffix}

	    build_uClibc $DIR_uC_OUTPUT/bfin-uclinux "" "${dir}"

	else

	    # Vanila FLAT format
	    if [ -z "$UCLIBC_CONFIG_FILE" ]; then
		cp extra/Configs/Config.bfin.default .config
	    else
		cp .config.in .config
	    fi
	    echo 'UCLIBC_FORMAT_FLAT=y' >>.config
	    echo '# UCLIBC_FORMAT_FDPIC_ELF is not set' >>.config
	    echo '# UCLIBC_FORMAT_SHARED_FLAT is not set' >>.config
	    echo '# UCLIBC_FORMAT_FLAT_SEP_DATA is not set' >>.config
	    echo "KERNEL_HEADERS=\"$DIR_KBUILD_OUTPUT/usr/include\"" >>.config
	    echo "MULTILIB=\"${dir}\"" >>.config
	    echo "UCLIBC_EXTRA_CFLAGS=\"${flags}\"" >>.config

	    run_cmd $MAKE oldconfig CROSS=bfin-elf- </dev/null

	    cp .config .config-used-for_${suffix}

	    build_uClibc $DIR_uC_OUTPUT/bfin-uclinux "" "${dir}"

	fi

	resume_save
    done

    # update the kernel header path just to make rebuilding easier later on
    sed -i.tmp '/^KERNEL_HEADERS/s:=.*:="'"$DIR_uC_OUTPUT/bfin-uclinux/runtime/usr/include"'":' .config-used-for*
    rm -f .config-used-for*.tmp

    ######################### Done with uClibc ###########################

    if ! resume_check uclibc.host-utils ; then

    echo_date  "Building uClibc host utils"
    RUN="$MAKE -C utils hostutils $ARGS"
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    if (echo $RUN $LOGFILE ; ) | sh ; then
        mkdir -p $DIR_LINUX_OUTPUT/bin
        for RUN in ldconfig ldd ; do
            cp utils/${RUN}.host $DIR_LINUX_OUTPUT/bin/bfin-linux-uclibc-${RUN} || exit 1
        done
    elif [ "${UCLIBC_HOSTUTILS}" != "XFAIL" ] ; then
        die_with_log
    else
        (echo "echo -e '!!! Host utils were expected to fail; ignoring\n' $LOGFILE" ) | sh
    fi

    run_cmd mkdir -p $DIR_uC_OUTPUT/bfin-uclinux/runtime
    run_cmd mkdir -p $DIR_LINUX_OUTPUT/bfin-linux-uclibc/runtime
    run_cmd cp -r $DIR_KBUILD_OUTPUT/usr $DIR_uC_OUTPUT/bfin-uclinux/runtime
    run_cmd cp -r $DIR_KBUILD_OUTPUT/usr $DIR_LINUX_OUTPUT/bfin-linux-uclibc/runtime

    if [ "$DIR_KBUILD_OUTPUT" != "$KERNEL_SOURCE" ]; then
        echo_date "Cleaning kernel"
        rm -rf "$DIR_KBUILD_OUTPUT"
    fi

    echo_date "Cleaning uClibc"
    change_dir $UCLIBC_SOURCE
    run_cmd $MAKE CROSS=bfin-elf- distclean

    resume_save
    fi

    ####################### Done Step 3  #########################

    ####################### Step 4 - build bfin-uclinux ################
    build_binutils uclinux $DIR_uC_OUTPUT

    ln -s runtime/usr/include $DIR_uC_OUTPUT/bfin-uclinux/sys-include
    for GCC_VERSION in $GCC_VERSIONS; do
      build_gcc $GCC_VERSION uclinux $DIR_uC_OUTPUT \
          "--enable-threads=posix \
           --with-sysroot=$DIR_uC_OUTPUT/bfin-uclinux/runtime"
    done
    rm -f $DIR_uC_OUTPUT/bfin-uclinux/sys-include

    build_elf2flt uclinux $DIR_uC_OUTPUT

    ####################### Test bfin-uclinux #######################

    if [ $CHECK_ON_HARDWARE ] ; then
        echo_date "Testing on hardware"

        # Remove all tools from build directory. Thus the installed ones
        # are tested. This way gcc will use ld wrapper provided by elf2flt.
        change_dir $DIR_BINUTILS_BUILD
        ( echo "$MAKE clean " $LOGFILE ; ) | sh

        run_tests $DIR_TEST_HW_RESULTS hardware-flat
    fi

    ####################### Step 4a - build bfin-linux-uclibc ################
    build_binutils linux-uclibc $DIR_LINUX_OUTPUT

    ln -s runtime/usr/include $DIR_LINUX_OUTPUT/bfin-linux-uclibc/sys-include
    for GCC_VERSION in $GCC_VERSIONS; do
    	build_gcc $GCC_VERSION linux-uclibc $DIR_LINUX_OUTPUT \
	  "--enable-threads=posix --enable-shared \
	   --with-sysroot=$DIR_LINUX_OUTPUT/bfin-linux-uclibc/runtime"
    done
    rm -f $DIR_LINUX_OUTPUT/bfin-linux-uclibc/sys-include

    if [ "${CHOST}" != "${CBUILD}" ] || ${RESUME_BUILD} ; then
        install_all_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc
    else

    install_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc libstdc++
    for GCC_VERSION in $GCC_VERSIONS; do
        if [ "$GCC_VERSION" != "3.4" ] ; then
	    install_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc libmudflap
	    install_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc libmudflapth
            if [ "$GCC_VERSION" != "4.1" ] ; then
		install_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc libgomp
	    fi
            # If we turned fortran on, or let the build system figure it out
            TMP=`echo $BFIN_LANGS | grep fortran`
            if ([ -n "$TMP" ] || [ -z "$BFIN_LANGS" ]) ; then
                install_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc libgfortran
            fi
            # If we turned objc on, or let the build system figure it out
            TMP=`echo $BFIN_LANGS | grep objc`
            if ([ -n "$TMP" ] || [ -z "$BFIN_LANGS" ]) ; then
                install_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc libobjc
            fi
	    break;
        fi
    done

    install_libgccs $DIR_LINUX_OUTPUT bfin-linux-uclibc

    fi

    ##################### Test bfin-linux-uclibc #####################

    if [ $CHECK_ON_HARDWARE ] ; then
        echo_date "Testing linux-uclibc on hw"

        # Remove all tools from build directory. Thus the installed ones
        # are tested. This way gcc will use ld wrapper provided by elf2flt.
        change_dir $DIR_BINUTILS_BUILD
        ( echo "$MAKE clean " $LOGFILE ; ) | sh

        run_tests $DIR_TEST_HW2_RESULTS hardware-fdpic
    fi

    ########################### genext2fs ########################

    echo_date "Building uClinux genext2fs"
    change_clean_dir $DIR_GENEXT2FS_BUILD
    touch -r . * # fix autotool timestamps

    echo_date "Cleaning uClinux genext2fs"
    RUN="$MAKE distclean "
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh

    RUN="$DIR_GENEXT2FS_SOURCE/configure --prefix=$DIR_uC_OUTPUT"
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh

    echo_date "Make uClinux genext2fs"
    RUN=$MAKE
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh

    for RUN in genext2fs
    do
        if [ ! -f $DIR_GENEXT2FS_BUILD/$RUN ] ; then
            echo "genext2fs did not build properly : Missing $RUN"
            die_with_log
        fi
    done

    echo_date "Installing uClinux genext2fs"
    RUN="$MAKE install"
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh
    cp $DIR_uC_OUTPUT/bin/genext2fs $DIR_uC_OUTPUT/bin/bfin-uclinux-genext2fs || exit 1
    mv $DIR_uC_OUTPUT/bin/genext2fs $DIR_LINUX_OUTPUT/bin/bfin-linux-uclibc-genext2fs || exit 1

    rm -rf $DIR_GENEXT2FS_BUILD

    ########################### cramfs ########################

    echo_date "Building uClinux cramfs-tools"
    change_dir $DIR_CRAMFS_SOURCE

    echo_date "Cleaning uClinux cramfs-tools"
    RUN="$MAKE distclean "
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh

    echo_date "Make uClinux cramfs-tools"
    RUN=$MAKE
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh

    for RUN in mkcramfs cramfsck
    do
        if [ ! -f $DIR_CRAMFS_SOURCE/$RUN ] ; then
            echo "cramfs did not build properly : Missing $RUN"
            die_with_log
        fi
    done

    echo_date "Installing uClinux cramfs-tools"
    RUN="$MAKE install"
    (echo "echo -e '###\n$RUN\n' $LOGFILE" ) | sh
    (echo $RUN $LOGFILE ; ) | sh
    cp $DIR_CRAMFS_SOURCE/mkcramfs $DIR_uC_OUTPUT/bin/bfin-uclinux-mkcramfs
    cp $DIR_CRAMFS_SOURCE/cramfsck $DIR_uC_OUTPUT/bin/bfin-uclinux-cramfsck
    mv $DIR_CRAMFS_SOURCE/mkcramfs $DIR_LINUX_OUTPUT/bin/bfin-linux-uclibc-mkcramfs
    mv $DIR_CRAMFS_SOURCE/cramfsck $DIR_LINUX_OUTPUT/bin/bfin-linux-uclibc-cramfsck

	######################## ldr-utils ###########################

    if ! resume_check ldr-utils ; then

    DIR_LDR_UTILS_BUILD=$DIR_BUILD/ldr-utils_build

    change_dir $DIR_LDR_UTILS_SOURCE

    echo_date "Cleaning ldr-utils"
    find . -print0 | xargs -0 touch -r . # fix autotool timestamps
    run_cmd $MAKE clean
    change_clean_dir "$DIR_LDR_UTILS_BUILD"

    echo_date "Configuring ldr-utils"
    run_cmd $DIR_LDR_UTILS_SOURCE/configure --prefix=/ $BUILD_TARGET $HOST_TARGET

    echo_date "Building ldr-utils"
    run_cmd $MAKE

    echo_date "Installing ldr-utils"
    run_cmd $MAKE install DESTDIR=$DIR_ELF_OUTPUT   program_transform_name=s,^,bfin-elf-,
    run_cmd $MAKE install DESTDIR=$DIR_uC_OUTPUT    program_transform_name=s,^,bfin-uclinux-,
    run_cmd $MAKE install DESTDIR=$DIR_LINUX_OUTPUT program_transform_name=s,^,bfin-linux-uclibc-,

    if [ "$CHECK_ON_SIMULATOR" = "1" ] ; then
        echo_date "Checking ldr-utils"
        run_cmd $MAKE check
    fi

    change_dir $DIR_LDR_UTILS_SOURCE
    rm -rf "$DIR_LDR_UTILS_BUILD"

    resume_save
    fi

    ######################## jtag/gdbproxy #######################

    if ! resume_check jtag-tools ; then

    ### libftdi
    if ( check_lib usb && ! check_lib ftdi ) 2>/dev/null ; then
    DIR_LIBFTDI_BUILD=$DIR_BUILD/libftdi

    change_dir $DIR_LIBFTDI_SOURCE

    echo_date "Cleaning libftdi"
    find . -print0 | xargs -0 touch -r . # fix autotool timestamps
    [ -e Makefile ] && run_cmd $MAKE distclean
    change_clean_dir "$DIR_LIBFTDI_BUILD"

    echo_date "Configuring libftdi"
    run_cmd $DIR_LIBFTDI_SOURCE/configure --prefix="$DIR_LIBFTDI_BUILD/destdir" \
        $BUILD_TARGET $HOST_TARGET --disable-shared --enable-static

    echo_date "Building libftdi"
    run_cmd $MAKE SUBDIRS=src

    echo_date "Installing libftdi"
    run_cmd $MAKE SUBDIRS=src install

    export PKG_CONFIG_PATH="$DIR_LIBFTDI_BUILD/destdir/lib/pkgconfig${PKG_CONFIG_PATH+:${PKG_CONFIG_PATH}}"
    export LIBFTDI_CONFIG="$DIR_LIBFTDI_BUILD/destdir/bin/libftdi-config"
    fi

    ### jtag
    DIR_JTAG_BUILD=$DIR_BUILD/jtag

    change_dir $DIR_JTAG_SOURCE

    echo_date "Cleaning jtag"
    find . -print0 | xargs -0 touch -r . # fix autotool timestamps
    [ -e Makefile ] && run_cmd $MAKE distclean
    # generated files get out of sync with source files; force regen
    rm -f src/bsdl/bsdl_bison.[ch] src/bsdl/bsdl_flex.c \
          src/svf/svf_bison.[ch] src/svf/svf_flex.c
    change_clean_dir "$DIR_JTAG_BUILD"

    echo_date "Configuring jtag"
    run_cmd env $DIR_JTAG_SOURCE/configure --prefix=/ $BUILD_TARGET $HOST_TARGET --enable-relocatable

    echo_date "Building jtag"
    run_cmd $MAKE

    echo_date "Installing jtag"
    run_cmd $MAKE install DESTDIR=$DIR_ELF_OUTPUT   program_transform_name=s,^,bfin-,
    run_cmd $MAKE install DESTDIR=$DIR_uC_OUTPUT    program_transform_name=s,^,bfin-,
    run_cmd $MAKE install DESTDIR=$DIR_LINUX_OUTPUT program_transform_name=s,^,bfin-,

    ### gdbproxy
    DIR_GDBPROXY_BUILD=$DIR_BUILD/gdbproxy

    change_dir $DIR_GDBPROXY_SOURCE

    echo_date "Cleaning gdbproxy"
    find . -print0 | xargs -0 touch -r . # fix autotool timestamps
    [ -e Makefile ] && run_cmd $MAKE distclean
    change_clean_dir "$DIR_GDBPROXY_BUILD"

    echo_date "Configuring gdbproxy"
    run_cmd env $DIR_GDBPROXY_SOURCE/configure --prefix=/ $BUILD_TARGET $HOST_TARGET \
        --with-jtag-srcdir=$DIR_JTAG_SOURCE --with-jtag-builddir=$DIR_JTAG_BUILD --enable-relocatable

    echo_date "Building gdbproxy"
    run_cmd $MAKE

    echo_date "Installing gdbproxy"
    run_cmd $MAKE install DESTDIR=$DIR_ELF_OUTPUT   program_transform_name=s,^,bfin-,
    run_cmd $MAKE install DESTDIR=$DIR_uC_OUTPUT    program_transform_name=s,^,bfin-,
    run_cmd $MAKE install DESTDIR=$DIR_LINUX_OUTPUT program_transform_name=s,^,bfin-,

    change_dir $DIR_BUILD
    rm -rf "$DIR_LIBFTDI_BUILD" "$DIR_JTAG_BUILD" "$DIR_GDBPROXY_BUILD"

    resume_save
    fi

    ######################## U-Boot ##############################

    if [ $DIR_UBOOT ] ; then
        echo_date "Building U-Boot to get Tools"
        change_dir $DIR_UBOOT
        DIR_UBOOT_BUILD="$DIR_BUILD/u-boot_build"

        echo_date "Cleaning U-Boot"
        run_cmd rm -rf "$DIR_UBOOT_BUILD"

        # the actual config file here doesnt matter since we
        # just want to build the mkimage and gen_eth_addr tools
        run_cmd mkdir -p "$DIR_UBOOT_BUILD/include"
        run_cmd touch "$DIR_UBOOT_BUILD"/include/config.mk "$DIR_UBOOT_BUILD"/include/config.h
        echo_date "Make U-Boot"
        run_cmd $MAKE O="$DIR_UBOOT_BUILD" BIN_FILES='mkimage gen_eth_addr' tools

        echo_date "Copying U-Boot Tools"
        EXEEXT=""
        check_installed_files u-boot "$DIR_UBOOT_BUILD/tools/" \
            mkimage gen_eth_addr
        for RUN in mkimage gen_eth_addr ; do
            run_cmd cp "$DIR_UBOOT_BUILD/tools/$RUN" "$DIR_uC_OUTPUT/bin/bfin-uclinux-$RUN"
            run_cmd cp "$DIR_UBOOT_BUILD/tools/$RUN" "$DIR_LINUX_OUTPUT/bin/bfin-linux-uclibc-$RUN"
        done

        echo_date "Cleaning U-Boot"
        run_cmd rm -rf "$DIR_UBOOT_BUILD"
    fi
    ######################## Done ################################

fi

for GCC_VERSION in $GCC_VERSIONS; do
    DIR_GCC_BUILD=$DIR_BUILD/gcc_build-$GCC_VERSION
    rm -rf $DIR_GCC_BUILD/*
done

########################### Target libs ########################

if [ -e $DIR_SOURCE/libs/Makefile ] ; then

    change_dir $DIR_SOURCE/libs

    MULTILIBS=`bfin-elf-gcc --print-multi-lib`

    echo_date "Building libs"

    for ml in $MULTILIBS; do

	dir=`echo ${ml} | sed -e 's/;.*$//'`
	flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`

	run_cmd $MAKE CROSS=bfin-elf- clean

	run_cmd $MAKE CROSS=bfin-elf- MULTILIB_FLAGS="$flags"

	check_installed_files libdsp "$DIR_SOURCE/libs/libdsp/" \
		libbfdsp.a libbffastfp.a

	if echo "${dir}" | grep -q -v bf561; then
	    if [ $KERNEL_SOURCE ] ; then
		if echo "${flags}" | grep -q mfdpic; then
		    dir2=`echo ${dir} | sed -e 's/mfdpic//' -e 's|/$||'`
		    run_cmd $MAKE CROSS=bfin-elf- install DESTDIR=$DIR_LINUX_OUTPUT/bfin-linux-uclibc/runtime USR=/usr SUFFIX=/$dir2 MULTILIB=
		else
		    run_cmd $MAKE CROSS=bfin-elf- install DESTDIR=$DIR_uC_OUTPUT/bfin-uclinux/runtime USR=/usr SUFFIX= MULTILIB=/$dir
		fi
	    fi
	fi

	# LIBC_HAS_NO_CMATH=1 will add several more files to libbfdsp.a.
	# For file systems with low resolution timestamp, like ext2/3,
	# sometimes, libbfdsp.a will not be updated correctly.
	# Remove it instead of make clean can save much time.
	rm $DIR_SOURCE/libs/libdsp/libbfdsp.a

	run_cmd $MAKE CROSS=bfin-elf- LIBC_HAS_NO_CMATH=1 MULTILIB_FLAGS="$flags"

	run_cmd $MAKE CROSS=bfin-elf- LIBC_HAS_NO_CMATH=1 install DESTDIR=$DIR_ELF_OUTPUT/bfin-elf USR= SUFFIX= MULTILIB=/$dir
    done

    run_cmd $MAKE CROSS=bfin-elf- clean
fi

########################### Target binutils ########################

if [ $KERNEL_SOURCE ] ; then
	export PATH=$DIR_uC_OUTPUT/bin:$DIR_LINUX_OUTPUT/bin:$PATH

	echo_date "Building target libbfd (flat)"
	change_clean_dir $DIR_BINUTILS_BUILD

	run_cmd $DIR_BINUTILS_SOURCE/configure \
		--target=bfin-uclinux --host=bfin-uclinux $BUILD_TARGET \
		--prefix=$DIR_uC_OUTPUT/bfin-uclinux \
		--disable-nls --disable-shared --without-newlib
	run_cmd $MAKE all-bfd all-opcodes all-libiberty

	echo_date "Installing target libbfd"
	run_cmd $MAKE install-bfd install-opcodes install-libiberty

	echo_date "Building target libbfd (fdpic)"
	change_clean_dir $DIR_BINUTILS_BUILD

	run_cmd $DIR_BINUTILS_SOURCE/configure \
		--target=bfin-linux-uclibc --host=bfin-linux-uclibc $BUILD_TARGET \
		--prefix=$DIR_LINUX_OUTPUT/bfin-linux-uclibc \
		--disable-nls --disable-shared --without-newlib
	run_cmd $MAKE all-bfd all-opcodes all-intl all-libiberty

	echo_date "Installing target libbfd"
	run_cmd $MAKE install-bfd install-opcodes install-libiberty

	change_dir ..
fi
rm -rf $DIR_BINUTILS_BUILD

resume_clear

printf "*** It took"
print_stop_time
echo " to complete"

echo_date "Done"
