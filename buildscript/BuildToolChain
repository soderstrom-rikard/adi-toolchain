#!/bin/sh
#Build Script - Rohit Makasana ( rohit.makasana@rrap-software.com )
#             - Modified by Bernd Schmidt (   )
#             - Modified by Robin Getz (rgetz@blackfin.uclinux.org)
#             - Modified by Jie Zhang (jie.zhang@analog.com)
#
#             - parts of this borrowed from the build-uclinux-tools.sh
#               written by David McCullough, Heiko Degenhardt,
#               Berndardo Innocenti, and Steve Miller
#
# This file is not an official part of GCC.
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING.  If not, write to
# the Free Software Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
###############################################################

. "${0%/*}/lib/lib.sh" || exit 1

START=$(date +%s)

#Uncomment only one of these
#TIMESTAMP=`date +%Y-%b-%d-%H-%M` # is YYYY_MMM_DD_HH_MM
TIMESTAMP=`date +%Y%m%d`       # is YYYY_MMM_DD
unset DATE_STAMP VERBOSE WARN

PREREQ_FILE="autoconf automake awk /bin/sh bison cp echo flex gcc gettext grep ln m4 make makeinfo mkdir msgfmt mv rm sed tail wc which pkg-config"
BINUTILS_VERSION=2.21
GDB_VERSION=2.17
NEWLIB_VERSION=${BINUTILS_VERSION}
GCC_VERSIONS=
GCC_VERSIONS_DEFAULT=4.3
NUM_JOBS=0
SKIP_DEV_CHECKS=false
WITHOUT_X=false
CLEAN_BUILD_DIRS=true
RESUME_BUILD=false
CBUILD= # the system we are compiling on
CHOST=  # the system the final compiler will run on

# All the packages we build up
PKGS_DEFAULT="bfin-elf bfin-uclinux bfin-linux-uclibc qemu u-boot ldr-utils urjtag gdbproxy target-libs"
PKGS_ALL="${PKGS_DEFAULT} expat libusb libftdi"
PKGS_ALIASES="
	bfin-elf:elf
	bfin-uclinux:uclinux:flat
	bfin-linux-uclibc:linux-uclibc:fdpic
	ldr-utils:ldr
	u-boot:uboot
	target-libs:tlibs
	urjtag:jtag
"
unset PKGS_SKIP PKGS_BUILD

unset UCLIBC_CFLAGS UCLIBC_CONFIG_FILE UCLIBC_OPTS

TEST_OPTS=
TEST_SIM=
TEST_HARDWARE=

pkgs_alias()
{
	local p u="$1"

	if has ${u} ${PKGS_ALL} ; then
		echo ${u}
		return 0
	fi

	for p in ${PKGS_ALIASES} ; do
		if has ${u} `IFS=:; set -- ${p#*:}; echo $*` ; then
			echo ${p%%:*}
			return 0
		fi
	done

	return 1
}

usage() {
# We don't document the -S option - it's for advanced users who know what
# they are doing.  For maximum reproducibility, not using it is better.
cat <<-EOF
Usage : $APP_NAME -s SOURCE [-b BUILD]
-a OPT=val       Control uClibc options (val may be "n" or "y" or a string)
-B BINUTILS_VER  Binutils version (default ${BINUTILS_VERSION}).  Can be given once.
-b BUILD         Build directory (leave blank to use current dir)
-C CONFIG_FILE   Use FILE as uClibc config file, rather than the default.
-c GCC_VERSION   GCC version (default ${GCC_VERSIONS_DEFAULT}).  Can be given multiple times.
-d               Date Stamp all output files
-D               Don't check libraries/headers -- assume all is OK
-f               Add stack checking to all tests
-G GDB_VER       GDB version (default ${GDB_VERSION}).  Can be given once.
-h               Help
-H HOST          Build toolchain to run on HOST.
-j NUM           Pass -j NUM to make (default is 2x num of CPUs)
-K SOURCE        Kernel Header directory (may be specified instead of source)
-k SOURCE        Kernel Source directory (builds bfin-uclinux-gcc)
-l LANGS         Only build specified gcc languages.
-m MAKE          Default make (leave blank to use system make)
-N NEWLIB_VER    Newlib version (default ${NEWLIB_VERSION}).  Can be given once.
-O OUTPUT        Output directory (leave blank to use build dir)
-o OUTPUT        Output directory prefix (leave blank to use build dir)
-p               Check prerequisites
-P STRING        Use STRING as the package version (instead of svn revision)
-r RESULTS_DIR   Compare current tests to old results
-R               Don't remove build directories when finished compiling
-s SOURCE        Toolchain Source directory (builds bfin-elf-gcc)
-T TARGET_IPADDR Test components on hardware
-t               Test components on simulator
-u UBOOT_SOURCE  U-Boot Source directory
-v               Verbose
-w               Warnings to be sent to a different log file
-X               Disable all graphical utilities
EOF
# -S PKG           Skip building package (elf:elf compiler, ldr:ldr-utils) - don't print this out
# -U               uClibc CFLAGS - don't print this out
exit ${1:-0}
}

while getopts a:b:B:c:C:dDG:fH:hj:k:K:l:m:N:o:O:pP:Rr:s:S:tT:u:U:vwX parameter
do
	case $parameter in
		a)
			case ${OPTARG} in
				*=*) ;;
				*)   error "uClibc option must have a value (like '$OPTARG=y')" ;;
			esac
			c=`echo ${OPTARG%%=*} | tr '[:lower:]' '[:upper:]'`
			v=${OPTARG#*=}
			UCLIBC_OPTS="${UCLIBC_OPTS} ${c#CONFIG_}=${v}"
			;;
		p)  CHECK_PRE=true ;;
		m)  MAKE=$OPTARG ;;
		w)  WARN=1 ;;
		d)  DATE_STAMP=1 ;;
		D)  SKIP_DEV_CHECKS=true ;;
		R)  CLEAN_BUILD_DIRS=false ;;
		v)  VERBOSE=1 ;;
		f|t|T|r)
			case ${parameter} in
				t) OPTARG="elf-sim";;
				T) OPTARG="${OPTARG} -t uclinux -t linux-uclibc";;
			esac
			TEST_OPTS="${TEST_OPTS} -${parameter} ${OPTARG}"
			;;
		S)
			if ! pkg=`pkgs_alias ${OPTARG}` ; then
				error "unknown package given to -S: ${OPTARG}"
			fi
			PKGS_SKIP="${PKGS_SKIP} ${pkg}"
			;;
		s)  DIR_SOURCE=${OPTARG%/} ;;
		l)
			TMP=`echo $OPTARG | grep c`
			if [ -n "$TMP" ] ; then
				TMP=`echo $OPTARG | sed {s/\,/\ /}`
				for RUN in $TMP
				do
					if [ "$RUN" = "c" ] ; then
						 BFIN_LANGS=" --enable-languages=$OPTARG"
					fi
				done
				if [ -z $BFIN_LANGS ] ; then
					error "Must Build C Compiler $OPTARG"
				fi
			else
				error "Can't understand Language argument $OPTARG"
			fi
			;;
		B)  BINUTILS_VERSION=$OPTARG ;;
		G)  GDB_VERSION=$OPTARG ;;
		N)  NEWLIB_VERSION=$OPTARG ;;
		P)  PKGVERSION=$OPTARG ;;
		c)  GCC_VERSIONS="$GCC_VERSIONS $OPTARG" ;;
		H)  CHOST=$OPTARG ;;
		k)  KERNEL_SOURCE=$OPTARG ;;
		K)  KERNEL_SOURCE=$OPTARG
			DIR_KBUILD_OUTPUT=$OPTARG
			if [ ! -d $KERNEL_SOURCE/usr/include/linux ] ; then
				error "Can't find kernel headers"
			fi
			;;
		u)
			if [ -f $OPTARG/tools/mkimage.c ] ; then
				DIR_UBOOT=$OPTARG
			else
				error "Invalid U-Boot Path"
			fi
			;;
		b)  DIR_BUILD=${OPTARG%/} ;;
		C)
			UCLIBC_CONFIG_FILE=$OPTARG
			if ! is_abs_file "${UCLIBC_CONFIG_FILE}" ; then
				UCLIBC_CONFIG_FILE="${PWD}/${OPTARG}"
				if ! is_abs_file "${UCLIBC_CONFIG_FILE}" ; then
					error "-C (uClibc config) option takes a full path"
				fi
			fi
			;;
		o)
			DIR_ELF_OUTPUT=$OPTARG-elf
			DIR_uC_OUTPUT=$OPTARG-uclinux
			DIR_LINUX_OUTPUT=$OPTARG-linux-uclibc
			;;
		O)
			DIR_ELF_OUTPUT=$OPTARG
			DIR_uC_OUTPUT=$OPTARG
			DIR_LINUX_OUTPUT=$OPTARG
			;;
		j)  NUM_JOBS=$OPTARG ;;
		X)  WITHOUT_X=true ;;
		U)  UCLIBC_CFLAGS=$OPTARG ;;
		h)  usage ;;
		*)  error "unknown option $parameter\n" \
		          "Try \`$APP_NAME -h' for more information."
			;;
	esac
done

pkgs_queue()
{
	local p pkg
	for pkg in "$@" ; do
		if ! p=`pkgs_alias ${pkg}` ; then
			error "unknown package: ${pkg}"
		fi
		has ${p} ${PKGS_SKIP} && continue
		has ${p} ${PKGS_BUILD} && continue
		PKGS_BUILD="${PKGS_BUILD} ${p}"
	done
}
pkgs_queued()
{
	local p
	for p in "$@" ; do
		p=`pkgs_alias ${p}`
		has ${p} ${PKGS_BUILD} || return 1
	done
	return 0
}
pkgs_queued_any()
{
	local p
	for p in "$@" ; do
		pkgs_queued ${p} && return 0
	done
	return 1
}
pkgs_unqueue()
{
	local p
	for p in "$@" ; do
		p=`pkgs_alias ${p}`
		PKGS_BUILD=$(echo $(echo ${PKGS_BUILD} | sed s:${p}::))
	done
}

shift $((OPTIND - 1))
[ $# -eq 0 ] && set -- ${PKGS_DEFAULT}
pkgs_queue "$@"

# binutils-2.20 and later don't include insight
if [ "${GDB_VERSION}" != "2.17" ] ; then
	WITHOUT_X=true
fi

# Make sure root does not build things
if [ "$(id -u)" -eq 0 ]; then
	echo "you should not build the toolchain as the 'root' user"
	sleep 30
fi

############ Check and error if I can't find the things I need #

check_cc_options() {
	if `${1} ${2} -S -o /dev/null -xc /dev/null > /dev/null 2>&1` ; then
		return 0
	else
		return 1
	fi
}

: ${MAKE:=make}
${SKIP_DEV_CHECKS} || check_source_packages
if [ -n "$CHECK_PRE" ] ; then
	check_prereqs_verbose ${PREREQ_FILE}
	exit 0
else
	check_prereqs_short ${PREREQ_FILE} ${MAKE}
fi

############ Done checking - lets get on to building ###################3

notice "Building packages" ${PKGS_BUILD}

# Don't set a default here ... let the build system
# figure out the defaults by loading all languages.
#BFIN_LANGS=" --enable-languages=c,c++"
: ${GCC_VERSIONS:=${GCC_VERSIONS_DEFAULT}}
notice "Building gcc versions" $GCC_VERSIONS
notice "Building gcc languages" ${BFIN_LANGS:-all found}

############ CHECK MAKE SET #####################################
if [ "$NUM_JOBS" = "0" ] ; then
	NUM_JOBS=`grep -sc "^processor" /proc/cpuinfo`
	: $(( NUM_JOBS *= 2 ))
	[ ${NUM_JOBS} -eq 0 ] && NUM_JOBS=2
fi
export MAKEFLAGS="-j$NUM_JOBS $MAKEFLAGS"
notice "Utilizing make" "$MAKE $MAKEFLAGS"

scrub_path

############ FIND SOME DEFAULT PATHS ############################
# Support the "normal" layout (what we document in examples):
# svn/toolchain/...
# svn/u-boot/...
# svn/uclinux-dist/linux-2.6.x/...

if [ -z "${KERNEL_SOURCE}" ] ; then
	for p in \
		../linux-kernel \
		../../linux-kernel/trunk \
		../uclinux-dist/linux-2.6.x \
		../uClinux-dist/linux-2.6.x \
		../../uclinux-dist/trunk/linux-2.6.x \
		../../uClinux-dist/trunk/linux-2.6.x
	do
		d="${DIR_SOURCE}/${p}"
		if [ -d "${d}/arch/blackfin" ] ; then
			KERNEL_SOURCE=${d}
			break
		fi
	done
fi
! pkgs_queued flat && ! pkgs_queued fdpic && unset KERNEL_SOURCE
[ -z "${KERNEL_SOURCE}" ] && pkgs_unqueue flat fdpic

if [ -z "${DIR_UBOOT}" ] ; then
	for p in ../u-boot ../../u-boot/trunk ; do
		d="${DIR_SOURCE}/${p}"
		if [ -d "${d}" ] ; then
			DIR_UBOOT=${d}
			break
		fi
	done
fi
pkgs_queued u-boot || unset DIR_UBOOT
[ -z "${DIR_UBOOT}" ] && pkgs_unqueue u-boot

############ ABSOLUTE PATH TO SOURCE DIRECTORIES ################

check_abs_dir "Toolchain source" "${DIR_SOURCE}"
if [ $KERNEL_SOURCE ] ; then
	check_abs_dir "Kernel source" "${KERNEL_SOURCE}"
fi

: ${DIR_BUILD:=${PWD}}

mkdir -p "${DIR_BUILD}"
check_abs_dir "" "${DIR_BUILD}"

export STAGEDIR=${DIR_BUILD}/staging_build
mk_output_dir "staging" "${STAGEDIR}"

: ${DIR_ELF_OUTPUT:=${DIR_BUILD}/bfin-elf}
DIR_ELF_SYSROOT=${DIR_ELF_OUTPUT}/bfin-elf/runtime
pkgs_queued elf && mk_output_dir "ELF" "${DIR_ELF_OUTPUT}"

DIR_LOG=$DIR_BUILD/logs
mk_output_dir "logs" "${DIR_LOG}"
${RESUME_BUILD} || resume_clear

# make sure we arent running on a case insensitive filesystem
cd "${DIR_BUILD}"
check_fs_case

if pkgs_queued_any elf flat fdpic ; then
	check_src_pkg binutils-${BINUTILS_VERSION} BINUTILS
	check_src_pkg binutils-${GDB_VERSION} GDB
	if pkgs_queued elf ; then
		check_src_pkg binutils-${NEWLIB_VERSION} NEWLIB
	fi
fi

CBUILD=$($DIR_APP/config.guess)
BUILD_TARGET="--build=${CBUILD}"
: ${CHOST:=${CBUILD}}
HOST_TARGET="--host=${CHOST}"

# libintl / libiconv handling in binutils-2.17 is broken for
# extraneous hosts ... it's been fixed in binutils-2.18, so
# once we update to that, we should be able to re-enable NLS
UCLIBC_HOSTUTILS="PASS"
if [ "${WITHOUT_X}" = "true" ] ; then
	BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-gdbtk"
fi
case ${CHOST} in
	*mingw*)  BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-nls"; UCLIBC_HOSTUTILS="XFAIL";;
	*darwin*) BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-nls"; UCLIBC_HOSTUTILS="XFAIL";;
esac
# warnings with gcc-4.3 cause build failures
BINUTILS_EXTRA_CONF="${BINUTILS_EXTRA_CONF} --disable-werror"

if pkgs_queued_any elf flat fdpic ; then
	for GCC_VER in $GCC_VERSIONS; do
		PRIMARY_GCC_VER=${GCC_VER}
		check_abs_dir "Path to gcc-${GCC_VER}" "${DIR_SOURCE}/gcc-${GCC_VER}"
	done
fi

if pkgs_queued_any elf flat ; then
	check_src_pkg elf2flt
fi

if pkgs_queued_any flat fdpic ; then
	check_src_pkg uClibc
	if [ -n "${UCLIBC_CFLAGS}" ] ; then
		printf "    uClibc CFLAGS           "
		# We test (and warn) if any of the CFLAGS for uClibc
		# don't work on the host compiler
		for opt in $UCLIBC_CFLAGS ; do
			printf " %s" "$opt"
			if check_cc_options gcc $opt ; then
				printf "(bfin only?)"
			fi
		done
		echo
	fi
	: ${UCLIBC_CFLAGS:=-g -O2}

	notice "Path to uClibc config" "${UCLIBC_CONFIG_FILE:-$DIR_UCLIBC_SOURCE/extra/Configs/}"
	if [ -n "$UCLIBC_CONFIG_FILE" ] && [ ! -f "${UCLIBC_CONFIG_FILE}" ] ; then
		error "Can't find uClibc config file '$UCLIBC_CONFIG_FILE'"
	fi
fi

if pkgs_queued_any elf flat fdpic ; then
	pkgs_queue expat
fi

if pkgs_queued qemu ; then
	check_src_pkg qemu
fi
if pkgs_queued ldr-utils ; then
	pkgs_queue libusb
	check_src_pkg ldr-utils
fi
if pkgs_queued gdbproxy ; then
	pkgs_queue urjtag
	check_src_pkg gdbproxy
fi
if pkgs_queued urjtag ; then
	pkgs_queue libusb libftdi
	check_src_pkg urjtag
else
	pkgs_unqueue gdbproxy
fi
if pkgs_queued libftdi ; then
	pkgs_queue libusb
	check_src_pkg libftdi-1.0 LIBFTDI
fi
pkgs_queued libusb && check_src_pkg libusb

: ${DIR_uC_OUTPUT:=${DIR_BUILD}/bfin-uclinux}
DIR_uC_SYSROOT=${DIR_uC_OUTPUT}/bfin-uclinux/runtime
pkgs_queued flat && mk_output_dir "FLAT" $DIR_uC_OUTPUT

: ${DIR_LINUX_OUTPUT:=${DIR_BUILD}/bfin-linux-uclibc}
DIR_LINUX_SYSROOT=${DIR_LINUX_OUTPUT}/bfin-linux-uclibc/runtime
pkgs_queued fdpic && mk_output_dir "FDPIC" $DIR_LINUX_OUTPUT

if [ ! $DIR_KBUILD_OUTPUT ] ; then
	DIR_KBUILD_LOCAL=true
	DIR_KBUILD_OUTPUT=$DIR_BUILD/kernel_build
	mk_output_dir "kernel" $DIR_KBUILD_OUTPUT ""
else
	DIR_KBUILD_LOCAL=false
fi

if ! pkgs_queued u-boot ; then
	echo "U-Boot Source not specified: addon utilties (like 'mkimage') will not be built"
else
	check_abs_dir "Path to U-Boot" "${DIR_UBOOT}"
fi

###################### set up log file ###########################

STDOUT_LOG="$DIR_LOG/log${DATE_STAMP+.${TIMESTAMP}}"
STDERR_LOG="$DIR_LOG/warn${DATE_STAMP+.${TIMESTAMP}}"
notice "Creating log file" "${STDOUT_LOG}"
if [ $VERBOSE ]; then
	LOGFILE="| tee -a ${STDOUT_LOG}"
	ACTUAL_LOGFILE=${STDOUT_LOG}
else
	if [ $WARN ] ; then
		echo "*** Warnings going to $DIR_LOG/warn"
		LOGFILE=">> ${STDOUT_LOG} 2>> ${STDERR_LOG}"
		ACTUAL_LOGFILE=${STDERR_LOG}
	else
		LOGFILE=">> ${STDOUT_LOG} 2>&1"
		ACTUAL_LOGFILE=${STDOUT_LOG}
	fi
fi

# Add output dir so when building uclibc, it can find the toolchain
if [ -n "${NEW_PATH}" ] ; then
	PATH=$NEW_PATH:/$DIR_ELF_OUTPUT/bin:/$DIR_uC_OUTPUT/bin:/$DIR_LINUX_OUTPUT/bin
fi

#################################################################
############## DONOT CHANGE ANYTHING BELOW THIS LINE ############
#################################################################

build_curses()
{
	# help out mingw targets; some packages (like gdb) need curses
	if [ "${CBUILD}" = "${CHOST}" ] || check_lib curses ${CHOST} 2>/dev/null ; then
		return 0
	fi

	PN="pdcurses"
	S=$(echo $DIR_BINUTILS_SOURCE/../PDCurses-*)
	WORKDIR=$DIR_BUILD/${PN}_build

	[ -d "${S}" ] || return 0

	PV=$(awk '{v=$NF} END{print v}' "${S}"/version.mif)

	echo_date "${CHOST}: ${PN}: building (${PV})"
	change_clean_dir "${WORKDIR}"
	run_cmd $MAKE -f "${S}"/win32/gccwin32.mak PDCURSES_SRCDIR="${S}" \
		CC=${CHOST}-gcc LIBEXE=${CHOST}-ar libs

	echo_date "${CHOST}: ${PN}: installing"
	run_cmd cp *curses.a "${STAGEDIR}"/usr/lib/libcurses.a
	run_cmd cp "${S}"/curses.h "${STAGEDIR}"/usr/include/

	clean_build_dir "${WORKDIR}"
}

build_expat()
{
	pkgs_queued expat || return 0

	# help out mingw targets; some packages (like gdb) like expat
	if check_lib expat ${CHOST} 2>/dev/null ; then
		return 0
	fi

	PN="expat"
	S=$(echo $DIR_BINUTILS_SOURCE/../expat-*)
	WORKDIR=$DIR_BUILD/${PN}_build

	[ -d "${S}" ] || return 0

	PV=$("${S}"/conftools/get-version.sh "${S}"/lib/expat.h)

	echo_date "${CHOST}: ${PN}: configuring (${PV})"
	change_clean_dir "${WORKDIR}"
	run_cmd "${S}"/configure $BUILD_TARGET $HOST_TARGET \
		--target=${target} --disable-shared --prefix=/usr

	echo_date "${CHOST}: ${PN}: building"
	run_cmd $MAKE buildlib

	echo_date "${CHOST}: ${PN}: installing"
	run_cmd $MAKE installlib DESTDIR="${STAGEDIR}"

	clean_build_dir "${WORKDIR}"
}

build_zlib()
{
	# help out mingw targets; some packages (like elf2flt) need zlib
	if [ "${CBUILD}" = "${CHOST}" ] || check_lib z ${CHOST} 2>/dev/null ; then
		return 0
	fi

	PN="zlib"
	_S=$DIR_SOURCE/gcc-${PRIMARY_GCC_VER}
	S="${_S}"/zlib
	WORKDIR=$DIR_BUILD/${PN}_build

	PV=$(echo ZLIB_VERSION | gcc -include "${S}"/zlib.h -E - | tail -n 1)
	PV="`eval echo ${PV}` from gcc-${PRIMARY_GCC_VER}"

	echo_date "${CHOST}: ${PN}: configuring (${PV})"
	change_clean_dir "${WORKDIR}"
	run_cmd rm -f "${_S}"/gmp "${_S}"/mpfr
	run_cmd ln -s ../gmp "${_S}"/gmp
	run_cmd ln -s ../mpfr "${_S}"/mpfr
	run_cmd "${_S}"/configure $BUILD_TARGET $HOST_TARGET

	echo_date "${CHOST}: ${PN}: building"
	run_cmd $MAKE all-zlib

	echo_date "${CHOST}: ${PN}: installing"
	run_cmd cp zlib/libz.a "${STAGEDIR}"/usr/lib/
	run_cmd cp "${S}"/zlib.h "${S}"/zconf.h "${STAGEDIR}"/usr/include/

	run_cmd rm -f "${_S}"/gmp "${_S}"/mpfr
	clean_build_dir "${WORKDIR}"
}

build_gcc()
{
	local ver="$1"
	local target="bfin-$2"
	local prefix="$3"
	local bare=false
	if [ "$4" = "--bare--" ] ; then
		shift
		bare=true
	fi
	shift 3

	resume_check ${target}.gcc-${ver}.${bare} && return 0

	DIR_GCC_SOURCE=$DIR_SOURCE/gcc-${ver}

	DIR_GCC_BUILD=$DIR_BUILD/gcc_build-${ver}
	change_clean_dir "$DIR_GCC_BUILD"
	touch_tree "${DIR_GCC_SOURCE}"

	# When doing a canadian cross, we have to use the toolchain on the host.
	# Since gcc is very picky about being compiled by another version, make
	# sure we compile this version with the same version on the host.
	if [ "${CBUILD}" != "${CHOST}" ] ; then
		p=$DIR_GCC_BUILD/.bfin.path
		mkdir $p
		for t in gcc g++ c++ gfortran ; do
			fullt=$(echo `which ${target}-$t 2>/dev/null`-${ver}.?)
			if [ ! -x "$fullt" ] ; then
				if [ "$t" = "gcc" ] ; then
					die_with_log "You need to have gcc ${ver} installed in order to build it"
				else
					continue
				fi
			fi
			printf '#!/bin/sh\nexec %s "$@"\n' "$fullt" > "$p/${target}-$t"
			chmod a+rx $p/${target}-$t
		done
		save_PATH=$PATH
		PATH=$p:$PATH
	fi

	local epver epdir
	echo_date "${target}: gcc: linking external packages"
	run_cmd rm -f \
		$DIR_GCC_SOURCE/newlib \
		$DIR_GCC_SOURCE/libgloss \
		$DIR_GCC_SOURCE/mpfr \
		$DIR_GCC_SOURCE/gmp \
		$DIR_GCC_SOURCE/mpc \
		${prefix}/${target}/sys-include
	run_cmd ln -s runtime/usr/include ${prefix}/${target}/sys-include

	epdir="$DIR_GCC_SOURCE/../gmp"
	if [ -e "${epdir}"  ] ; then
		epver=`"${epdir}"/configure --version | head -n1 | awk '{print $NF}'`
		echo_date "${target}: gcc: linking gmp (${epver})"
		run_cmd ln -snf ../gmp $DIR_GCC_SOURCE/
	fi

	epdir="$DIR_GCC_SOURCE/../mpfr"
	if [ -e "${epdir}" ] ; then
		epver=`"${epdir}"/configure --version | head -n1 | awk '{print $NF}'`
		echo_date "${target}: gcc: linking mpfr (${epver})"
		run_cmd ln -snf ../mpfr $DIR_GCC_SOURCE/
	fi

	epdir="$DIR_GCC_SOURCE/../mpc"
	if [ -e "${epdir}"  ] ; then
		epver=`"${epdir}"/configure --version | head -n1 | awk '{print $NF}'`
		echo_date "${target}: gcc: linking mpc (${epver})"
		run_cmd ln -snf ../mpc $DIR_GCC_SOURCE/
	fi

	case ${target} in
	bfin-elf)
		if [ "${DIR_BINUTILS_SOURCE}" != "${DIR_NEWLIB_SOURCE}" ] ; then
			touch_tree "${DIR_NEWLIB_SOURCE}"
		fi
		epver=`"$DIR_NEWLIB_SOURCE"/newlib/configure --version | head -n1 | awk '{print $NF}'`
		echo_date "${target}: gcc: linking newlib (${epver} via ${NEWLIB_VERSION})"
		run_cmd ln -snf $DIR_NEWLIB_SOURCE/newlib $DIR_GCC_SOURCE/
		run_cmd ln -snf $DIR_NEWLIB_SOURCE/libgloss $DIR_GCC_SOURCE/
		set -- --enable-languages=c,c++ --with-newlib "$@"
		;;
	bfin-uclinux)
		set -- --enable-threads=posix "$@"
		;;
	bfin-linux-uclibc)
		set -- --enable-threads=posix --enable-shared "$@"
		;;
	esac

	if ${bare} ; then
		set -- "$@" \
			--enable-languages=c \
			--disable-threads \
			--disable-libmudflap \
			--disable-libgomp \
			--disable-shared
	fi

	local LOCALE="--enable-clocale=generic"
	if [ "${target}" != "bfin-elf" ] ; then
		if grep -qs UCLIBC_HAS_LOCALE=y "$UCLIBC_CONFIG_FILE" ; then
			LOCALE="--enable-clocale=uclibc"
		fi
		case " ${UCLIBC_OPTS} " in
		*" UCLIBC_HAS_LOCALE=y "*) LOCALE="--enable-clocale=uclibc" ;;
		esac

		set -- --with-sysroot=${prefix}/${target}/runtime "$@"
	fi

	local ver
	if [ -e $DIR_GCC_SOURCE/gcc/BASE-VER ] ; then
		ver=`cat $DIR_GCC_SOURCE/gcc/BASE-VER`
	else
		ver=`grep version_string $DIR_GCC_SOURCE/gcc/version.c | sed 's/.*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*/\1/'`
	fi
	${bare} && ver="${ver}/bare"

	echo_date "${target}: gcc: configuring (${ver})"
	run_cmd "${DIR_GCC_SOURCE}"/configure $BUILD_TARGET $HOST_TARGET --target=${target} \
		--prefix=${prefix} --disable-libstdcxx-pch $BFIN_LANGS "$@" $LOCALE \
		--disable-symvers --disable-libssp --disable-libffi --disable-libgcj \
		--enable-version-specific-runtime-libs --enable-__cxa_atexit \
		--with-bugurl=URL:http://blackfin.uclinux.org/gf/project/toolchain/tracker \
		--with-pkgversion=$(get_scm_ver $DIR_GCC_SOURCE)

	echo_date "${target}: gcc: building"
	run_cmd $MAKE

	get_exeext "${DIR_GCC_BUILD}"/gcc/config.log
	FILE="cc1 collect2 gcov xgcc"
	if echo $BFIN_LANGS | grep -q c++ ; then
		FILE="${FILE} cc1plus cpp g++"
	fi
	check_installed_files gcc "$DIR_GCC_BUILD/gcc/" $FILE

	echo_date "${target}: gcc: installing"
	run_cmd $MAKE -j1 install

	# some basic sanity checks
	FILE="addr2line ar as c++filt gcov nm objdump ld \
	      objcopy ranlib readelf size strings strip \
	      gdb run \
	      cpp gcc"
	if echo $BFIN_LANGS | grep -q c++ ; then
		FILE="${FILE} g++ c++"
	fi
	if [ "${WITHOUT_X}" = "false" ] ; then
		FILE="${FILE} insight"
	fi
	check_installed_files toolchain "${prefix}/bin/${target}-" $FILE

	if [ -e ${prefix}/bin/${target}-g++$EXEEXT ]; then
		ln ${prefix}/bin/${target}-g++$EXEEXT ${prefix}/bin/${target}-g++-$ver$EXEEXT
		ln ${prefix}/bin/${target}-c++$EXEEXT ${prefix}/bin/${target}-c++-$ver$EXEEXT
	fi
	if [ -e ${prefix}/bin/${target}-gfortran$EXEEXT ]; then
		ln ${prefix}/bin/${target}-gfortran$EXEEXT ${prefix}/bin/${target}-gfortran-$ver$EXEEXT
	fi

	# make sure the tcl baggage that comes with insight doesnt pollute our PATH.
	# note this isnt an issue as insight statically links in all of the TCL stuff
	# it actually needs and does not use these binaries at runtime.
	if ! ${WITHOUT_X} ; then
		(
		cd "${prefix}"/bin     && rm -f tclsh* wish*
		cd "${prefix}"/lib     && rm -f libitcl*.a libitk*.a libtcl*.a libtk*.a
		cd "${prefix}"/include && rm -f itcl*.h itk*.h tcl*.h tk*.h
		cd "${prefix}"/man     && rm -rf mann man1/tclsh.1 man1/wish.1
		grep -sl Tcl/Tk man3/* | xargs rm -f
		) 2>/dev/null
	fi
	# scrub files we dont care about
	run_cmd rm -rf "${prefix}"/libexec/gcc/*/*/install-tools/ "${prefix}"/lib*/gcc/*/*/install-tools/mkheaders.conf

	if [ "${CBUILD}" != "${CHOST}" ] ; then
		PATH=$save_PATH
		rm -rf "$DIR_GCC_BUILD/.bfin.path"
	fi

	run_cmd rm -f \
		$DIR_GCC_SOURCE/newlib \
		$DIR_GCC_SOURCE/libgloss \
		$DIR_GCC_SOURCE/mpfr \
		$DIR_GCC_SOURCE/gmp \
		$DIR_GCC_SOURCE/mpc \
		${prefix}/${target}/sys-include
	clean_build_dir "$DIR_GCC_BUILD"

	resume_save
}

# Build up a set of binutils
#  $1 - toolchain prefix (bfin-XXX-gcc)
#  $2 - configure --prefix=XXX
build_binutils()
{
	local target="bfin-$1"
	local prefix="$2"
	local pkg="binutils/gdb"
	local split_gdb=false

	DIR_BINUTILS_BUILD=$DIR_BUILD/binutils_build
	DIR_GDB_BUILD=$DIR_BINUTILS_BUILD

	resume_check ${target}.binutils && return 0

	change_clean_dir "$DIR_BINUTILS_BUILD"
	touch_tree "${DIR_BINUTILS_SOURCE}"
	if [ "${DIR_BINUTILS_SOURCE}" != "${DIR_GDB_SOURCE}" ] ; then
		split_gdb=true
		pkg="binutils"
		DIR_GDB_BUILD=$DIR_BUILD/gdb_build
		touch_tree "${DIR_GDB_SOURCE}"
	fi

	# generated files get out of sync with source files; force regen
	run_cmd rm -f gas/bfin-lex.c gas/bfin-parse.[ch]

	case ${target} in
		bfin-elf) myconf="--without-newlib";;
		*)        myconf="--with-sysroot=${prefix}/${target}/runtime";;
	esac

	echo_date "${target}: ${pkg}: configuring (${BINUTILS_VERSION})"
	set -- \
		$BUILD_TARGET $HOST_TARGET --target=${target} \
		--prefix=${prefix} ${myconf} $BINUTILS_EXTRA_CONF \
		--with-libexpat-prefix="${STAGEDIR}"/usr \
		--with-bugurl=URL:http://blackfin.uclinux.org/gf/project/toolchain/tracker \
		--with-pkgversion=$(get_scm_ver $DIR_BINUTILS_SOURCE)
	run_cmd "$DIR_BINUTILS_SOURCE"/configure "$@"

	echo_date "${target}: ${pkg}: building"
	run_cmd $MAKE all-binutils all-gas all-ld $(${split_gdb} || echo all-sim all-gdb)

	get_exeext "${DIR_BINUTILS_BUILD}"/binutils/config.log
	check_installed_files binutils "$DIR_BINUTILS_BUILD/binutils/" \
		addr2line ar cxxfilt nm-new objcopy objdump ranlib \
		readelf size strings strip-new
	check_installed_files gas "$DIR_BINUTILS_BUILD/gas/" as-new
	check_installed_files ld "$DIR_BINUTILS_BUILD/ld/" ld-new

	if ${split_gdb} ; then
		change_clean_dir "$DIR_GDB_BUILD"

		echo_date "${target}: gdb: configuring (${GDB_VERSION})"
		run_cmd "$DIR_GDB_SOURCE"/configure "$@"

		echo_date "${target}: gdb: building"
		run_cmd $MAKE all-gdb
	fi

	FILE="gdb"
	if [ "${WITHOUT_X}" = "false" ] ; then
		FILE="${FILE} insight"
	fi
	check_installed_files gdb "$DIR_GDB_BUILD/gdb/" ${FILE}
	check_installed_files gdb "$DIR_GDB_BUILD/sim/bfin/" run

	change_dir "$DIR_BINUTILS_BUILD"
	echo_date "${target}: ${pkg}: installing"
	run_cmd $MAKE install-binutils install-gas install-ld $(${split_gdb} || echo install-sim install-gdb)

	if ${split_gdb} ; then
		change_dir "$DIR_GDB_BUILD"
		echo_date "${target}: gdb: installing"
		run_cmd $MAKE install-sim install-gdb
	fi

	if [ "${CBUILD}" != "${CHOST}" ] && ! check_lib readline ${CHOST} 2>/dev/null ; then
		echo_date "${CHOST}: readline: installing"
		# cache native readline for other packages (like urjtag)
		run_cmd $MAKE -C readline install-static DESTDIR=${STAGEDIR} prefix=/usr
	fi

	# need to leave build dir behind for elf2flt
	[ "${target}" = "bfin-linux-uclibc" ] && clean_build_dir "$DIR_BINUTILS_BUILD" "$DIR_GDB_BUILD"

	resume_save
}

build_elf2flt()
{
	local target="bfin-$1"
	local prefix="$2"

	resume_check ${target}.elf2flt && return 0

	DIR_ELF2FLT_BUILD=$DIR_BUILD/elf2flt_build

	echo_date "${target}: elf2flt: configuring"
	change_clean_dir "$DIR_ELF2FLT_BUILD"
	touch_tree "${DIR_ELF2FLT_SOURCE}"

	myconf=""
	if [ -e $DIR_BINUTILS_BUILD/intl/libintl.a ] ; then
		myconf="${myconf} --with-libintl=$DIR_BINUTILS_BUILD/intl/libintl.a"
	fi
	run_cmd $DIR_ELF2FLT_SOURCE/configure \
		$BUILD_TARGET $HOST_TARGET --target=${target} \
		--with-libbfd=$DIR_BINUTILS_BUILD/bfd/libbfd.a \
		--with-libiberty=$DIR_BINUTILS_BUILD/libiberty/libiberty.a \
		--with-bfd-include-dir=$DIR_BINUTILS_BUILD/bfd \
		--with-binutils-include-dir=$DIR_BINUTILS_SOURCE/include \
		--prefix=${prefix} --program-suffix= ${myconf}

	echo_date "${target}: elf2flt: building"
	run_cmd $MAKE

	get_exeext "${DIR_ELF2FLT_BUILD}"/config.log
	check_installed_files elf2flt "$DIR_ELF2FLT_BUILD/" elf2flt flthdr

	echo_date "${target}: elf2flt: installing"
	run_cmd $MAKE install

	check_installed_files elf2flt "${prefix}/bin/${target}-" \
		elf2flt flthdr

	clean_build_dir "$DIR_ELF2FLT_BUILD" "$DIR_BINUTILS_BUILD"

	resume_save
}

# Compare two dotted version numbers.  Versions are .0 extended if they
# do not have the same number of components.  Return values are:
#	0 - versions are equal
#	1 - first version is larger
#	2 - second version is larger
compare_version()
{
	local v1=$1 v2=$2
	[ -z "${v1}${v2}" ] && return 0

	local _v1=${v1%%.*} _v2=${v2%%.*}
	: ${_v1:=0} ${_v2:=0}

	if [ ${_v1} -eq ${_v2} ] ; then
		v1=${v1#${_v1}}
		v2=${v2#${_v2}}
		compare_version ${v1#.} ${v2#.}
		return $?
	elif [ ${_v1} -gt ${_v2} ] ; then
		return 1
	elif [ ${_v1} -lt ${_v2} ] ; then
		return 2
	fi
}

# Install all shared libs found in the toolchain path $1 into the sysroot dir
# so that our later tools (like uclinux-dist) can easily find it.  Do not
# execute the target toolchain here so we do not have to worry about ugly
# canadian cross issues.  The toolchain prefix is passed in as $2.
install_all_target_libs()
{
	local dir=$1
	local base_gccdir="$1/lib/gcc/$2"
	local rundir="$1/$2/runtime"
	local reldir="../../../../$2/runtime"

	local readelf
	if [ "${CHOST}" != "${CBUILD}" ] ; then
		readelf=$2-readelf
	else
		readelf=$1/bin/$2-readelf
	fi

	find "${base_gccdir}" -name '*.so' | \
	while read flib ; do
		gccdir=${flib%/*}
		lib=${flib#${base_gccdir}/}
		gver=${lib%%/*}
		lib=${lib#${gver}}
		mdir=${lib%/*}
		mdir=${mdir#/}/
		[ "${mdir}" = "/" ] && mdir=""
		lib=${lib##*/}
		otarg=$(readlink "${flib}")
		ntarg=${otarg}.${gver}
		lver=${ntarg#${lib}.}
		tdir=${rundir}/${mdir}lib
		reltdir=$(echo "${mdir}" | sed 's:[^/]*/:../:g')${reldir}/${mdir}lib
		soname=$(${readelf} -d "${flib}" | sed -n '/(SONAME)/s:.*[[]\(.*\)[]].*:\1:p')

		# see if this library has been moved already ...
		# all symlinks in the gcc libdir should be relative
		# and contain no path elements
		if echo "${otarg}" | grep -q / ; then
			continue
		fi

		local movit=true
		if [ -e "${tdir}/${soname}" ] ; then
			old_lver=$(readlink "${tdir}/${soname}")
			old_lver=${old_lver#${lib}.}
			compare_version ${lver} ${old_lver}
			if [ $? -eq 1 ] ; then
				echo_date "Up ${mdir}${lib} (${lver})"
				run_cmd rm "${tdir}/${lib}".*
			else
				movit=false
			fi
		else
			echo_date "Installed ${mdir}${lib} (${lver})"
		fi
		if ${movit} ; then
			run_cmd mv "${gccdir}/${otarg}" "${tdir}/${ntarg}"
			run_cmd ln -s "${ntarg}" "${tdir}/${soname}"
		fi
		run_cmd rm "${flib}"*
		run_cmd ln -s "${reltdir}/${soname}" "${flib}"
	done

	# Now drop the extended gcc ver we added to all libs
	local gver
	for gver in `find "${base_gccdir}" -mindepth 1 -maxdepth 1 -type d` ; do
		gver=${gver##*/}
		# first drop the .gver
		find "${rundir}" -name "*.${gver}" | \
		while read flib ; do
			mv "${flib}" "${flib%.${gver}}"
		done
		# then update every lib that may be relevant
		# too bad -lname isn't in posix ...
		find "${rundir}" -type l -name '*.so.*' | \
		while read flib ; do
			lib=$(readlink "${flib}")
			case ${lib} in
				*.${gver}) ln -sf "${lib%.${gver}}" "${flib}" ;;
			esac
		done
	done
}

build_uboot()
{
	pkgs_queued u-boot || return 0

	local ver
	# do the cd to avoid pwd warnings with `make`
	ver=$(cd /; printf 'e:;@echo $(U_BOOT_VERSION)\ninclude '$DIR_UBOOT'/Makefile\n' | ${MAKE} -f -)

	echo_date "U-Boot: building helper tools (${ver})"
	change_dir "$DIR_UBOOT"
	DIR_UBOOT_BUILD="$DIR_BUILD/u-boot_build"

	echo_date "U-Boot: cleaning"
	run_cmd rm -rf "$DIR_UBOOT_BUILD"

	echo_date "U-Boot: building"
	if [ "${CBUILD}" = "${CHOST}" ] ; then
		unset HOSTCC HOSTSTRIP
	else
		HOSTCC="${CHOST}-gcc"
		HOSTSTRIP="${CHOST}-strip"
	fi
	run_cmd $MAKE \
		-C "$DIR_UBOOT" \
		O="$DIR_UBOOT_BUILD" \
		CONFIG_CMD_NET=y \
		${HOSTSTRIP+HOSTSTRIP=${HOSTSTRIP}} \
		${HOSTCC+HOSTCC=${HOSTCC}} \
		tools

	echo_date "U-Boot: installing tools"
	check_installed_files u-boot "$DIR_UBOOT_BUILD/tools/" \
		mkimage gen_eth_addr
	run_cmd mkdir -p "${DIR_uC_OUTPUT}/bin" "${DIR_LINUX_OUTPUT}/bin"
	for RUN in mkimage$EXEEXT gen_eth_addr$EXEEXT ; do
		run_cmd cp "$DIR_UBOOT_BUILD/tools/$RUN" "$DIR_uC_OUTPUT/bin/bfin-uclinux-$RUN"
		run_cmd cp "$DIR_UBOOT_BUILD/tools/$RUN" "$DIR_LINUX_OUTPUT/bin/bfin-linux-uclibc-$RUN"
	done

	echo_date "U-Boot: cleaning"
	clean_build_dir "$DIR_UBOOT_BUILD"
}

build_kernel_headers()
{
	local target="bfin-$1" sysroot="$2"

	resume_check ${target}.linux-headers && return 0

	local ver prebuilt
	if [ "$DIR_KBUILD_OUTPUT" = "$KERNEL_SOURCE" ] ; then
		ver=$(gawk '$2 == "LINUX_VERSION_CODE" { print rshift($3,16) "." and(rshift($3,8),0xff) "." and($3,0xff) }' "${DIR_KBUILD_OUTPUT}"/usr/include/linux/version.h)
		prebuilt=true
	else
		ver=$(echo `sed -n '1,4{s:.*= *::p}' "${KERNEL_SOURCE}"/Makefile` | sed -e 's: :.:g' -e 's:[.][.]:.:g')
		prebuilt=false
	fi

	echo_date "${target}: linux-headers: configuring (${ver})"

	if ! ${prebuilt} ; then
		change_clean_dir "$DIR_KBUILD_OUTPUT"

		# the CROSS_COMPILE here isn't really necessary, but keeps
		# an ugly harmless build warning from showing (most of the time)
		change_dir "$KERNEL_SOURCE"
		run_cmd \
			$MAKE \
			headers_check headers_install \
			INSTALL_HDR_PATH=$DIR_KBUILD_OUTPUT/usr \
			KBUILD_OUTPUT=$DIR_KBUILD_OUTPUT \
			CROSS_COMPILE=bfin-elf- \
			ARCH=blackfin
		find "$DIR_KBUILD_OUTPUT/usr" -type f -name '.*' -print0 | xargs -0 rm -f
		change_dir ..

		# now that we have compiled sources, save them for next time
		KERNEL_SOURCE=$DIR_KBUILD_OUTPUT
	fi

	echo_date "${target}: linux-headers: installing"
	run_cmd mkdir -p "${sysroot}"
	run_cmd cp -r "${DIR_KBUILD_OUTPUT}"/usr "${sysroot}"

	resume_save
}

build_uclibc_core()
{
	local target="$1" sysroot="$2" config="$3" mlib1="$4" mlib2="$5"

	local ARGS="V=1"

	# workaround make behavior which causes it to search system paths
	# for a .config file.  Such as /usr/include/../../.config.
	run_cmd touch .config

	echo_date "${target}: uClibc: cleaning"
	run_cmd $MAKE $ARGS distclean

	echo_date "${target}: uClibc: setup"
	run_cmd cp "${config}" .config
	run_cmd $MAKE $ARGS headers

	if grep -qs UCLIBC_HAS_LOCALE=y .config ; then
		echo_date "${target}: uClibc: building locale"

		change_dir extra/locale
		run_cmd $MAKE clean

		find ./charmaps -name "*.pairs" > ./codesets.txt
		run_cmd cp ./LOCALES ./locales.txt
		run_cmd $MAKE $ARGS -j 1

		change_dir ../..
	fi

	echo_date "${target}: uClibc: building"
	# sometimes uClibc dies on parallel build, so lets build it with -j1
	run_cmd $MAKE $ARGS -j 1

	echo_date "${target}: uClibc: installing"
	run_cmd $MAKE $ARGS install DESTDIR="${sysroot}" SUFFIX=${mlib1}

	# Need a way to look at uClibc make system , and see what libs
	# should be created
	EXEEXT=""
	check_installed_files uClibc "${sysroot}/${mlib1}/usr/lib/${mlib2}/" \
		crt1.o libc.a libcrypt.a libm.a libnsl.a libresolv.a libutil.a
}

build_uclibc_config()
{
	local target="$1" sysroot="$2" config="$3" mlib="$4" extra_cflags="$5"
	local file_format

	do_opt() {
		local opt="$1"
		shift
		log_it "uClibc config update: $*"
		ised .config \
			-e "/^\# ${opt} is not set/d" \
			-e "/^${opt}=.*/d"
		echo "$*" >> .config
	}
	set_opt() {
		local opt="$1"
		shift
		do_opt ${opt} "${opt}=${*:-y}"
	}
	unset_opt() { do_opt $1 "# $1 is not set" ; }

	# First process all the user's uClibc options so that all
	# of our own hardcoded options below will win over the user
	run_cmd cp ${UCLIBC_CONFIG_FILE:-extra/Configs/Config.bfin.default} .config
	local opt
	for opt in ${UCLIBC_OPTS} ; do
		case ${opt} in
		*=n) unset_opt ${opt%=n} ;;
		*=y) set_opt ${opt%=y} ;;
		*=*) set_opt ${opt%%=*} \"${opt#*=}\" ;;
		esac
	done
	set_opt KERNEL_HEADERS \"$DIR_KBUILD_OUTPUT/usr/include\"
	set_opt MULTILIB \"${mlib}\"
	set_opt UCLIBC_EXTRA_CFLAGS \"${extra_cflags} ${UCLIBC_CFLAGS} -Wa,--noexecstack\"
	set_opt RUNTIME_PREFIX \"/\"
	set_opt DEVEL_PREFIX \"/usr/\"

	case ${target} in
	bfin-linux-uclibc)        file_format="FDPIC_ELF" ;;
	*)
		case ${extra_cflags} in
		*msep-data*)          file_format="FLAT_SEP_DATA" ;;
		*mid-shared-library*) file_format="SHARED_FLAT" ;;
		*)                    file_format="FLAT" ;;
		esac
		;;
	esac
	set_opt UCLIBC_FORMAT_${file_format}
	for format in FDPIC_ELF FLAT_SEP_DATA SHARED_FLAT FLAT ; do
		[ "${format}" = "${file_format}" ] && continue
		unset_opt UCLIBC_FORMAT_${format}
	done

	unset_opt HAVE_NO_PIC
	set_opt LDSO_BASE_FILENAME \"ld.so\"
	set_opt SHARED_LIB_LOADER_PREFIX \"/lib\"
	set_opt CROSS_COMPILER_PREFIX \"${target}-\"
	unset_opt LDSO_RUNPATH
	for opt in \
		BUILD_UCLIBC_LDSO \
		DOPIC \
		FORCE_SHAREABLE_TEXT_SEGMENTS \
		HAVE_SHARED \
		LDSO_CACHE_SUPPORT \
		LDSO_LDD_SUPPORT \
		UCLIBC_BUILD_NOEXECSTACK \
		UCLIBC_BUILD_RELRO \
		UCLIBC_STATIC_LDCONFIG
	do
		case ${file_format} in
		FDPIC_ELF) set_opt ${opt} ;;
		*)       unset_opt ${opt} ;;
		esac
	done

	run_cmd $MAKE oldconfig </dev/null
	run_cmd cp .config "${config}"
}

build_uclibc()
{
	local target="bfin-$1" sysroot="$2" output="$3"
	local save_PATH="${PATH}"
	PATH="${output}/bin:${PATH}"

	if [ "${CHOST}" = "${CBUILD}" ] ; then
		echo_date "${target}: uClibc: checking CFLAGS ${UCLIBC_CFLAGS}"
		# We test (and fail) if any of the CFLAGS for uClibc don't work on the bfin-elf compiler
		for opt in $UCLIBC_CFLAGS ; do
			if ! check_cc_options "$output/bin/${target}-gcc" $opt ; then
				die_with_log "I could not make option '$opt' work on the ${target} compiler, so I can't use it for uClibc"
			fi
		done
	fi

	change_dir "$DIR_UCLIBC_SOURCE"

	local ml mdir mdir1 mdir2 mflags
	for ml in `"${output}"/bin/${target}-gcc --print-multi-lib` ; do
		# Each multilib line takes the form:
		# <dir>;@<flags>
		mdir=${ml%%;*}
		suffix=`echo ${mdir} | sed -e 's:/:_:g'`
		mflags=`echo "${ml}" | sed -e 's:^[^;]*;::' -e 's:@: -:g'`

		resume_check ${target}.uclibc.${suffix} && continue

		echo_date "${target}: uClibc: configuring for ${mdir}"

		case ${target} in
		bfin-linux-uclibc) mdir1=${mdir} mdir2= ;;
		bfin-uclinux)      mdir1= mdir2=${mdir} ;;
		esac

		build_uclibc_config ${target} "${sysroot}" \
			.config-used-for_${suffix} "${mdir2}" "${mflags}"
		build_uclibc_core ${target} "${sysroot}" \
			.config-used-for_${suffix} "${mdir1}" "${mdir2}"

		resume_save
	done

	# update the kernel header path just to make rebuilding easier later on
	local f
	for f in .config-used-for* ; do
		ised "${f}" -e '/^KERNEL_HEADERS/s:=.*:="'"${sysroot}/usr/include"'":'
	done
	run_cmd rm -f .config*.tmp

	run_cmd find "${sysroot}" -type f -name '*.so' -exec chmod a+rx {} \;

	[ "${target}" = "bfin-linux-uclibc" ] && build_uclibc_host_tools ${target} "${sysroot}"

	echo_date "${target}: uClibc: cleaning"
	change_dir "$DIR_UCLIBC_SOURCE"
	run_cmd $MAKE distclean

	PATH=${save_PATH}
}

build_uclibc_headers()
{
	local target="bfin-$1" sysroot="$2"
	local ver ARGS="V=1 SUFFIX="

	resume_check ${target}.uclibc.headers && return 0

	change_dir "$DIR_UCLIBC_SOURCE"

	# workaround make behavior which causes it to search system paths
	# for a .config file.  Such as /usr/include/../../.config.
	run_cmd touch .config

	ver=$(printf 'e:;@echo $(VERSION)\ninclude '$DIR_UCLIBC_SOURCE'/Rules.mak\n' | ${MAKE} -f - 2>/dev/null)

	echo_date "${target}: uClibc: installing headers (${ver})"

	build_uclibc_config "${target}" "${sysroot}" .config-used-for_${target}-headers

	run_cmd $MAKE $ARGS headers
	run_cmd $MAKE $ARGS install_headers DESTDIR="${sysroot}"

	resume_save
}

build_uclibc_host_tools()
{
	local target="$1" sysroot="$2"

	resume_check ${target}.uclibc.host-utils && return 0

	echo_date "${target}: uClibc: building host utils"
	change_dir "$DIR_UCLIBC_SOURCE"

	if run_cmd_nodie $MAKE -C utils hostutils $ARGS ; then
		run_cmd mkdir -p $DIR_LINUX_OUTPUT/bin
		for RUN in ldconfig ldd ; do
			run_cmd cp utils/${RUN}.host $DIR_LINUX_OUTPUT/bin/bfin-linux-uclibc-${RUN}
		done
	elif [ "${UCLIBC_HOSTUTILS}" != "XFAIL" ] ; then
		die_with_log
	else
		log_it 'Host utils were expected to fail; ignoring'
	fi

	resume_save
}

build_qemu()
{
	pkgs_queued qemu || return 0

	# qemu doesn't have a standard autoconf script
	local cbuild=${BUILD_TARGET} chost=${HOST_TARGET}
	BUILD_TARGET= HOST_TARGET=

	build_autotooled_pkg "${DIR_QEMU_SOURCE}" \
		--interp-prefix=${DIR_LINUX_SYSROOT} \
		--disable-werror \
		--disable-strip \
		--target-list=bfin-linux-user \
		--disable-system

	BUILD_TARGET=${cbuild} chost=${HOST_TARGET}

	# rename "qemu-bfin" to "$CTARGET-qemu" and "bfin-qemu"
	local x t d sf df
	for x in elf:${DIR_ELF_OUTPUT} uclinux:${DIR_uC_OUTPUT} linux-uclibc:${DIR_LINUX_OUTPUT} ; do
		t=${x%%:*}
		d=${x##*:}
		sf="${d}/bin/qemu-bfin$EXEEXT"
		df="${d}/bin/bfin-${t}-qemu$EXEEXT"
		[ -e "${sf}" ] || continue
		run_cmd mv "${sf}" "${df}"
		sf=${df##*/}
		df="${d}/bin/bfin-qemu$EXEEXT"
		run_cmd ln -sf "${sf}" "${df}"
	done
}

build_ldr_utils()
{
	pkgs_queued ldr-utils || return 0

	local x t d sf df
	build_autotooled_pkg "${DIR_LDR_UTILS_SOURCE}"

	# backwards compat support
	for x in elf:${DIR_ELF_OUTPUT} uclinux:${DIR_uC_OUTPUT} linux-uclibc:${DIR_LINUX_OUTPUT} ; do
		t=${x%%:*}
		d=${x##*:}
		sf="${d}/bin/bfin-ldr$EXEEXT"
		df="${d}/bin/bfin-${t}-ldr$EXEEXT"
		[ -e "${sf}" ] || continue
		run_cmd ln -f "${sf}" "${df}"
	done
}

build_libusb()
{
	pkgs_queued libusb || return 0

	build_autotooled_pkg --tlib "${DIR_LIBUSB_SOURCE}" \
		--disable-shared --enable-static
}

build_libftdi()
{
	pkgs_queued libftdi || return 0

	at_make_args() { echo SUBDIRS=src; }
	build_autotooled_pkg --tlib "${DIR_LIBFTDI_SOURCE}" \
		--disable-shared --enable-static --disable-libftdipp \
		--disable-python-binding --with-async-mode
}

build_urjtag()
{
	pkgs_queued urjtag || return 0

	at_clean() {
		# generated files get out of sync with source files; force regen
		run_cmd rm -f src/bsdl/bsdl_bison.[ch] src/bsdl/bsdl_flex.c \
			src/svf/svf_bison.[ch] src/svf/svf_flex.c
	}
	at_install_post() {
		# let the local jtag find its data files while debugging
		if [ ! -L src/apps/share/urjtag ] ; then
			mkdir -p src/apps/share
			ln -s ../../../../../urjtag/data src/apps/share/urjtag
		fi
	}

	build_autotooled_pkg "${DIR_URJTAG_SOURCE}" \
		--disable-shared --enable-static --enable-relocatable \
		--with-libusb=1.0
}

build_gdbproxy()
{
	pkgs_queued gdbproxy || return 0

	build_autotooled_pkg "${DIR_GDBPROXY_SOURCE}"
}

build_target_libs()
{
	pkgs_queued target-libs || return 0

	change_dir "$DIR_SOURCE/libs"

	echo_date "Building libs"

	for ml in `bfin-elf-gcc --print-multi-lib`; do

		dir=`echo ${ml} | sed -e 's/;.*$//'`
		flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`

		run_cmd $MAKE CROSS=bfin-elf- clean

		run_cmd $MAKE CROSS=bfin-elf- MULTILIB_FLAGS="$flags"

		EXEEXT=
		check_installed_files libdsp "$DIR_SOURCE/libs/libdsp/" \
			libbfdsp.a libbffastfp.a

		if echo "${dir}" | grep -q -v bf561; then
			if echo "${flags}" | grep -q mfdpic; then
				pkgs_queued fdpic || continue
				suffix=/`echo ${dir} | sed -e 's/mfdpic//' -e 's|/$||'`
				mlib=
				destdir="$DIR_LINUX_OUTPUT/bfin-linux-uclibc/runtime"
			else
				pkgs_queued flat || continue
				suffix=
				mlib="/$dir"
				destdir="$DIR_uC_OUTPUT/bfin-uclinux/runtime"
			fi
			run_cmd $MAKE CROSS=bfin-elf- install DESTDIR="${destdir}" USR=/usr SUFFIX="${suffix}" MULTILIB="${mlib}"
		fi

		# LIBC_HAS_NO_CMATH=1 will add several more files to libbfdsp.a.
		# For file systems with low resolution timestamp, like ext2/3,
		# sometimes, libbfdsp.a will not be updated correctly.
		# Remove it instead of make clean can save much time.
		run_cmd rm $DIR_SOURCE/libs/libdsp/libbfdsp.a

		run_cmd $MAKE CROSS=bfin-elf- LIBC_HAS_NO_CMATH=1 MULTILIB_FLAGS="$flags"

		run_cmd $MAKE CROSS=bfin-elf- LIBC_HAS_NO_CMATH=1 install DESTDIR=$DIR_ELF_OUTPUT/bfin-elf USR= SUFFIX= MULTILIB=/$dir
	done

	run_cmd $MAKE CROSS=bfin-elf- clean
}

build_target_binutils_libs()
{
	local target="bfin-$1" out="$2"

	pkgs_queued target-libs ${target} || return 0

	echo_date "${target}: target libbfd: building"
	change_clean_dir "${DIR_BINUTILS_BUILD}"

	run_cmd "${DIR_BINUTILS_SOURCE}"/configure \
		--target=${target} --host=${target} $BUILD_TARGET \
		--prefix="${out}/${target}" \
		--disable-nls --disable-shared --without-newlib

	run_cmd $MAKE all-bfd all-opcodes all-libiberty

	echo_date "${target}: target libbfd: installing"
	run_cmd $MAKE install-bfd install-opcodes install-libiberty

	clean_build_dir "${DIR_BINUTILS_BUILD}"
}

######################## Now for the actual execution #######################

#
# Prep a few 3rd party libs if need be
#
run_cmd mkdir -p "${STAGEDIR}"/bin "${STAGEDIR}"/usr/lib/pkgconfig "${STAGEDIR}"/usr/include
if [ "${CBUILD}" != "${CHOST}" ] ; then
	# need a local compiling wrapper for the staging dir
	PATH=${STAGEDIR}/bin:${PATH}
	for x in cpp g++ gcc ld ; do
		run_cmd cp "${DIR_APP}"/staging-compiler "${STAGEDIR}"/bin/${CHOST}-${x}
	done
fi
build_curses
build_expat
build_zlib

#
# First build up the ELF toolchain
#
if pkgs_queued elf ; then
	build_binutils elf $DIR_ELF_OUTPUT
	build_elf2flt elf $DIR_ELF_OUTPUT
	for GCC_VER in $GCC_VERSIONS ; do
		build_gcc $GCC_VER elf "${DIR_ELF_OUTPUT}"
	done
fi

#
# Then the FLAT toolchain
#
if pkgs_queued flat ; then
	build_binutils uclinux $DIR_uC_OUTPUT
	build_elf2flt uclinux $DIR_uC_OUTPUT
	build_kernel_headers uclinux $DIR_uC_SYSROOT
	build_uclibc_headers uclinux $DIR_uC_SYSROOT
	# build minimal gcc first for uClibc
	build_gcc ${PRIMARY_GCC_VER} uclinux "${DIR_uC_OUTPUT}" --bare--
	build_uclibc uclinux $DIR_uC_SYSROOT $DIR_uC_OUTPUT
	for GCC_VER in $GCC_VERSIONS ; do
		build_gcc ${GCC_VER} uclinux "${DIR_uC_OUTPUT}"
	done
fi

#
# Then the FDPIC toolchain
#
if pkgs_queued fdpic ; then
	build_binutils linux-uclibc $DIR_LINUX_OUTPUT
	build_kernel_headers linux-uclibc $DIR_LINUX_SYSROOT
	build_uclibc_headers linux-uclibc $DIR_LINUX_SYSROOT
	# build minimal gcc first for uClibc
	build_gcc ${PRIMARY_GCC_VER} linux-uclibc "${DIR_LINUX_OUTPUT}" --bare--
	build_uclibc linux-uclibc $DIR_LINUX_SYSROOT $DIR_LINUX_OUTPUT
	for GCC_VER in $GCC_VERSIONS ; do
		build_gcc $GCC_VER linux-uclibc "${DIR_LINUX_OUTPUT}"
	done
	install_all_target_libs $DIR_LINUX_OUTPUT bfin-linux-uclibc
fi

if pkgs_queued_any flat fdpic && ${DIR_KBUILD_LOCAL} ; then
	echo_date "linux-headers: cleaning"
	clean_build_dir "$DIR_KBUILD_OUTPUT"
fi

#
# Do random add-on packages
#
export PKG_CONFIG_PATH="${STAGEDIR}/usr/lib/pkgconfig${PKG_CONFIG_PATH:+:${PKG_CONFIG_PATH}}"
: ${PKG_CONFIG:=pkg-config --static}
export PKG_CONFIG

build_uboot
build_qemu
build_libusb
build_ldr_utils
build_libftdi
build_urjtag
build_gdbproxy

#
# Finally do target libraries
#
PATH=$DIR_ELF_OUTPUT/bin:$DIR_uC_OUTPUT/bin:$DIR_LINUX_OUTPUT/bin:$PATH

if [ -e $DIR_SOURCE/libs/Makefile ] ; then
	build_target_libs
fi
build_target_binutils_libs uclinux "${DIR_uC_OUTPUT}"
build_target_binutils_libs linux-uclibc "${DIR_LINUX_OUTPUT}"

########################### Clean up ###########################

# Now that we're done with the random libraries, punt them
for d in "${DIR_ELF_OUTPUT}" "${DIR_uC_OUTPUT}" "${DIR_LINUX_OUTPUT}" ; do
	run_cmd rm -rf \
		"${d}"/lib*/pkgconfig \
		"${d}"/lib*/lib*.a \
		"${d}"/lib*/lib*.la \
		"${d}"/include \
		"${d}"/bin/*-config
	find "${d}" -depth -type d -exec rmdir {} \; 2>/dev/null
done

clean_build_dir "${STAGEDIR}"

resume_clear

echo_date "It took $(print_stop_time) to complete"

if [ -n "${TEST_OPTS}" ] ; then
	echo_date "Testing toolchains"
	set -- \
	"${DIR_APP}"/toolchain-regtest ${TEST_OPTS} \
		${DATE_STAMP:+-d} ${VERBOSE:+-v} ${WARN:+-w} \
		-s "${DIR_SOURCE}"
	log_it "$@"
	"$@"
fi

echo_date "Done"
