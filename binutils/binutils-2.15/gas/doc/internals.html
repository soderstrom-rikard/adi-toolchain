<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from internals.texi on 22 June 2001 -->

<TITLE>Untitled Document</TITLE>
</HEAD>
<BODY>
<H1>Untitled Document</H1>
<P>
<P><HR><P>


<H2><A NAME="SEC1" HREF="internals_toc.html#TOC1">GAS versions</A></H2>

<P>
GAS has acquired layers of code over time.  The original GAS only supported the
a.out object file format, with three sections.  Support for multiple sections
has been added in two different ways.

</P>
<P>
The preferred approach is to use the version of GAS created when the symbol
<CODE>BFD_ASSEMBLER</CODE> is defined.  The other versions of GAS are documented for
historical purposes, and to help anybody who has to debug code written for
them.

</P>
<P>
The type <CODE>segT</CODE> is used to represent a section in code which must work
with all versions of GAS.

</P>



<H3><A NAME="SEC2" HREF="internals_toc.html#TOC2">Original GAS</A></H3>

<P>
The original GAS only supported the a.out object file format with three
sections: <SAMP>`.text'</SAMP>, <SAMP>`.data'</SAMP>, and <SAMP>`.bss'</SAMP>.  This is the version of
GAS that is compiled if neither <CODE>BFD_ASSEMBLER</CODE> nor <CODE>MANY_SEGMENTS</CODE>
is defined.  This version of GAS is still used for the m68k-aout target, and
perhaps others.

</P>
<P>
This version of GAS should not be used for any new development.

</P>
<P>
There is still code that is specific to this version of GAS, notably in
<TT>`write.c'</TT>.  There is no way for this code to loop through all the
sections; it simply looks at global variables like <CODE>text_frag_root</CODE> and
<CODE>data_frag_root</CODE>.

</P>
<P>
The type <CODE>segT</CODE> is an enum.

</P>


<H3><A NAME="SEC3" HREF="internals_toc.html#TOC3">MANY_SEGMENTS gas version</A></H3>
<P>
<A NAME="IDX1"></A>

</P>
<P>
The <CODE>MANY_SEGMENTS</CODE> version of gas is only used for COFF.  It uses the BFD
library, but it writes out all the data itself using <CODE>bfd_write</CODE>.  This
version of gas supports up to 40 normal sections.  The section names are stored
in the <CODE>seg_name</CODE> array.  Other information is stored in the
<CODE>segment_info</CODE> array.

</P>
<P>
The type <CODE>segT</CODE> is an enum.  Code that wants to examine all the sections
can use a <CODE>segT</CODE> variable as loop index from <CODE>SEG_E0</CODE> up to but not
including <CODE>SEG_UNKNOWN</CODE>.

</P>
<P>
Most of the code specific to this version of GAS is in the file
<TT>`config/obj-coff.c'</TT>, in the portion of that file that is compiled when
<CODE>BFD_ASSEMBLER</CODE> is not defined.

</P>
<P>
This version of GAS is still used for several COFF targets.

</P>


<H3><A NAME="SEC4" HREF="internals_toc.html#TOC4">BFD_ASSEMBLER gas version</A></H3>
<P>
<A NAME="IDX2"></A>

</P>
<P>
The preferred version of GAS is the <CODE>BFD_ASSEMBLER</CODE> version.  In this
version of GAS, the output file is a normal BFD, and the BFD routines are used
to generate the output.

</P>
<P>
<CODE>BFD_ASSEMBLER</CODE> will automatically be used for certain targets, including
those that use the ELF, ECOFF, and SOM object file formats, and also all Alpha,
MIPS, PowerPC, and SPARC targets.  You can force the use of
<CODE>BFD_ASSEMBLER</CODE> for other targets with the configure option
<SAMP>`--enable-bfd-assembler'</SAMP>; however, it has not been tested for many
targets, and can not be assumed to work.

</P>


<H2><A NAME="SEC5" HREF="internals_toc.html#TOC5">Data types</A></H2>
<P>
<A NAME="IDX3"></A>

</P>
<P>
This section describes some fundamental GAS data types.

</P>



<H3><A NAME="SEC6" HREF="internals_toc.html#TOC6">Symbols</A></H3>
<P>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>

</P>
<P>
The definition for <CODE>struct symbol</CODE>, also known as <CODE>symbolS</CODE>, is
located in <TT>`struc-symbol.h'</TT>.  Symbol structures contain the following
fields:

</P>
<DL COMPACT>

<DT><CODE>sy_value</CODE>
<DD>
This is an <CODE>expressionS</CODE> that describes the value of the symbol.  It might
refer to one or more other symbols; if so, its true value may not be known
until <CODE>resolve_symbol_value</CODE> is called in <CODE>write_object_file</CODE>.

The expression is often simply a constant.  Before <CODE>resolve_symbol_value</CODE>
is called, the value is the offset from the frag (see section <A HREF="internals.html#SEC9">Frags</A>).  Afterward,
the frag address has been added in.

<DT><CODE>sy_resolved</CODE>
<DD>
This field is non-zero if the symbol's value has been completely resolved.  It
is used during the final pass over the symbol table.

<DT><CODE>sy_resolving</CODE>
<DD>
This field is used to detect loops while resolving the symbol's value.

<DT><CODE>sy_used_in_reloc</CODE>
<DD>
This field is non-zero if the symbol is used by a relocation entry.  If a local
symbol is used in a relocation entry, it must be possible to redirect those
relocations to other symbols, or this symbol cannot be removed from the final
symbol list.

<DT><CODE>sy_next</CODE>
<DD>
<DT><CODE>sy_previous</CODE>
<DD>
These pointers to other <CODE>symbolS</CODE> structures describe a singly or doubly
linked list.  (If <CODE>SYMBOLS_NEED_BACKPOINTERS</CODE> is not defined, the
<CODE>sy_previous</CODE> field will be omitted; <CODE>SYMBOLS_NEED_BACKPOINTERS</CODE> is
always defined if <CODE>BFD_ASSEMBLER</CODE>.)  These fields should be accessed with
the <CODE>symbol_next</CODE> and <CODE>symbol_previous</CODE> macros.

<DT><CODE>sy_frag</CODE>
<DD>
This points to the frag (see section <A HREF="internals.html#SEC9">Frags</A>) that this symbol is attached to.

<DT><CODE>sy_used</CODE>
<DD>
Whether the symbol is used as an operand or in an expression.  Note: Not all of
the backends keep this information accurate; backends which use this bit are
responsible for setting it when a symbol is used in backend routines.

<DT><CODE>sy_mri_common</CODE>
<DD>
Whether the symbol is an MRI common symbol created by the <CODE>COMMON</CODE>
pseudo-op when assembling in MRI mode.

<DT><CODE>bsym</CODE>
<DD>
If <CODE>BFD_ASSEMBLER</CODE> is defined, this points to the BFD <CODE>asymbol</CODE> that
will be used in writing the object file.

<DT><CODE>sy_name_offset</CODE>
<DD>
(Only used if <CODE>BFD_ASSEMBLER</CODE> is not defined.)  This is the position of
the symbol's name in the string table of the object file.  On some formats,
this will start at position 4, with position 0 reserved for unnamed symbols.
This field is not used until <CODE>write_object_file</CODE> is called.

<DT><CODE>sy_symbol</CODE>
<DD>
(Only used if <CODE>BFD_ASSEMBLER</CODE> is not defined.)  This is the
format-specific symbol structure, as it would be written into the object file.

<DT><CODE>sy_number</CODE>
<DD>
(Only used if <CODE>BFD_ASSEMBLER</CODE> is not defined.)  This is a 24-bit symbol
number, for use in constructing relocation table entries.

<DT><CODE>sy_obj</CODE>
<DD>
This format-specific data is of type <CODE>OBJ_SYMFIELD_TYPE</CODE>.  If no macro by
that name is defined in <TT>`obj-format.h'</TT>, this field is not defined.

<DT><CODE>sy_tc</CODE>
<DD>
This processor-specific data is of type <CODE>TC_SYMFIELD_TYPE</CODE>.  If no macro
by that name is defined in <TT>`targ-cpu.h'</TT>, this field is not defined.

<DT><CODE>TARGET_SYMBOL_FIELDS</CODE>
<DD>
If this macro is defined, it defines additional fields in the symbol structure.
This macro is obsolete, and should be replaced when possible by uses of
<CODE>OBJ_SYMFIELD_TYPE</CODE> and <CODE>TC_SYMFIELD_TYPE</CODE>.
</DL>

<P>
There are a number of access routines used to extract the fields of a
<CODE>symbolS</CODE> structure.  When possible, these routines should be used rather
than referring to the fields directly.  These routines will work for any GAS
version.

</P>
<DL COMPACT>

<DT><CODE>S_SET_VALUE</CODE>
<DD>
<A NAME="IDX7"></A>
Set the symbol's value.

<DT><CODE>S_GET_VALUE</CODE>
<DD>
<A NAME="IDX8"></A>
Get the symbol's value.  This will cause <CODE>resolve_symbol_value</CODE> to be
called if necessary, so <CODE>S_GET_VALUE</CODE> should only be called when it is
safe to resolve symbols (i.e., after the entire input file has been read and
all symbols have been defined).

<DT><CODE>S_SET_SEGMENT</CODE>
<DD>
<A NAME="IDX9"></A>
Set the section of the symbol.

<DT><CODE>S_GET_SEGMENT</CODE>
<DD>
<A NAME="IDX10"></A>
Get the symbol's section.

<DT><CODE>S_GET_NAME</CODE>
<DD>
<A NAME="IDX11"></A>
Get the name of the symbol.

<DT><CODE>S_SET_NAME</CODE>
<DD>
<A NAME="IDX12"></A>
Set the name of the symbol.

<DT><CODE>S_IS_EXTERNAL</CODE>
<DD>
<A NAME="IDX13"></A>
Return non-zero if the symbol is externally visible.

<DT><CODE>S_IS_EXTERN</CODE>
<DD>
<A NAME="IDX14"></A>
A synonym for <CODE>S_IS_EXTERNAL</CODE>.  Don't use it.

<DT><CODE>S_IS_WEAK</CODE>
<DD>
<A NAME="IDX15"></A>
Return non-zero if the symbol is weak.

<DT><CODE>S_IS_COMMON</CODE>
<DD>
<A NAME="IDX16"></A>
Return non-zero if this is a common symbol.  Common symbols are sometimes
represented as undefined symbols with a value, in which case this function will
not be reliable.

<DT><CODE>S_IS_DEFINED</CODE>
<DD>
<A NAME="IDX17"></A>
Return non-zero if this symbol is defined.  This function is not reliable when
called on a common symbol.

<DT><CODE>S_IS_DEBUG</CODE>
<DD>
<A NAME="IDX18"></A>
Return non-zero if this is a debugging symbol.

<DT><CODE>S_IS_LOCAL</CODE>
<DD>
<A NAME="IDX19"></A>
Return non-zero if this is a local assembler symbol which should not be
included in the final symbol table.  Note that this is not the opposite of
<CODE>S_IS_EXTERNAL</CODE>.  The <SAMP>`-L'</SAMP> assembler option affects the return value
of this function.

<DT><CODE>S_SET_EXTERNAL</CODE>
<DD>
<A NAME="IDX20"></A>
Mark the symbol as externally visible.

<DT><CODE>S_CLEAR_EXTERNAL</CODE>
<DD>
<A NAME="IDX21"></A>
Mark the symbol as not externally visible.

<DT><CODE>S_SET_WEAK</CODE>
<DD>
<A NAME="IDX22"></A>
Mark the symbol as weak.

<DT><CODE>S_GET_TYPE</CODE>
<DD>
<DT><CODE>S_GET_DESC</CODE>
<DD>
<DT><CODE>S_GET_OTHER</CODE>
<DD>
<A NAME="IDX23"></A>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
Get the <CODE>type</CODE>, <CODE>desc</CODE>, and <CODE>other</CODE> fields of the symbol.  These
are only defined for object file formats for which they make sense (primarily
a.out).

<DT><CODE>S_SET_TYPE</CODE>
<DD>
<DT><CODE>S_SET_DESC</CODE>
<DD>
<DT><CODE>S_SET_OTHER</CODE>
<DD>
<A NAME="IDX26"></A>
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>
Set the <CODE>type</CODE>, <CODE>desc</CODE>, and <CODE>other</CODE> fields of the symbol.  These
are only defined for object file formats for which they make sense (primarily
a.out).

<DT><CODE>S_GET_SIZE</CODE>
<DD>
<A NAME="IDX29"></A>
Get the size of a symbol.  This is only defined for object file formats for
which it makes sense (primarily ELF).

<DT><CODE>S_SET_SIZE</CODE>
<DD>
<A NAME="IDX30"></A>
Set the size of a symbol.  This is only defined for object file formats for
which it makes sense (primarily ELF).
</DL>



<H3><A NAME="SEC7" HREF="internals_toc.html#TOC7">Expressions</A></H3>
<P>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>
<A NAME="IDX33"></A>

</P>
<P>
Expressions are stored in an <CODE>expressionS</CODE> structure.  The structure is
defined in <TT>`expr.h'</TT>.

</P>
<P>
<A NAME="IDX34"></A>
The macro <CODE>expression</CODE> will create an <CODE>expressionS</CODE> structure based
on the text found at the global variable <CODE>input_line_pointer</CODE>.

</P>
<P>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>
A single <CODE>expressionS</CODE> structure can represent a single operation.
Complex expressions are formed by creating <STRONG>expression symbols</STRONG> and
combining them in <CODE>expressionS</CODE> structures.  An expression symbol is
created by calling <CODE>make_expr_symbol</CODE>.  An expression symbol should
naturally never appear in a symbol table, and the implementation of
<CODE>S_IS_LOCAL</CODE> (see section <A HREF="internals.html#SEC6">Symbols</A>) reflects that.  The function
<CODE>expr_symbol_where</CODE> returns non-zero if a symbol is an expression symbol,
and also returns the file and line for the expression which caused it to be
created.

</P>
<P>
The <CODE>expressionS</CODE> structure has two symbol fields, a number field, an
operator field, and a field indicating whether the number is unsigned.

</P>
<P>
The operator field is of type <CODE>operatorT</CODE>, and describes how to interpret
the other fields; see the definition in <TT>`expr.h'</TT> for the possibilities.

</P>
<P>
An <CODE>operatorT</CODE> value of <CODE>O_big</CODE> indicates either a floating point
number, stored in the global variable <CODE>generic_floating_point_number</CODE>, or
an integer to large to store in an <CODE>offsetT</CODE> type, stored in the global
array <CODE>generic_bignum</CODE>.  This rather inflexible approach makes it
impossible to use floating point numbers or large expressions in complex
expressions.

</P>


<H3><A NAME="SEC8" HREF="internals_toc.html#TOC8">Fixups</A></H3>
<P>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>

</P>
<P>
A <STRONG>fixup</STRONG> is basically anything which can not be resolved in the first
pass.  Sometimes a fixup can be resolved by the end of the assembly; if not,
the fixup becomes a relocation entry in the object file.

</P>
<P>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
A fixup is created by a call to <CODE>fix_new</CODE> or <CODE>fix_new_exp</CODE>.  Both
take a frag (see section <A HREF="internals.html#SEC9">Frags</A>), a position within the frag, a size, an indication
of whether the fixup is PC relative, and a type.  In a <CODE>BFD_ASSEMBLER</CODE>
GAS, the type is nominally a <CODE>bfd_reloc_code_real_type</CODE>, but several
targets use other type codes to represent fixups that can not be described as
relocations.

</P>
<P>
The <CODE>fixS</CODE> structure has a number of fields, several of which are obsolete
or are only used by a particular target.  The important fields are:

</P>
<DL COMPACT>

<DT><CODE>fx_frag</CODE>
<DD>
The frag (see section <A HREF="internals.html#SEC9">Frags</A>) this fixup is in.

<DT><CODE>fx_where</CODE>
<DD>
The location within the frag where the fixup occurs.

<DT><CODE>fx_addsy</CODE>
<DD>
The symbol this fixup is against.  Typically, the value of this symbol is added
into the object contents.  This may be NULL.

<DT><CODE>fx_subsy</CODE>
<DD>
The value of this symbol is subtracted from the object contents.  This is
normally NULL.

<DT><CODE>fx_offset</CODE>
<DD>
A number which is added into the fixup.

<DT><CODE>fx_addnumber</CODE>
<DD>
Some CPU backends use this field to convey information between
<CODE>md_apply_fix</CODE> and <CODE>tc_gen_reloc</CODE>.  The machine independent code does
not use it.

<DT><CODE>fx_next</CODE>
<DD>
The next fixup in the section.

<DT><CODE>fx_r_type</CODE>
<DD>
The type of the fixup.  This field is only defined if <CODE>BFD_ASSEMBLER</CODE>, or
if the target defines <CODE>NEED_FX_R_TYPE</CODE>.

<DT><CODE>fx_size</CODE>
<DD>
The size of the fixup.  This is mostly used for error checking.

<DT><CODE>fx_pcrel</CODE>
<DD>
Whether the fixup is PC relative.

<DT><CODE>fx_done</CODE>
<DD>
Non-zero if the fixup has been applied, and no relocation entry needs to be
generated.

<DT><CODE>fx_file</CODE>
<DD>
<DT><CODE>fx_line</CODE>
<DD>
The file and line where the fixup was created.

<DT><CODE>tc_fix_data</CODE>
<DD>
This has the type <CODE>TC_FIX_TYPE</CODE>, and is only defined if the target defines
that macro.
</DL>



<H3><A NAME="SEC9" HREF="internals_toc.html#TOC9">Frags</A></H3>
<P>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>

</P>
<P>
The <CODE>fragS</CODE> structure is defined in <TT>`as.h'</TT>.  Each frag represents a
portion of the final object file.  As GAS reads the source file, it creates
frags to hold the data that it reads.  At the end of the assembly the frags and
fixups are processed to produce the final contents.

</P>
<DL COMPACT>

<DT><CODE>fr_address</CODE>
<DD>
The address of the frag.  This is not set until the assembler rescans the list
of all frags after the entire input file is parsed.  The function
<CODE>relax_segment</CODE> fills in this field.

<DT><CODE>fr_next</CODE>
<DD>
Pointer to the next frag in this (sub)section.

<DT><CODE>fr_fix</CODE>
<DD>
Fixed number of characters we know we're going to emit to the output file.  May
be zero.

<DT><CODE>fr_var</CODE>
<DD>
Variable number of characters we may output, after the initial <CODE>fr_fix</CODE>
characters.  May be zero.

<DT><CODE>fr_offset</CODE>
<DD>
The interpretation of this field is controlled by <CODE>fr_type</CODE>.  Generally,
if <CODE>fr_var</CODE> is non-zero, this is a repeat count: the <CODE>fr_var</CODE>
characters are output <CODE>fr_offset</CODE> times.

<DT><CODE>line</CODE>
<DD>
Holds line number info when an assembler listing was requested.

<DT><CODE>fr_type</CODE>
<DD>
Relaxation state.  This field indicates the interpretation of <CODE>fr_offset</CODE>,
<CODE>fr_symbol</CODE> and the variable-length tail of the frag, as well as the
treatment it gets in various phases of processing.  It does not affect the
initial <CODE>fr_fix</CODE> characters; they are always supposed to be output
verbatim (fixups aside).  See below for specific values this field can have.

<DT><CODE>fr_subtype</CODE>
<DD>
Relaxation substate.  If the macro <CODE>md_relax_frag</CODE> isn't defined, this is
assumed to be an index into <CODE>TC_GENERIC_RELAX_TABLE</CODE> for the generic
relaxation code to process (see section <A HREF="internals.html#SEC15">Relaxation</A>).  If <CODE>md_relax_frag</CODE> is
defined, this field is available for any use by the CPU-specific code.

<DT><CODE>fr_symbol</CODE>
<DD>
This normally indicates the symbol to use when relaxing the frag according to
<CODE>fr_type</CODE>.

<DT><CODE>fr_opcode</CODE>
<DD>
Points to the lowest-addressed byte of the opcode, for use in relaxation.

<DT><CODE>tc_frag_data</CODE>
<DD>
Target specific fragment data of type TC_FRAG_TYPE.
Only present if <CODE>TC_FRAG_TYPE</CODE> is defined.

<DT><CODE>fr_file</CODE>
<DD>
<DT><CODE>fr_line</CODE>
<DD>
The file and line where this frag was last modified.

<DT><CODE>fr_literal</CODE>
<DD>
Declared as a one-character array, this last field grows arbitrarily large to
hold the actual contents of the frag.
</DL>

<P>
These are the possible relaxation states, provided in the enumeration type
<CODE>relax_stateT</CODE>, and the interpretations they represent for the other
fields:

</P>
<DL COMPACT>

<DT><CODE>rs_align</CODE>
<DD>
<DT><CODE>rs_align_code</CODE>
<DD>
The start of the following frag should be aligned on some boundary.  In this
frag, <CODE>fr_offset</CODE> is the logarithm (base 2) of the alignment in bytes.
(For example, if alignment on an 8-byte boundary were desired, <CODE>fr_offset</CODE>
would have a value of 3.)  The variable characters indicate the fill pattern to
be used.  The <CODE>fr_subtype</CODE> field holds the maximum number of bytes to skip
when doing this alignment.  If more bytes are needed, the alignment is not
done.  An <CODE>fr_subtype</CODE> value of 0 means no maximum, which is the normal
case.  Target backends can use <CODE>rs_align_code</CODE> to handle certain types of
alignment differently.

<DT><CODE>rs_broken_word</CODE>
<DD>
This indicates that "broken word" processing should be done (see section <A HREF="internals.html#SEC18">Broken words</A>).  If broken word processing is not necessary on the target machine,
this enumerator value will not be defined.

<DT><CODE>rs_cfa</CODE>
<DD>
This state is used to implement exception frame optimizations.  The
<CODE>fr_symbol</CODE> is an expression symbol for the subtraction which may be
relaxed.  The <CODE>fr_opcode</CODE> field holds the frag for the preceding command
byte.  The <CODE>fr_offset</CODE> field holds the offset within that frag.  The
<CODE>fr_subtype</CODE> field is used during relaxation to hold the current size of
the frag.

<DT><CODE>rs_fill</CODE>
<DD>
The variable characters are to be repeated <CODE>fr_offset</CODE> times.  If
<CODE>fr_offset</CODE> is 0, this frag has a length of <CODE>fr_fix</CODE>.  Most frags
have this type.

<DT><CODE>rs_leb128</CODE>
<DD>
This state is used to implement the DWARF "little endian base 128" 
variable length number format.  The <CODE>fr_symbol</CODE> is always an expression
symbol, as constant expressions are emitted directly.  The <CODE>fr_offset</CODE>
field is used during relaxation to hold the previous size of the number so
that we can determine if the fragment changed size.

<DT><CODE>rs_machine_dependent</CODE>
<DD>
Displacement relaxation is to be done on this frag.  The target is indicated by
<CODE>fr_symbol</CODE> and <CODE>fr_offset</CODE>, and <CODE>fr_subtype</CODE> indicates the
particular machine-specific addressing mode desired.  See section <A HREF="internals.html#SEC15">Relaxation</A>.

<DT><CODE>rs_org</CODE>
<DD>
The start of the following frag should be pushed back to some specific offset
within the section.  (Some assemblers use the value as an absolute address; GAS
does not handle final absolute addresses, but rather requires that the linker
set them.)  The offset is given by <CODE>fr_symbol</CODE> and <CODE>fr_offset</CODE>; one
character from the variable-length tail is used as the fill character.
</DL>

<P>
<A NAME="IDX45"></A>
A chain of frags is built up for each subsection.  The data structure
describing a chain is called a <CODE>frchainS</CODE>, and contains the following
fields:

</P>
<DL COMPACT>

<DT><CODE>frch_root</CODE>
<DD>
Points to the first frag in the chain.  May be NULL if there are no frags in
this chain.
<DT><CODE>frch_last</CODE>
<DD>
Points to the last frag in the chain, or NULL if there are none.
<DT><CODE>frch_next</CODE>
<DD>
Next in the list of <CODE>frchainS</CODE> structures.
<DT><CODE>frch_seg</CODE>
<DD>
Indicates the section this frag chain belongs to.
<DT><CODE>frch_subseg</CODE>
<DD>
Subsection (subsegment) number of this frag chain.
<DT><CODE>fix_root, fix_tail</CODE>
<DD>
(Defined only if <CODE>BFD_ASSEMBLER</CODE> is defined).  Point to first and last
<CODE>fixS</CODE> structures associated with this subsection.
<DT><CODE>frch_obstack</CODE>
<DD>
Not currently used.  Intended to be used for frag allocation for this
subsection.  This should reduce frag generation caused by switching sections.
<DT><CODE>frch_frag_now</CODE>
<DD>
The current frag for this subsegment.
</DL>

<P>
A <CODE>frchainS</CODE> corresponds to a subsection; each section has a list of
<CODE>frchainS</CODE> records associated with it.  In most cases, only one subsection
of each section is used, so the list will only be one element long, but any
processing of frag chains should be prepared to deal with multiple chains per
section.

</P>
<P>
After the input files have been completely processed, and no more frags are to
be generated, the frag chains are joined into one per section for further
processing.  After this point, it is safe to operate on one chain per section.

</P>
<P>
The assembler always has a current frag, named <CODE>frag_now</CODE>.  More space is
allocated for the current frag using the <CODE>frag_more</CODE> function; this
returns a pointer to the amount of requested space.  Relaxing is done using
variant frags allocated by <CODE>frag_var</CODE> or <CODE>frag_variant</CODE>
(see section <A HREF="internals.html#SEC15">Relaxation</A>).

</P>


<H2><A NAME="SEC10" HREF="internals_toc.html#TOC10">What GAS does when it runs</A></H2>
<P>
<A NAME="IDX46"></A>

</P>
<P>
This is a quick look at what an assembler run looks like.

</P>

<UL>
<LI>

The assembler initializes itself by calling various init routines.

<LI>

For each source file, the <CODE>read_a_source_file</CODE> function reads in the file
and parses it.  The global variable <CODE>input_line_pointer</CODE> points to the
current text; it is guaranteed to be correct up to the end of the line, but not
farther.

<LI>

For each line, the assembler passes labels to the <CODE>colon</CODE> function, and
isolates the first word.  If it looks like a pseudo-op, the word is looked up
in the pseudo-op hash table <CODE>po_hash</CODE> and dispatched to a pseudo-op
routine.  Otherwise, the target dependent <CODE>md_assemble</CODE> routine is called
to parse the instruction.

<LI>

When pseudo-ops or instructions output data, they add it to a frag, calling
<CODE>frag_more</CODE> to get space to store it in.

<LI>

Pseudo-ops and instructions can also output fixups created by <CODE>fix_new</CODE> or
<CODE>fix_new_exp</CODE>.

<LI>

For certain targets, instructions can create variant frags which are used to
store relaxation information (see section <A HREF="internals.html#SEC15">Relaxation</A>).

<LI>

When the input file is finished, the <CODE>write_object_file</CODE> routine is
called.  It assigns addresses to all the frags (<CODE>relax_segment</CODE>), resolves
all the fixups (<CODE>fixup_segment</CODE>), resolves all the symbol values (using
<CODE>resolve_symbol_value</CODE>), and finally writes out the file (in the
<CODE>BFD_ASSEMBLER</CODE> case, this is done by simply calling <CODE>bfd_close</CODE>).
</UL>



<H2><A NAME="SEC11" HREF="internals_toc.html#TOC11">Porting GAS</A></H2>
<P>
<A NAME="IDX47"></A>

</P>
<P>
Each GAS target specifies two main things: the CPU file and the object format
file.  Two main switches in the <TT>`configure.in'</TT> file handle this.  The
first switches on CPU type to set the shell variable <CODE>cpu_type</CODE>.  The
second switches on the entire target to set the shell variable <CODE>fmt</CODE>.

</P>
<P>
The configure script uses the value of <CODE>cpu_type</CODE> to select two files in
the <TT>`config'</TT> directory: <TT>`tc-<VAR>CPU</VAR>.c'</TT> and <TT>`tc-<VAR>CPU</VAR>.h'</TT>.
The configuration process will create a file named <TT>`targ-cpu.h'</TT> in the
build directory which includes <TT>`tc-<VAR>CPU</VAR>.h'</TT>.

</P>
<P>
The configure script also uses the value of <CODE>fmt</CODE> to select two files:
<TT>`obj-<VAR>fmt</VAR>.c'</TT> and <TT>`obj-<VAR>fmt</VAR>.h'</TT>.  The configuration process
will create a file named <TT>`obj-format.h'</TT> in the build directory which
includes <TT>`obj-<VAR>fmt</VAR>.h'</TT>.

</P>
<P>
You can also set the emulation in the configure script by setting the <CODE>em</CODE>
variable.  Normally the default value of <SAMP>`generic'</SAMP> is fine.  The
configuration process will create a file named <TT>`targ-env.h'</TT> in the build
directory which includes <TT>`te-<VAR>em</VAR>.h'</TT>.

</P>
<P>
Porting GAS to a new CPU requires writing the <TT>`tc-<VAR>CPU</VAR>'</TT> files.
Porting GAS to a new object file format requires writing the
<TT>`obj-<VAR>fmt</VAR>'</TT> files.  There is sometimes some interaction between these
two files, but it is normally minimal.

</P>
<P>
The best approach is, of course, to copy existing files.  The documentation
below assumes that you are looking at existing files to see usage details.

</P>
<P>
These interfaces have grown over time, and have never been carefully thought
out or designed.  Nothing about the interfaces described here is cast in stone.
It is possible that they will change from one version of the assembler to the
next.  Also, new macros are added all the time as they are needed.

</P>



<H3><A NAME="SEC12" HREF="internals_toc.html#TOC12">Writing a CPU backend</A></H3>
<P>
<A NAME="IDX48"></A>
<A NAME="IDX49"></A>

</P>
<P>
The CPU backend files are the heart of the assembler.  They are the only parts
of the assembler which actually know anything about the instruction set of the
processor.

</P>
<P>
You must define a reasonably small list of macros and functions in the CPU
backend files.  You may define a large number of additional macros in the CPU
backend files, not all of which are documented here.  You must, of course,
define macros in the <TT>`.h'</TT> file, which is included by every assembler
source file.  You may define the functions as macros in the <TT>`.h'</TT> file, or
as functions in the <TT>`.c'</TT> file.

</P>
<DL COMPACT>

<DT><CODE>TC_<VAR>CPU</VAR></CODE>
<DD>
<A NAME="IDX50"></A>
By convention, you should define this macro in the <TT>`.h'</TT> file.  For
example, <TT>`tc-m68k.h'</TT> defines <CODE>TC_M68K</CODE>.  You might have to use this
if it is necessary to add CPU specific code to the object format file.

<DT><CODE>TARGET_FORMAT</CODE>
<DD>
This macro is the BFD target name to use when creating the output file.  This
will normally depend upon the <CODE>OBJ_<VAR>FMT</VAR></CODE> macro.

<DT><CODE>TARGET_ARCH</CODE>
<DD>
This macro is the BFD architecture to pass to <CODE>bfd_set_arch_mach</CODE>.

<DT><CODE>TARGET_MACH</CODE>
<DD>
This macro is the BFD machine number to pass to <CODE>bfd_set_arch_mach</CODE>.  If
it is not defined, GAS will use 0.

<DT><CODE>TARGET_BYTES_BIG_ENDIAN</CODE>
<DD>
You should define this macro to be non-zero if the target is big endian, and
zero if the target is little endian.

<DT><CODE>md_shortopts</CODE>
<DD>
<DT><CODE>md_longopts</CODE>
<DD>
<DT><CODE>md_longopts_size</CODE>
<DD>
<DT><CODE>md_parse_option</CODE>
<DD>
<DT><CODE>md_show_usage</CODE>
<DD>
<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>
GAS uses these variables and functions during option processing.
<CODE>md_shortopts</CODE> is a <CODE>const char *</CODE> which GAS adds to the machine
independent string passed to <CODE>getopt</CODE>.  <CODE>md_longopts</CODE> is a
<CODE>struct option []</CODE> which GAS adds to the machine independent long options
passed to <CODE>getopt</CODE>; you may use <CODE>OPTION_MD_BASE</CODE>, defined in
<TT>`as.h'</TT>, as the start of a set of long option indices, if necessary.
<CODE>md_longopts_size</CODE> is a <CODE>size_t</CODE> holding the size <CODE>md_longopts</CODE>.
GAS will call <CODE>md_parse_option</CODE> whenever <CODE>getopt</CODE> returns an
unrecognized code, presumably indicating a special code value which appears in
<CODE>md_longopts</CODE>.  GAS will call <CODE>md_show_usage</CODE> when a usage message is
printed; it should print a description of the machine specific options.

<DT><CODE>md_begin</CODE>
<DD>
<A NAME="IDX56"></A>
GAS will call this function at the start of the assembly, after the command
line arguments have been parsed and all the machine independent initializations
have been completed.

<DT><CODE>md_cleanup</CODE>
<DD>
<A NAME="IDX57"></A>
If you define this macro, GAS will call it at the end of each input file.

<DT><CODE>md_assemble</CODE>
<DD>
<A NAME="IDX58"></A>
GAS will call this function for each input line which does not contain a
pseudo-op.  The argument is a null terminated string.  The function should
assemble the string as an instruction with operands.  Normally
<CODE>md_assemble</CODE> will do this by calling <CODE>frag_more</CODE> and writing out
some bytes (see section <A HREF="internals.html#SEC9">Frags</A>).  <CODE>md_assemble</CODE> will call <CODE>fix_new</CODE> to
create fixups as needed (see section <A HREF="internals.html#SEC8">Fixups</A>).  Targets which need to do special
purpose relaxation will call <CODE>frag_var</CODE>.

<DT><CODE>md_pseudo_table</CODE>
<DD>
<A NAME="IDX59"></A>
This is a const array of type <CODE>pseudo_typeS</CODE>.  It is a mapping from
pseudo-op names to functions.  You should use this table to implement
pseudo-ops which are specific to the CPU.

<DT><CODE>tc_conditional_pseudoop</CODE>
<DD>
<A NAME="IDX60"></A>
If this macro is defined, GAS will call it with a <CODE>pseudo_typeS</CODE> argument.
It should return non-zero if the pseudo-op is a conditional which controls
whether code is assembled, such as <SAMP>`.if'</SAMP>.  GAS knows about the normal
conditional pseudo-ops,and you should normally not have to define this macro.

<DT><CODE>comment_chars</CODE>
<DD>
<A NAME="IDX61"></A>
This is a null terminated <CODE>const char</CODE> array of characters which start a
comment.

<DT><CODE>tc_comment_chars</CODE>
<DD>
<A NAME="IDX62"></A>
If this macro is defined, GAS will use it instead of <CODE>comment_chars</CODE>.

<DT><CODE>line_comment_chars</CODE>
<DD>
<A NAME="IDX63"></A>
This is a null terminated <CODE>const char</CODE> array of characters which start a
comment when they appear at the start of a line.

<DT><CODE>line_separator_chars</CODE>
<DD>
<A NAME="IDX64"></A>
This is a null terminated <CODE>const char</CODE> array of characters which separate
lines (the semicolon is such a character by default, and need not be listed in
this array).

<DT><CODE>EXP_CHARS</CODE>
<DD>
<A NAME="IDX65"></A>
This is a null terminated <CODE>const char</CODE> array of characters which may be
used as the exponent character in a floating point number.  This is normally
<CODE>"eE"</CODE>.

<DT><CODE>FLT_CHARS</CODE>
<DD>
<A NAME="IDX66"></A>
This is a null terminated <CODE>const char</CODE> array of characters which may be
used to indicate a floating point constant.  A zero followed by one of these
characters is assumed to be followed by a floating point number; thus they
operate the way that <CODE>0x</CODE> is used to indicate a hexadecimal constant.
Usually this includes <SAMP>`r'</SAMP> and <SAMP>`f'</SAMP>.

<DT><CODE>LEX_AT</CODE>
<DD>
<A NAME="IDX67"></A>
You may define this macro to the lexical type of the <KBD>}</KBD> character.  The
default is zero.

Lexical types are a combination of <CODE>LEX_NAME</CODE> and <CODE>LEX_BEGIN_NAME</CODE>,
both defined in <TT>`read.h'</TT>.  <CODE>LEX_NAME</CODE> indicates that the character
may appear in a name.  <CODE>LEX_BEGIN_NAME</CODE> indicates that the character may
appear at the beginning of a nem.

<DT><CODE>LEX_BR</CODE>
<DD>
<A NAME="IDX68"></A>
You may define this macro to the lexical type of the brace characters <KBD>{</KBD>,
<KBD>}</KBD>, <KBD>[</KBD>, and <KBD>]</KBD>.  The default value is zero.

<DT><CODE>LEX_PCT</CODE>
<DD>
<A NAME="IDX69"></A>
You may define this macro to the lexical type of the <KBD>%</KBD> character.  The
default value is zero.

<DT><CODE>LEX_QM</CODE>
<DD>
<A NAME="IDX70"></A>
You may define this macro to the lexical type of the <KBD>?</KBD> character.  The
default value it zero.

<DT><CODE>LEX_DOLLAR</CODE>
<DD>
<A NAME="IDX71"></A>
You may define this macro to the lexical type of the <KBD>$</KBD> character.  The
default value is <CODE>LEX_NAME | LEX_BEGIN_NAME</CODE>.

<DT><CODE>SINGLE_QUOTE_STRINGS</CODE>
<DD>
<A NAME="IDX72"></A>
If you define this macro, GAS will treat single quotes as string delimiters.
Normally only double quotes are accepted as string delimiters.

<DT><CODE>NO_STRING_ESCAPES</CODE>
<DD>
<A NAME="IDX73"></A>
If you define this macro, GAS will not permit escape sequences in a string.

<DT><CODE>ONLY_STANDARD_ESCAPES</CODE>
<DD>
<A NAME="IDX74"></A>
If you define this macro, GAS will warn about the use of nonstandard escape
sequences in a string.

<DT><CODE>md_start_line_hook</CODE>
<DD>
<A NAME="IDX75"></A>
If you define this macro, GAS will call it at the start of each line.

<DT><CODE>LABELS_WITHOUT_COLONS</CODE>
<DD>
<A NAME="IDX76"></A>
If you define this macro, GAS will assume that any text at the start of a line
is a label, even if it does not have a colon.

<DT><CODE>TC_START_LABEL</CODE>
<DD>
<A NAME="IDX77"></A>
You may define this macro to control what GAS considers to be a label.  The
default definition is to accept any name followed by a colon character.

<DT><CODE>NO_PSEUDO_DOT</CODE>
<DD>
<A NAME="IDX78"></A>
If you define this macro, GAS will not require pseudo-ops to start with a
<KBD>.</KBD> character.

<DT><CODE>TC_EQUAL_IN_INSN</CODE>
<DD>
<A NAME="IDX79"></A>
If you define this macro, it should return nonzero if the instruction is
permitted to contain an <KBD>=</KBD> character.  GAS will use this to decide if a
<KBD>=</KBD> is an assignment or an instruction.

<DT><CODE>TC_EOL_IN_INSN</CODE>
<DD>
<A NAME="IDX80"></A>
If you define this macro, it should return nonzero if the current input line
pointer should be treated as the end of a line.

<DT><CODE>md_parse_name</CODE>
<DD>
<A NAME="IDX81"></A>
If this macro is defined, GAS will call it for any symbol found in an
expression.  You can define this to handle special symbols in a special way.
If a symbol always has a certain value, you should normally enter it in the
symbol table, perhaps using <CODE>reg_section</CODE>.

<DT><CODE>md_undefined_symbol</CODE>
<DD>
<A NAME="IDX82"></A>
GAS will call this function when a symbol table lookup fails, before it
creates a new symbol.  Typically this would be used to supply symbols whose
name or value changes dynamically, possibly in a context sensitive way.
Predefined symbols with fixed values, such as register names or condition
codes, are typically entered directly into the symbol table when <CODE>md_begin</CODE>
is called.

<DT><CODE>md_operand</CODE>
<DD>
<A NAME="IDX83"></A>
GAS will call this function for any expression that can not be recognized.
When the function is called, <CODE>input_line_pointer</CODE> will point to the start
of the expression.

<DT><CODE>tc_unrecognized_line</CODE>
<DD>
<A NAME="IDX84"></A>
If you define this macro, GAS will call it when it finds a line that it can not
parse.

<DT><CODE>md_do_align</CODE>
<DD>
<A NAME="IDX85"></A>
You may define this macro to handle an alignment directive.  GAS will call it
when the directive is seen in the input file.  For example, the i386 backend
uses this to generate efficient nop instructions of varying lengths, depending
upon the number of bytes that the alignment will skip.

<DT><CODE>HANDLE_ALIGN</CODE>
<DD>
<A NAME="IDX86"></A>
You may define this macro to do special handling for an alignment directive.
GAS will call it at the end of the assembly.

<DT><CODE>md_flush_pending_output</CODE>
<DD>
<A NAME="IDX87"></A>
If you define this macro, GAS will call it each time it skips any space because of a
space filling or alignment or data allocation pseudo-op.

<DT><CODE>TC_PARSE_CONS_EXPRESSION</CODE>
<DD>
<A NAME="IDX88"></A>
You may define this macro to parse an expression used in a data allocation
pseudo-op such as <CODE>.word</CODE>.  You can use this to recognize relocation
directives that may appear in such directives.

<DT><CODE>BITFIELD_CONS_EXPRESSION</CODE>
<DD>
<A NAME="IDX89"></A>
If you define this macro, GAS will recognize bitfield instructions in data
allocation pseudo-ops, as used on the i960.

<DT><CODE>REPEAT_CONS_EXPRESSION</CODE>
<DD>
<A NAME="IDX90"></A>
If you define this macro, GAS will recognize repeat counts in data allocation
pseudo-ops, as used on the MIPS.

<DT><CODE>md_cons_align</CODE>
<DD>
<A NAME="IDX91"></A>
You may define this macro to do any special alignment before a data allocation
pseudo-op.

<DT><CODE>TC_CONS_FIX_NEW</CODE>
<DD>
<A NAME="IDX92"></A>
You may define this macro to generate a fixup for a data allocation pseudo-op.

<DT><CODE>TC_INIT_FIX_DATA (<VAR>fixp</VAR>)</CODE>
<DD>
<A NAME="IDX93"></A>
A C statement to initialize the target specific fields of fixup <VAR>fixp</VAR>.
These fields are defined with the <CODE>TC_FIX_TYPE</CODE> macro.

<DT><CODE>TC_FIX_DATA_PRINT (<VAR>stream</VAR>, <VAR>fixp</VAR>)</CODE>
<DD>
<A NAME="IDX94"></A>
A C statement to output target specific debugging information for
fixup <VAR>fixp</VAR> to <VAR>stream</VAR>.  This macro is called by <CODE>print_fixup</CODE>.

<DT><CODE>TC_FRAG_INIT (<VAR>fragp</VAR>)</CODE>
<DD>
<A NAME="IDX95"></A>
A C statement to initialize the target specific fields of frag <VAR>fragp</VAR>.
These fields are defined with the <CODE>TC_FRAG_TYPE</CODE> macro.

<DT><CODE>md_number_to_chars</CODE>
<DD>
<A NAME="IDX96"></A>
This should just call either <CODE>number_to_chars_bigendian</CODE> or
<CODE>number_to_chars_littleendian</CODE>, whichever is appropriate.  On targets like
the MIPS which support options to change the endianness, which function to call
is a runtime decision.  On other targets, <CODE>md_number_to_chars</CODE> can be a
simple macro.

<DT><CODE>md_reloc_size</CODE>
<DD>
<A NAME="IDX97"></A>
This variable is only used in the original version of gas (not
<CODE>BFD_ASSEMBLER</CODE> and not <CODE>MANY_SEGMENTS</CODE>).  It holds the size of a
relocation entry.

<DT><CODE>WORKING_DOT_WORD</CODE>
<DD>
<DT><CODE>md_short_jump_size</CODE>
<DD>
<DT><CODE>md_long_jump_size</CODE>
<DD>
<DT><CODE>md_create_short_jump</CODE>
<DD>
<DT><CODE>md_create_long_jump</CODE>
<DD>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
<A NAME="IDX102"></A>
If <CODE>WORKING_DOT_WORD</CODE> is defined, GAS will not do broken word processing
(see section <A HREF="internals.html#SEC18">Broken words</A>).  Otherwise, you should set <CODE>md_short_jump_size</CODE> to
the size of a short jump (a jump that is just long enough to jump around a long
jmp) and <CODE>md_long_jump_size</CODE> to the size of a long jump (a jump that can
go anywhere in the function), You should define <CODE>md_create_short_jump</CODE> to
create a short jump around a long jump, and define <CODE>md_create_long_jump</CODE>
to create a long jump.

<DT><CODE>md_estimate_size_before_relax</CODE>
<DD>
<A NAME="IDX103"></A>
This function returns an estimate of the size of a <CODE>rs_machine_dependent</CODE>
frag before any relaxing is done.  It may also create any necessary
relocations.

<DT><CODE>md_relax_frag</CODE>
<DD>
<A NAME="IDX104"></A>
This macro may be defined to relax a frag.  GAS will call this with the frag
and the change in size of all previous frags; <CODE>md_relax_frag</CODE> should
return the change in size of the frag.  See section <A HREF="internals.html#SEC15">Relaxation</A>.

<DT><CODE>TC_GENERIC_RELAX_TABLE</CODE>
<DD>
<A NAME="IDX105"></A>
If you do not define <CODE>md_relax_frag</CODE>, you may define
<CODE>TC_GENERIC_RELAX_TABLE</CODE> as a table of <CODE>relax_typeS</CODE> structures.  The
machine independent code knows how to use such a table to relax PC relative
references.  See <TT>`tc-m68k.c'</TT> for an example.  See section <A HREF="internals.html#SEC15">Relaxation</A>.

<DT><CODE>md_prepare_relax_scan</CODE>
<DD>
<A NAME="IDX106"></A>
If defined, it is a C statement that is invoked prior to scanning
the relax table.

<DT><CODE>LINKER_RELAXING_SHRINKS_ONLY</CODE>
<DD>
<A NAME="IDX107"></A>
If you define this macro, and the global variable <SAMP>`linkrelax'</SAMP> is set
(because of a command line option, or unconditionally in <CODE>md_begin</CODE>), a
<SAMP>`.align'</SAMP> directive will cause extra space to be allocated.  The linker can
then discard this space when relaxing the section.

<DT><CODE>md_convert_frag</CODE>
<DD>
<A NAME="IDX108"></A>
GAS will call this for each rs_machine_dependent fragment.
The instruction is completed using the data from the relaxation pass.
It may also create any necessary relocations.
See section <A HREF="internals.html#SEC15">Relaxation</A>.

<DT><CODE>md_apply_fix</CODE>
<DD>
<A NAME="IDX109"></A>
GAS will call this for each fixup.  It should store the correct value in the
object file.

<DT><CODE>TC_HANDLES_FX_DONE</CODE>
<DD>
<A NAME="IDX110"></A>
If this macro is defined, it means that <CODE>md_apply_fix</CODE> correctly sets the
<CODE>fx_done</CODE> field in the fixup.

<DT><CODE>tc_gen_reloc</CODE>
<DD>
<A NAME="IDX111"></A>
A <CODE>BFD_ASSEMBLER</CODE> GAS will call this to generate a reloc.  GAS will pass
the resulting reloc to <CODE>bfd_install_relocation</CODE>.  This currently works
poorly, as <CODE>bfd_install_relocation</CODE> often does the wrong thing, and
instances of <CODE>tc_gen_reloc</CODE> have been written to work around the problems,
which in turns makes it difficult to fix <CODE>bfd_install_relocation</CODE>.

<DT><CODE>RELOC_EXPANSION_POSSIBLE</CODE>
<DD>
<A NAME="IDX112"></A>
If you define this macro, it means that <CODE>tc_gen_reloc</CODE> may return multiple
relocation entries for a single fixup.  In this case, the return value of
<CODE>tc_gen_reloc</CODE> is a pointer to a null terminated array.

<DT><CODE>MAX_RELOC_EXPANSION</CODE>
<DD>
<A NAME="IDX113"></A>
You must define this if <CODE>RELOC_EXPANSION_POSSIBLE</CODE> is defined; it
indicates the largest number of relocs which <CODE>tc_gen_reloc</CODE> may return for
a single fixup.

<DT><CODE>tc_fix_adjustable</CODE>
<DD>
<A NAME="IDX114"></A>
You may define this macro to indicate whether a fixup against a locally defined
symbol should be adjusted to be against the section symbol.  It should return a
non-zero value if the adjustment is acceptable.

<DT><CODE>MD_PCREL_FROM_SECTION</CODE>
<DD>
<A NAME="IDX115"></A>
If you define this macro, it should return the offset between the address of a
PC relative fixup and the position from which the PC relative adjustment should
be made.  On many processors, the base of a PC relative instruction is the next
instruction, so this macro would return the length of an instruction.

<DT><CODE>md_pcrel_from</CODE>
<DD>
<A NAME="IDX116"></A>
This is the default value of <CODE>MD_PCREL_FROM_SECTION</CODE>.  The difference is
that <CODE>md_pcrel_from</CODE> does not take a section argument.

<DT><CODE>tc_frob_label</CODE>
<DD>
<A NAME="IDX117"></A>
If you define this macro, GAS will call it each time a label is defined.

<DT><CODE>md_section_align</CODE>
<DD>
<A NAME="IDX118"></A>
GAS will call this function for each section at the end of the assembly, to
permit the CPU backend to adjust the alignment of a section.

<DT><CODE>tc_frob_section</CODE>
<DD>
<A NAME="IDX119"></A>
If you define this macro, a <CODE>BFD_ASSEMBLER</CODE> GAS will call it for each
section at the end of the assembly.

<DT><CODE>tc_frob_file_before_adjust</CODE>
<DD>
<A NAME="IDX120"></A>
If you define this macro, GAS will call it after the symbol values are
resolved, but before the fixups have been changed from local symbols to section
symbols.

<DT><CODE>tc_frob_symbol</CODE>
<DD>
<A NAME="IDX121"></A>
If you define this macro, GAS will call it for each symbol.  You can indicate
that the symbol should not be included in the object file by definining this
macro to set its second argument to a non-zero value.

<DT><CODE>tc_frob_file</CODE>
<DD>
<A NAME="IDX122"></A>
If you define this macro, GAS will call it after the symbol table has been
completed, but before the relocations have been generated.

<DT><CODE>tc_frob_file_after_relocs</CODE>
<DD>
If you define this macro, GAS will call it after the relocs have been
generated.

<DT><CODE>LISTING_HEADER</CODE>
<DD>
A string to use on the header line of a listing.  The default value is simply
<CODE>"GAS LISTING"</CODE>.

<DT><CODE>LISTING_WORD_SIZE</CODE>
<DD>
The number of bytes to put into a word in a listing.  This affects the way the
bytes are clumped together in the listing.  For example, a value of 2 might
print <SAMP>`1234 5678'</SAMP> where a value of 1 would print <SAMP>`12 34 56 78'</SAMP>.  The
default value is 4.

<DT><CODE>LISTING_LHS_WIDTH</CODE>
<DD>
The number of words of data to print on the first line of a listing for a
particular source line, where each word is <CODE>LISTING_WORD_SIZE</CODE> bytes.  The
default value is 1.

<DT><CODE>LISTING_LHS_WIDTH_SECOND</CODE>
<DD>
Like <CODE>LISTING_LHS_WIDTH</CODE>, but applying to the second and subsequent line
of the data printed for a particular source line.  The default value is 1.

<DT><CODE>LISTING_LHS_CONT_LINES</CODE>
<DD>
The maximum number of continuation lines to print in a listing for a particular
source line.  The default value is 4.

<DT><CODE>LISTING_RHS_WIDTH</CODE>
<DD>
The maximum number of characters to print from one line of the input file.  The
default value is 100.
</DL>



<H3><A NAME="SEC13" HREF="internals_toc.html#TOC13">Writing an object format backend</A></H3>
<P>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>

</P>
<P>
As with the CPU backend, the object format backend must define a few things,
and may define some other things.  The interface to the object format backend
is generally simpler; most of the support for an object file format consists of
defining a number of pseudo-ops.

</P>
<P>
The object format <TT>`.h'</TT> file must include <TT>`targ-cpu.h'</TT>.

</P>
<P>
This section will only define the <CODE>BFD_ASSEMBLER</CODE> version of GAS.  It is
impossible to support a new object file format using any other version anyhow,
as the original GAS version only supports a.out, and the <CODE>MANY_SEGMENTS</CODE>
GAS version only supports COFF.

</P>
<DL COMPACT>

<DT><CODE>OBJ_<VAR>format</VAR></CODE>
<DD>
<A NAME="IDX125"></A>
By convention, you should define this macro in the <TT>`.h'</TT> file.  For
example, <TT>`obj-elf.h'</TT> defines <CODE>OBJ_ELF</CODE>.  You might have to use this
if it is necessary to add object file format specific code to the CPU file.

<DT><CODE>obj_begin</CODE>
<DD>
If you define this macro, GAS will call it at the start of the assembly, after
the command line arguments have been parsed and all the machine independent
initializations have been completed.

<DT><CODE>obj_app_file</CODE>
<DD>
<A NAME="IDX126"></A>
If you define this macro, GAS will invoke it when it sees a <CODE>.file</CODE>
pseudo-op or a <SAMP>`#'</SAMP> line as used by the C preprocessor.

<DT><CODE>OBJ_COPY_SYMBOL_ATTRIBUTES</CODE>
<DD>
<A NAME="IDX127"></A>
You should define this macro to copy object format specific information from
one symbol to another.  GAS will call it when one symbol is equated to
another.

<DT><CODE>obj_fix_adjustable</CODE>
<DD>
<A NAME="IDX128"></A>
You may define this macro to indicate whether a fixup against a locally defined
symbol should be adjusted to be against the section symbol.  It should return a
non-zero value if the adjustment is acceptable.

<DT><CODE>obj_sec_sym_ok_for_reloc</CODE>
<DD>
<A NAME="IDX129"></A>
You may define this macro to indicate that it is OK to use a section symbol in
a relocateion entry.  If it is not, GAS will define a new symbol at the start
of a section.

<DT><CODE>EMIT_SECTION_SYMBOLS</CODE>
<DD>
<A NAME="IDX130"></A>
You should define this macro with a zero value if you do not want to include
section symbols in the output symbol table.  The default value for this macro
is one.

<DT><CODE>obj_adjust_symtab</CODE>
<DD>
<A NAME="IDX131"></A>
If you define this macro, GAS will invoke it just before setting the symbol
table of the output BFD.  For example, the COFF support uses this macro to
generate a <CODE>.file</CODE> symbol if none was generated previously.

<DT><CODE>SEPARATE_STAB_SECTIONS</CODE>
<DD>
<A NAME="IDX132"></A>
You may define this macro to indicate that stabs should be placed in separate
sections, as in ELF.

<DT><CODE>INIT_STAB_SECTION</CODE>
<DD>
<A NAME="IDX133"></A>
You may define this macro to initialize the stabs section in the output file.

<DT><CODE>OBJ_PROCESS_STAB</CODE>
<DD>
<A NAME="IDX134"></A>
You may define this macro to do specific processing on a stabs entry.

<DT><CODE>obj_frob_section</CODE>
<DD>
<A NAME="IDX135"></A>
If you define this macro, GAS will call it for each section at the end of the
assembly.

<DT><CODE>obj_frob_file_before_adjust</CODE>
<DD>
<A NAME="IDX136"></A>
If you define this macro, GAS will call it after the symbol values are
resolved, but before the fixups have been changed from local symbols to section
symbols.

<DT><CODE>obj_frob_symbol</CODE>
<DD>
<A NAME="IDX137"></A>
If you define this macro, GAS will call it for each symbol.  You can indicate
that the symbol should not be included in the object file by definining this
macro to set its second argument to a non-zero value.

<DT><CODE>obj_frob_file</CODE>
<DD>
<A NAME="IDX138"></A>
If you define this macro, GAS will call it after the symbol table has been
completed, but before the relocations have been generated.

<DT><CODE>obj_frob_file_after_relocs</CODE>
<DD>
If you define this macro, GAS will call it after the relocs have been
generated.
</DL>



<H3><A NAME="SEC14" HREF="internals_toc.html#TOC14">Writing emulation files</A></H3>

<P>
Normally you do not have to write an emulation file.  You can just use
<TT>`te-generic.h'</TT>.

</P>
<P>
If you do write your own emulation file, it must include <TT>`obj-format.h'</TT>.

</P>
<P>
An emulation file will often define <CODE>TE_<VAR>EM</VAR></CODE>; this may then be used
in other files to change the output.

</P>


<H2><A NAME="SEC15" HREF="internals_toc.html#TOC15">Relaxation</A></H2>
<P>
<A NAME="IDX139"></A>

</P>
<P>
<STRONG>Relaxation</STRONG> is a generic term used when the size of some instruction or
data depends upon the value of some symbol or other data.

</P>
<P>
GAS knows to relax a particular type of PC relative relocation using a table.
You can also define arbitrarily complex forms of relaxation yourself.

</P>



<H3><A NAME="SEC16" HREF="internals_toc.html#TOC16">Relaxing with a table</A></H3>

<P>
If you do not define <CODE>md_relax_frag</CODE>, and you do define
<CODE>TC_GENERIC_RELAX_TABLE</CODE>, GAS will relax <CODE>rs_machine_dependent</CODE> frags
based on the frag subtype and the displacement to some specified target
address.  The basic idea is that several machines have different addressing
modes for instructions that can specify different ranges of values, with
successive modes able to access wider ranges, including the entirety of the
previous range.  Smaller ranges are assumed to be more desirable (perhaps the
instruction requires one word instead of two or three); if this is not the
case, don't describe the smaller-range, inferior mode.

</P>
<P>
The <CODE>fr_subtype</CODE> field of a frag is an index into a CPU-specific
relaxation table.  That table entry indicates the range of values that can be
stored, the number of bytes that will have to be added to the frag to
accomodate the addressing mode, and the index of the next entry to examine if
the value to be stored is outside the range accessible by the current
addressing mode.  The <CODE>fr_symbol</CODE> field of the frag indicates what symbol
is to be accessed; the <CODE>fr_offset</CODE> field is added in.

</P>
<P>
If the <CODE>TC_PCREL_ADJUST</CODE> macro is defined, which currently should only happen
for the NS32k family, the <CODE>TC_PCREL_ADJUST</CODE> macro is called on the frag to
compute an adjustment to be made to the displacement.

</P>
<P>
The value fitted by the relaxation code is always assumed to be a displacement
from the current frag.  (More specifically, from <CODE>fr_fix</CODE> bytes into the
frag.)

</P>
<P>
The end of the relaxation sequence is indicated by a "next" value of 0.  This
means that the first entry in the table can't be used.

</P>
<P>
For some configurations, the linker can do relaxing within a section of an
object file.  If call instructions of various sizes exist, the linker can
determine which should be used in each instance, when a symbol's value is
resolved.  In order for the linker to avoid wasting space and having to insert
no-op instructions, it must be able to expand or shrink the section contents
while still preserving intra-section references and meeting alignment
requirements.

</P>
<P>
For the i960 using b.out format, no expansion is done; instead, each
<SAMP>`.align'</SAMP> directive causes extra space to be allocated, enough that when
the linker is relaxing a section and removing unneeded space, it can discard
some or all of this extra padding and cause the following data to be correctly
aligned.

</P>
<P>
For the H8/300, I think the linker expands calls that can't reach, and doesn't
worry about alignment issues; the cpu probably never needs any significant
alignment beyond the instruction size.

</P>
<P>
The relaxation table type contains these fields:

</P>
<DL COMPACT>

<DT><CODE>long rlx_forward</CODE>
<DD>
Forward reach, must be non-negative.
<DT><CODE>long rlx_backward</CODE>
<DD>
Backward reach, must be zero or negative.
<DT><CODE>rlx_length</CODE>
<DD>
Length in bytes of this addressing mode.
<DT><CODE>rlx_more</CODE>
<DD>
Index of the next-longer relax state, or zero if there is no next relax state.
</DL>

<P>
The relaxation is done in <CODE>relax_segment</CODE> in <TT>`write.c'</TT>.  The
difference in the length fields between the original mode and the one finally
chosen by the relaxing code is taken as the size by which the current frag will
be increased in size.  For example, if the initial relaxing mode has a length
of 2 bytes, and because of the size of the displacement, it gets upgraded to a
mode with a size of 6 bytes, it is assumed that the frag will grow by 4 bytes.
(The initial two bytes should have been part of the fixed portion of the frag,
since it is already known that they will be output.)  This growth must be
effected by <CODE>md_convert_frag</CODE>; it should increase the <CODE>fr_fix</CODE> field
by the appropriate size, and fill in the appropriate bytes of the frag.
(Enough space for the maximum growth should have been allocated in the call to
frag_var as the second argument.)

</P>
<P>
If relocation records are needed, they should be emitted by
<CODE>md_estimate_size_before_relax</CODE>.  This function should examine the target
symbol of the supplied frag and correct the <CODE>fr_subtype</CODE> of the frag if
needed.  When this function is called, if the symbol has not yet been defined,
it will not become defined later; however, its value may still change if the
section it is in gets relaxed.

</P>
<P>
Usually, if the symbol is in the same section as the frag (given by the
<VAR>sec</VAR> argument), the narrowest likely relaxation mode is stored in
<CODE>fr_subtype</CODE>, and that's that.

</P>
<P>
If the symbol is undefined, or in a different section (and therefore moveable
to an arbitrarily large distance), the largest available relaxation mode is
specified, <CODE>fix_new</CODE> is called to produce the relocation record,
<CODE>fr_fix</CODE> is increased to include the relocated field (remember, this
storage was allocated when <CODE>frag_var</CODE> was called), and <CODE>frag_wane</CODE> is
called to convert the frag to an <CODE>rs_fill</CODE> frag with no variant part.
Sometimes changing addressing modes may also require rewriting the instruction.
It can be accessed via <CODE>fr_opcode</CODE> or <CODE>fr_fix</CODE>.

</P>
<P>
Sometimes <CODE>fr_var</CODE> is increased instead, and <CODE>frag_wane</CODE> is not
called.  I'm not sure, but I think this is to keep <CODE>fr_fix</CODE> referring to
an earlier byte, and <CODE>fr_subtype</CODE> set to <CODE>rs_machine_dependent</CODE> so
that <CODE>md_convert_frag</CODE> will get called.

</P>


<H3><A NAME="SEC17" HREF="internals_toc.html#TOC17">General relaxing</A></H3>

<P>
If using a simple table is not suitable, you may implement arbitrarily complex
relaxation semantics yourself.  For example, the MIPS backend uses this to emit
different instruction sequences depending upon the size of the symbol being
accessed.

</P>
<P>
When you assemble an instruction that may need relaxation, you should allocate
a frag using <CODE>frag_var</CODE> or <CODE>frag_variant</CODE> with a type of
<CODE>rs_machine_dependent</CODE>.  You should store some sort of information in the
<CODE>fr_subtype</CODE> field so that you can figure out what to do with the frag
later.

</P>
<P>
When GAS reaches the end of the input file, it will look through the frags and
work out their final sizes.

</P>
<P>
GAS will first call <CODE>md_estimate_size_before_relax</CODE> on each
<CODE>rs_machine_dependent</CODE> frag.  This function must return an estimated size
for the frag.

</P>
<P>
GAS will then loop over the frags, calling <CODE>md_relax_frag</CODE> on each
<CODE>rs_machine_dependent</CODE> frag.  This function should return the change in
size of the frag.  GAS will keep looping over the frags until none of the frags
changes size.

</P>


<H2><A NAME="SEC18" HREF="internals_toc.html#TOC18">Broken words</A></H2>
<P>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>

</P>
<P>
Some compilers, including GCC, will sometimes emit switch tables specifying
16-bit <CODE>.word</CODE> displacements to branch targets, and branch instructions
that load entries from that table to compute the target address.  If this is
done on a 32-bit machine, there is a chance (at least with really large
functions) that the displacement will not fit in 16 bits.  The assembler
handles this using a concept called <STRONG>broken words</STRONG>.  This idea is well
named, since there is an implied promise that the 16-bit field will in fact
hold the specified displacement.

</P>
<P>
If broken word processing is enabled, and a situation like this is encountered,
the assembler will insert a jump instruction into the instruction stream, close
enough to be reached with the 16-bit displacement.  This jump instruction will
transfer to the real desired target address.  Thus, as long as the <CODE>.word</CODE>
value really is used as a displacement to compute an address to jump to, the
net effect will be correct (minus a very small efficiency cost).  If
<CODE>.word</CODE> directives with label differences for values are used for other
purposes, however, things may not work properly.  For targets which use broken
words, the <SAMP>`-K'</SAMP> option will warn when a broken word is discovered.

</P>
<P>
The broken word code is turned off by the <CODE>WORKING_DOT_WORD</CODE> macro.  It
isn't needed if <CODE>.word</CODE> emits a value large enough to contain an address
(or, more correctly, any possible difference between two addresses).

</P>


<H2><A NAME="SEC19" HREF="internals_toc.html#TOC19">Internal functions</A></H2>

<P>
This section describes basic internal functions used by GAS.

</P>



<H3><A NAME="SEC20" HREF="internals_toc.html#TOC20">Warning and error messages</A></H3>

<P>
<DL>
<DT><U>Function:</U> {} <B>int</B> <I>had_warnings (void)</I>
<DD><A NAME="IDX142"></A>
<DT><U>Function:</U> {} <B>int</B> <I>had_errors (void)</I>
<DD><A NAME="IDX143"></A>
Returns non-zero if any warnings or errors, respectively, have been printed
during this invocation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>void</B> <I>as_perror (const char *<VAR>gripe</VAR>, const char *<VAR>filename</VAR>)</I>
<DD><A NAME="IDX144"></A>
Displays a BFD or system error, then clears the error status.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>void</B> <I>as_tsktsk (const char *<VAR>format</VAR>, ...)</I>
<DD><A NAME="IDX145"></A>
<DT><U>Function:</U> {} <B>void</B> <I>as_warn (const char *<VAR>format</VAR>, ...)</I>
<DD><A NAME="IDX146"></A>
<DT><U>Function:</U> {} <B>void</B> <I>as_bad (const char *<VAR>format</VAR>, ...)</I>
<DD><A NAME="IDX147"></A>
<DT><U>Function:</U> {} <B>void</B> <I>as_fatal (const char *<VAR>format</VAR>, ...)</I>
<DD><A NAME="IDX148"></A>
These functions display messages about something amiss with the input file, or
internal problems in the assembler itself.  The current file name and line
number are printed, followed by the supplied message, formatted using
<CODE>vfprintf</CODE>, and a final newline.

</P>
<P>
An error indicated by <CODE>as_bad</CODE> will result in a non-zero exit status when
the assembler has finished.  Calling <CODE>as_fatal</CODE> will result in immediate
termination of the assembler process.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>void</B> <I>as_warn_where (char *<VAR>file</VAR>, unsigned int <VAR>line</VAR>, const char *<VAR>format</VAR>, ...)</I>
<DD><A NAME="IDX149"></A>
<DT><U>Function:</U> {} <B>void</B> <I>as_bad_where (char *<VAR>file</VAR>, unsigned int <VAR>line</VAR>, const char *<VAR>format</VAR>, ...)</I>
<DD><A NAME="IDX150"></A>
These variants permit specification of the file name and line number, and are
used when problems are detected when reprocessing information saved away when
processing some earlier part of the file.  For example, fixups are processed
after all input has been read, but messages about fixups should refer to the
original filename and line number that they are applicable to.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>void</B> <I>fprint_value (FILE *<VAR>file</VAR>, valueT <VAR>val</VAR>)</I>
<DD><A NAME="IDX151"></A>
<DT><U>Function:</U> {} <B>void</B> <I>sprint_value (char *<VAR>buf</VAR>, valueT <VAR>val</VAR>)</I>
<DD><A NAME="IDX152"></A>
These functions are helpful for converting a <CODE>valueT</CODE> value into printable
format, in case it's wider than modes that <CODE>*printf</CODE> can handle.  If the
type is narrow enough, a decimal number will be produced; otherwise, it will be
in hexadecimal.  The value itself is not examined to make this determination.
</DL>

</P>


<H3><A NAME="SEC21" HREF="internals_toc.html#TOC21">Hash tables</A></H3>
<P>
<A NAME="IDX153"></A>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>{struct hash_control *}</B> <I>hash_new (void)</I>
<DD><A NAME="IDX154"></A>
Creates the hash table control structure.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>void</B> <I>hash_die (struct hash_control *)</I>
<DD><A NAME="IDX155"></A>
Destroy a hash table.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>PTR</B> <I>hash_delete (struct hash_control *, const char *)</I>
<DD><A NAME="IDX156"></A>
Deletes entry from the hash table, returns the value it had.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>PTR</B> <I>hash_replace (struct hash_control *, const char *, PTR)</I>
<DD><A NAME="IDX157"></A>
Updates the value for an entry already in the table, returning the old value.
If no entry was found, just returns NULL.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>{const char *}</B> <I>hash_insert (struct hash_control *, const char *, PTR)</I>
<DD><A NAME="IDX158"></A>
Inserting a value already in the table is an error.
Returns an error message or NULL.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> {} <B>{const char *}</B> <I>hash_jam (struct hash_control *, const char *, PTR)</I>
<DD><A NAME="IDX159"></A>
Inserts if the value isn't already present, updates it if it is.
</DL>

</P>


<H2><A NAME="SEC22" HREF="internals_toc.html#TOC22">Test suite</A></H2>
<P>
<A NAME="IDX160"></A>

</P>
<P>
The test suite is kind of lame for most processors.  Often it only checks to
see if a couple of files can be assembled without the assembler reporting any
errors.  For more complete testing, write a test which either examines the
assembler listing, or runs <CODE>objdump</CODE> and examines its output.  For the
latter, the TCL procedure <CODE>run_dump_test</CODE> may come in handy.  It takes the
base name of a file, and looks for <TT>`<VAR>file</VAR>.d'</TT>.  This file should
contain as its initial lines a set of variable settings in <SAMP>`#'</SAMP> comments,
in the form:

</P>

<PRE>
        #<VAR>varname</VAR>: <VAR>value</VAR>
</PRE>

<P>
The <VAR>varname</VAR> may be <CODE>objdump</CODE>, <CODE>nm</CODE>, or <CODE>as</CODE>, in which case
it specifies the options to be passed to the specified programs.  Exactly one
of <CODE>objdump</CODE> or <CODE>nm</CODE> must be specified, as that also specifies which
program to run after the assembler has finished.  If <VAR>varname</VAR> is
<CODE>source</CODE>, it specifies the name of the source file; otherwise,
<TT>`<VAR>file</VAR>.s'</TT> is used.  If <VAR>varname</VAR> is <CODE>name</CODE>, it specifies the
name of the test to be used in the <CODE>pass</CODE> or <CODE>fail</CODE> messages.

</P>
<P>
The non-commented parts of the file are interpreted as regular expressions, one
per line.  Blank lines in the <CODE>objdump</CODE> or <CODE>nm</CODE> output are skipped,
as are blank lines in the <CODE>.d</CODE> file; the other lines are tested to see if
the regular expression matches the program output.  If it does not, the test
fails.

</P>
<P>
Note that this means the tests must be modified if the <CODE>objdump</CODE> output
style is changed.

</P>
<P><HR><P>
This document was generated on 22 June 2001 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
