#
# Provide U-Boot-style functions in gdb
#

define md
	if $argc == 2
		x/64x$arg0 $arg1
	else
		if $argc == 3
			x/$arg2x$arg0 $arg1
		else
			help md
		end
	end
end
document md
Usage: md <unit type> <address> [count=64]
Display [count] <unit type> starting at <address>.
end

define _md
	# dummy func for "document" to work
end
document _md
Usage: md[cbwl] <address> [count=64]
Display [count] <chars|bytes|words|longs> starting at <address>.
end

define mdb
	if $argc == 1
		md b $arg0
	else
		if $argc == 2
			md b $arg0 $arg1
		else
			help _md
		end
	end
end
document mdb
Use 'help _md'
end
define mdw
	if $argc == 1
		md h $arg0
	else
		if $argc == 2
			md h $arg0 $arg1
		else
			help _md
		end
	end
end
document mdw
Use 'help _md'
end
define mdl
	if $argc == 1
		md w $arg0
	else
		if $argc == 2
			md w $arg0 $arg1
		else
			help _md
		end
	end
end
document mdl
Use 'help _md'
end
define mdc
	if $argc == 1
		md c $arg0
	else
		if $argc == 2
			md c $arg0 $arg1
		else
			help _md
		end
	end
end
document mdc
Use 'help _md'
end


#
# U-Boot style memory modify functions
#

define _mw
	set $$addr  = $arg0
	set $$val   = $arg1
	set $$count = $arg2
	while $$count-- > 0
		set *$$addr = $$val
		set $$addr += 1
	end
	dont-repeat
end
document _mw
Usage: mw[bwl] <address> <value> <count>
Set <count> <bytes|words|longs> at <address> to <value>.
end

define mwl
	if $argc == 3
		set $$addr = (unsigned long *)$arg0
		_mw $$addr $arg1 $arg2
	else
		help _mw
	end
end
document mwl
Use 'help _mw'
end
define mww
	if $argc == 3
		set $$addr = (unsigned short *)$arg0
		_mw $$addr $arg1 $arg2
	else
		help _mw
	end
end
document mww
Use 'help _mw'
end
define mwb
	if $argc == 3
		set $$addr = (unsigned char *)$arg0
		_mw $$addr $arg1 $arg2
	else
		help _mw
	end
end
document mwb
Use 'help _mw'
end

define uboot_jtag_load
	set remotetimeout 300
	load init.elf
	continue
	load u-boot
	call memset(&_bss_start, 0, &_bss_end - &_bss_start)
	continue
end
