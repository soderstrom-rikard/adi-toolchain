#
# Misc Blackfin helper functions
#

define regs
	printf "R0: %08x %-11i  P0: %08x  RETS: %08x  LC0: %08x %u\n",  $r0, $r0, $p0, $rets, $lc0, $lc0
	printf "R1: %08x %-11i  P1: %08x  RETI: %08x  LT0: %08x\n",     $r1, $r1, $p1, $reti, $lt0
	printf "R2: %08x %-11i  P2: %08x  RETX: %08x  LB0: %08x\n",     $r2, $r2, $p2, $retx, $lb0
	printf "R3: %08x %-11i  P3: %08x  RETE: %08x  LC1: %08x %u\n",  $r3, $r3, $p3, $rete, $lc1, $lc1
	printf "R4: %08x %-11i  P4: %08x  RETN: %08x  LT1: %08x\n",     $r4, $r4, $p4, $retn, $lt1
	printf "R5: %08x %-11i  P5: %08x ASTAT: %08x  LB1: %08x\n",     $r5, $r5, $p5, $astat, $lb1
	printf "R6: %08x %-11i  SP: %08x    CC: %08x\n",                $r6, $r6, $sp, $cc
	printf "R7: %08x %-11i USP: %08x  CYC1: %08x  SEQSTAT: %08x\n", $r7, $r7, $usp, $cycles, $seqstat
	printf "PC: %08x              FP: %08x  CYC2: %08x   SYSCFG: %08x\n", $pc, $fp, $cycles2, $syscfg
end
document regs
Usage: regs
Display the common core registers in a compact format.
end

define seqstat
	if $argc == 1
		set $$seqstat = $arg0
	else
		set $$seqstat = $seqstat
	end
	set $$excause    = ($$seqstat & 0x3f)
	set $$sftreset   = ($$seqstat & (0x1 << 13)) >> 13
	set $$hwerrcause = ($$seqstat & (0x1f << 14)) >> 14
	printf "SEQSTAT: %08x\n", $$seqstat
	printf " EXCAUSE:    0x%x\t", $$excause
	if $$excause >= 0x0 && $$excause <= 0xf
		printf "(custom exception)"
	end
	if $$excause == 0x10
		printf "(single step)"
	end
	if $$excause == 0x11
		printf "(trace buffer full)"
	end
	if $$excause == 0x21
		printf "(undef inst)"
	end
	if $$excause == 0x22
		printf "(illegal inst)"
	end
	if $$excause == 0x23
		printf "(dcplb prot violation)"
	end
	if $$excause == 0x24
		printf "(misaligned data)"
	end
	if $$excause == 0x25
		printf "(unrecoverable event)"
	end
	if $$excause == 0x26
		printf "(dcplb miss)"
	end
	if $$excause == 0x27
		printf "(multiple dcplb hit)"
	end
	if $$excause == 0x28
		printf "(emulation watchpoint)"
	end
	if $$excause == 0x2a
		printf "(misaligned inst)"
	end
	if $$excause == 0x2b
		printf "(icplb prot violation)"
	end
	if $$excause == 0x2c
		printf "(icplb miss)"
	end
	if $$excause == 0x2d
		printf "(multiple icplb hit)"
	end
	if $$excause == 0x2e
		printf "(illegal use of supervisor resource)"
	end
	printf "\n"
	printf " SFTRESET:   0x%x\t(last reset was ", $$sftreset
	if $$sftreset == 0
		printf "not "
	end
	printf "a software reset)\n"
	printf " HWERRCAUSE: 0x%x\t", $$hwerrcause
	if $$hwerrcause == 0x2
		printf "(system mmr error)"
	end
	if $$hwerrcause == 0x3
		printf "(external memory addressing error)"
	end
	if $$hwerrcause == 0x12
		printf "(performance monitor overflow)"
	end
	if $$hwerrcause == 0x18
		printf "(raise 5 instruction)"
	end
	printf "\n"
end
document seqstat
Usage: seqstat [value=$seqstat]
Parse the bits of the seqstat [value] into the human readable definitions.
end

define reset
	if $argc == 0
		set $$l1 = 0xffa00000
	else
		set $$l1 = $arg0
	end
	set $$pc = $$l1

	# SSYNC
	set *(unsigned short *)($$l1) = 0x0024
	set $$l1 += 2

	#  P2.H = 0xffc0
	set *(unsigned long  *)($$l1) = 0xffc0e14a
	set $$l1 += 4

	# P2.L = 0x100
	set *(unsigned long  *)($$l1) = 0x0100e10a
	set $$l1 += 4

	# R0 = 0x7 (X)
	set *(unsigned short *)($$l1) = 0x6038
	set $$l1 += 2

	# [P2] = R0
	set *(unsigned short *)($$l1) = 0x9310
	set $$l1 += 2

	# SSYNC
	set *(unsigned short *)($$l1) = 0x0024
	set $$l1 += 2

	# R0 = 0x0 (X)
	set *(unsigned short *)($$l1) = 0x6000
	set $$l1 += 2

	# [P2] = R0
	set *(unsigned short *)($$l1) = 0x9310
	set $$l1 += 2

	# SSYNC
	set *(unsigned short *)($$l1) = 0x0024
	set $$l1 += 2

	# RAISE 0x1
	set *(unsigned short *)($$l1) = 0x0091
	set $$l1 += 2

	# JUMP.S -0x18
	if ($$l1 - $$pc) != 0x18
		echo ERROR: jump.s has wrong offset
	else
		set $pc == $$pc
	end
	set *(unsigned short *)($$l1) = 0x2ff4
	set $$l1 += 2

	printf "Continuing.\n"
	continue
end
document reset
Usage: reset [L1 Instruction address=0xffa00000]
Cram the software reset code into [L1 Instruction address] and execute it.
This will perform both a system reset and a core reset.
end

define hwtrace_on
	set $$TBUFCTL  = (unsigned long *)0xFFE06000
	set *$$TBUFCTL = 0x3
end
define hwtrace
	set $$TBUFSTAT = (unsigned long *)0xFFE06004
	set $$TBUF = (unsigned long *)0xFFE06100
	set $$i = 0
	if (!(*$$TBUFSTAT & 0x1F))
		printf "Hardware trace buffer is empty\n"
	end
	while (*$$TBUFSTAT & 0x1F)
		printf "%2i Target: ", $$i
		output/a *$$TBUF
		printf "\n"
		printf "   Source: "
		output/a *$$TBUF
		printf "\n"
		set $$i++
	end
end
document hwtrace
Usage: hwtrace
Dump the hardware trace buffer.  Remember, this is a destructive operation,
so it can only be dumped once.
end

define show_clocks
	printf "PLL_LOCKCNT: 0x%04x\n", *(unsigned short *)0xFFC00010
	printf "VR_CTL:      0x%04x\n", *(unsigned short *)0xFFC00008
	printf "PLL_DIV:     0x%04x\n", *(unsigned short *)0xFFC00004
	printf "PLL_CTL:     0x%04x\n", *(unsigned short *)0xFFC00000
end

define show_sdram
	printf "SDRRC:  0x%04x\n", *(unsigned short *)0xFFC00A18

	set $$SDBCTL = *(unsigned short *)0xFFC00A14
	set $$EBCAW = ($$SDBCTL & 0x30) >> 4
	set $$EBSZ = ($$SDBCTL & 0xe) >> 1
	printf "SDBCTL: 0x%04x ", $$SDBCTL
	if ($$SDBCTL & 0x1)
		printf "(enabled) "
	else
		printf "(disabled) "
	end
	if $$EBCAW == 0x0
		printf "(8-bit) "
	end
	if $$EBCAW == 0x1
		printf "(9-bit) "
	end
	if $$EBCAW == 0x2
		printf "(10-bit) "
	end
	if $$EBCAW == 0x3
		printf "(11-bit) "
	end
	if $$EBSZ == 0x0
		printf "(16MB)"
	end
	if $$EBSZ == 0x1
		printf "(32MB)"
	end
	if $$EBSZ == 0x2
		printf "(64MB)"
	end
	if $$EBSZ == 0x3
		printf "(128MB)"
	end
	if $$EBSZ == 0x4
		printf "(256MB)"
	end
	if $$EBSZ == 0x5
		printf "(512MB)"
	end
	printf "\n"

	printf "SDSTAT: 0x%04x\n", *(unsigned short *)0xFFC00A1C
	printf "SDGCTL: 0x%08x\n", *(unsigned long  *)0xFFC00A10
end

define show_ddr
	printf "DDRCTL0: 0x%08x\n", *(unsigned long *)0xFFC00A20
	printf "DDRCTL1: 0x%08x\n", *(unsigned long *)0xFFC00A24
	printf "DDRCTL2: 0x%08x\n", *(unsigned long *)0xFFC00A28
	printf "DDRCTL3: 0x%08x\n", *(unsigned long *)0xFFC00A2C
	printf "DDRQUE:  0x%08x\n", *(unsigned long *)0xFFC00A30
	printf "ERRADD:  0x%08x\n", *(unsigned long *)0xFFC00A34
	printf "ERRMST:  0x%04x\n", *(unsigned short *)0xFFC00A38
	printf "RSTCTL:  0x%04x\n", *(unsigned short *)0xFFC00A3C
end

define show_ebiu
	printf "EBIU_AMGCTL:  0x%04x\n", *(unsigned short *)0xFFC00A00
	printf "EBIU_AMBCTL0: 0x%08x\n", *(unsigned long *)0xFFC00A04
	printf "EBIU_AMBCTL1: 0x%08x\n", *(unsigned long *)0xFFC00A08
	printf "EBIU_MBSCTL:  0x%08x\n", *(unsigned long *)0xFFC00A0C
	printf "EBIU_MODE:    0x%08x\n", *(unsigned long *)0xFFC00A14
	printf "EBIU_FCTL:    0x%08x\n", *(unsigned long *)0xFFC00A18
end

define _show_cec
	set $$cec = *(unsigned long *)$arg0
	printf "0x%08x: ", $$cec
	if ($$cec & (1 << 0))
		printf "EMU "
	else
		printf "    "
	end
	if ($$cec & (1 << 1))
		printf "RST "
	else
		printf "    "
	end
	if ($$cec & (1 << 2))
		printf "NMI "
	else
		printf "    "
	end
	if ($$cec & (1 << 3))
		printf "EVX "
	else
		printf "    "
	end
	if ($$cec & (1 << 4))
		printf "GBL "
	else
		printf "    "
	end
	if ($$cec & (1 << 5))
		printf "HW "
	else
		printf "   "
	end
	if ($$cec & (1 << 6))
		printf "TMR "
	else
		printf "    "
	end
	set $$ceci = 7
	while ($$ceci < 16)
		if ($$cec & (1 << $$ceci))
			printf "G%i ", $$ceci
		else
			printf "   "
			if ($$ceci > 9)
				printf " "
			end
		end
		set $$ceci = $$ceci + 1
	end
	printf "\n"
end
define show_cec
	printf "IMASK: "
	_show_cec 0xFFE02104
	printf "IPEND: "
	_show_cec 0xFFE02108
	printf "ILAT:  "
	_show_cec 0xFFE0210C

	set $$EVT = 0xFFE02000
	set $$EVTi = 0
	while ($$EVTi < 16)
		printf "EVT%-2i ", $$EVTi
		output/a *(unsigned long *)($$EVT + $$EVTi * 4)
		printf "\n"
		set $$EVTi = $$EVTi + 1
	end
end

define _show_cplbs
	set $$addr = $arg0
	set $$data = $arg1
	set $$i = 0
	while ($$i < 16)
		set $$data_val = *(unsigned long *)($$data + $$i * 4)
		printf " 0x%08x 0x%08x ( ", *(unsigned long *)($$addr + $$i * 4), $$data_val
		if (($$data_val & (0x3 << 16)) == (0x0 << 16))
			printf "1K "
		end
		if (($$data_val & (0x3 << 16)) == (0x1 << 16))
			printf "4K "
		end
		if (($$data_val & (0x3 << 16)) == (0x2 << 16))
			printf "1M "
		end
		if (($$data_val & (0x3 << 16)) == (0x3 << 16))
			printf "4M "
		end
		if ($$data_val & (0x1 << 14))
			printf "wt "
		else
			printf "wb "
		end
		if ($$data_val & (0x1 << 7))
			printf "dirty "
		end
		if ($$data_val & (0x1 << 4))
			printf "supv-wr "
		end
		if ($$data_val & (0x1 << 3))
			printf "user-wr "
		end
		if ($$data_val & (0x1 << 2))
			printf "user-rd "
		end
		if ($$data_val & (0x1 << 1))
			printf "locked "
		end
		if ($$data_val & (0x1 << 0))
			printf "valid "
		else
			printf "invalid "
		end
		printf ")\n"
		set $$i = $$i + 1
	end
end
define show_icplbs
	set $$IMEM_CONTROL = 0xFFE01004
	printf "ICPLBS (0x%08x)\n", *(unsigned long *)$$IMEM_CONTROL
	_show_cplbs 0xFFE01100 0xFFE01200
end
define show_dcplbs
	set $$DMEM_CONTROL = 0xFFE00004
	printf "DCPLBS (0x%08x)\n", *(unsigned long *)$$DMEM_CONTROL
	_show_cplbs 0xFFE00100 0xFFE00200
end
define show_cplbs
	show_icplbs
	show_dcplbs
end
