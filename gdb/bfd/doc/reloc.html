<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from reloc.texi on 21 June 2001 -->

<TITLE>Untitled Document</TITLE>
</HEAD>
<BODY>
<H1>Untitled Document</H1>
<P>
<P><HR><P>


<H2><A NAME="SEC1" HREF="reloc_toc.html#TOC1">Relocations</A></H2>
<P>
BFD maintains relocations in much the same way it maintains
symbols: they are left alone until required, then read in
en-mass and translated into an internal form.  A common
routine <CODE>bfd_perform_relocation</CODE> acts upon the
canonical form to do the fixup.

</P>
<P>
Relocations are maintained on a per section basis,
while symbols are maintained on a per BFD basis.

</P>
<P>
All that a back end has to do to fit the BFD interface is to create
a <CODE>struct reloc_cache_entry</CODE> for each relocation
in a particular section, and fill in the right bits of the structures.

</P>



<H3><A NAME="SEC2" HREF="reloc_toc.html#TOC2">typedef arelent</A></H3>
<P>
This is the structure of a relocation entry:

</P>


<PRE>

typedef enum bfd_reloc_status
{
       /* No errors detected */
  bfd_reloc_ok,

       /* The relocation was performed, but there was an overflow. */
  bfd_reloc_overflow,

       /* The address to relocate was not within the section supplied. */
  bfd_reloc_outofrange,

       /* Used by special functions */
  bfd_reloc_continue,

       /* Unsupported relocation size requested. */
  bfd_reloc_notsupported,

       /* Unused */
  bfd_reloc_other,

       /* The symbol to relocate against was undefined. */
  bfd_reloc_undefined,

       /* The relocation was performed, but may not be ok - presently
          generated only when linking i960 coff files with i960 b.out
          symbols.  If this type is returned, the error_message argument
          to bfd_perform_relocation will be set.  */
  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;

typedef struct reloc_cache_entry
{
       /* A pointer into the canonical table of pointers  */
  struct symbol_cache_entry **sym_ptr_ptr;

       /* offset in section */
  bfd_size_type address;

       /* addend for relocation value */
  bfd_vma addend;

       /* Pointer to how to perform the required relocation */
  reloc_howto_type *howto;

} arelent;
</PRE>

<P>
<STRONG>Description</STRONG><BR>
Here is a description of each of the fields within an <CODE>arelent</CODE>:

</P>

<UL>

<LI>

<CODE>sym_ptr_ptr</CODE>
</UL>

<P>
The symbol table pointer points to a pointer to the symbol
associated with the relocation request.  It is
the pointer into the table returned by the back end's
<CODE>get_symtab</CODE> action. @xref{Symbols}. The symbol is referenced
through a pointer to a pointer so that tools like the linker
can fix up all the symbols of the same name by modifying only
one pointer. The relocation routine looks in the symbol and
uses the base of the section the symbol is attached to and the
value of the symbol as the initial relocation offset. If the
symbol pointer is zero, then the section provided is looked up.

</P>

<UL>

<LI>

<CODE>address</CODE>
</UL>

<P>
The <CODE>address</CODE> field gives the offset in bytes from the base of
the section data which owns the relocation record to the first
byte of relocatable information. The actual data relocated
will be relative to this point; for example, a relocation
type which modifies the bottom two bytes of a four byte word
would not touch the first byte pointed to in a big endian
world.

</P>

<UL>

<LI>

<CODE>addend</CODE>
</UL>

<P>
The <CODE>addend</CODE> is a value provided by the back end to be added (!)
to the relocation offset. Its interpretation is dependent upon
the howto. For example, on the 68k the code:

</P>

<PRE>
        char foo[];
        main()
                {
                return foo[0x12345678];
                }
</PRE>

<P>
Could be compiled into:

</P>

<PRE>
        linkw fp,#-4
        moveb @#12345678,d0
        extbl d0
        unlk fp
        rts
</PRE>

<P>
This could create a reloc pointing to <CODE>foo</CODE>, but leave the
offset in the data, something like:

</P>

<PRE>
RELOCATION RECORDS FOR [.text]:
offset   type      value
00000006 32        _foo

00000000 4e56 fffc          ; linkw fp,#-4
00000004 1039 1234 5678     ; moveb @#12345678,d0
0000000a 49c0               ; extbl d0
0000000c 4e5e               ; unlk fp
0000000e 4e75               ; rts
</PRE>

<P>
Using coff and an 88k, some instructions don't have enough
space in them to represent the full address range, and
pointers have to be loaded in two parts. So you'd get something like:

</P>

<PRE>
        or.u     r13,r0,hi16(_foo+0x12345678)
        ld.b     r2,r13,lo16(_foo+0x12345678)
        jmp      r1
</PRE>

<P>
This should create two relocs, both pointing to <CODE>_foo</CODE>, and with
0x12340000 in their addend field. The data would consist of:

</P>

<PRE>
RELOCATION RECORDS FOR [.text]:
offset   type      value
00000002 HVRT16    _foo+0x12340000
00000006 LVRT16    _foo+0x12340000

00000000 5da05678           ; or.u r13,r0,0x5678
00000004 1c4d5678           ; ld.b r2,r13,0x5678
00000008 f400c001           ; jmp r1
</PRE>

<P>
The relocation routine digs out the value from the data, adds
it to the addend to get the original offset, and then adds the
value of <CODE>_foo</CODE>. Note that all 32 bits have to be kept around
somewhere, to cope with carry from bit 15 to bit 16.

</P>
<P>
One further example is the sparc and the a.out format. The
sparc has a similar problem to the 88k, in that some
instructions don't have room for an entire offset, but on the
sparc the parts are created in odd sized lumps. The designers of
the a.out format chose to not use the data within the section
for storing part of the offset; all the offset is kept within
the reloc. Anything in the data should be ignored.

</P>

<PRE>
        save %sp,-112,%sp
        sethi %hi(_foo+0x12345678),%g2
        ldsb [%g2+%lo(_foo+0x12345678)],%i0
        ret
        restore
</PRE>

<P>
Both relocs contain a pointer to <CODE>foo</CODE>, and the offsets
contain junk.

</P>

<PRE>
RELOCATION RECORDS FOR [.text]:
offset   type      value
00000004 HI22      _foo+0x12345678
00000008 LO10      _foo+0x12345678

00000000 9de3bf90     ; save %sp,-112,%sp
00000004 05000000     ; sethi %hi(_foo+0),%g2
00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0
0000000c 81c7e008     ; ret
00000010 81e80000     ; restore
</PRE>


<UL>

<LI>

<CODE>howto</CODE>
</UL>

<P>
The <CODE>howto</CODE> field can be imagined as a
relocation instruction. It is a pointer to a structure which
contains information on what to do with all of the other
information in the reloc record and data section. A back end
would normally have a relocation instruction set and turn
relocations into pointers to the correct structure on input -
but it would be possible to create each howto field on demand.

</P>


<H4><A NAME="SEC3" HREF="reloc_toc.html#TOC3"><CODE>enum complain_overflow</CODE></A></H4>
<P>
Indicates what sort of overflow checking should be done when
performing a relocation.

</P>


<PRE>

enum complain_overflow
{
       /* Do not complain on overflow. */
  complain_overflow_dont,

       /* Complain if the bitfield overflows, whether it is considered
          as signed or unsigned. */
  complain_overflow_bitfield,

       /* Complain if the value overflows when considered as signed
          number. */
  complain_overflow_signed,

       /* Complain if the value overflows when considered as an
          unsigned number. */
  complain_overflow_unsigned
};
</PRE>



<H4><A NAME="SEC4" HREF="reloc_toc.html#TOC4"><CODE>reloc_howto_type</CODE></A></H4>
<P>
The <CODE>reloc_howto_type</CODE> is a structure which contains all the
information that libbfd needs to know to tie up a back end's data.

</P>


<PRE>
struct symbol_cache_entry;             /* Forward declaration */

struct reloc_howto_struct
{
       /*  The type field has mainly a documentary use - the back end can
           do what it wants with it, though normally the back end's
           external idea of what a reloc number is stored
           in this field. For example, a PC relative word relocation
           in a coff environment has the type 023 - because that's
           what the outside world calls a R_PCRWORD reloc. */
  unsigned int type;

       /*  The value the final relocation is shifted right by. This drops
           unwanted data from the relocation.  */
  unsigned int rightshift;

       /*  The size of the item to be relocated.  This is *not* a
           power-of-two measure.  To get the number of bytes operated
           on by a type of relocation, use bfd_get_reloc_size.  */
  int size;

       /*  The number of bits in the item to be relocated.  This is used
           when doing overflow checking.  */
  unsigned int bitsize;

       /*  Notes that the relocation is relative to the location in the
           data section of the addend. The relocation function will
           subtract from the relocation value the address of the location
           being relocated. */
  boolean pc_relative;

       /*  The bit position of the reloc value in the destination.
           The relocated value is left shifted by this amount. */
  unsigned int bitpos;

       /* What type of overflow error should be checked for when
          relocating. */
  enum complain_overflow complain_on_overflow;

       /* If this field is non null, then the supplied function is
          called rather than the normal function. This allows really
          strange relocation methods to be accomodated (e.g., i960 callj
          instructions). */
  bfd_reloc_status_type (*special_function)
                                   PARAMS ((bfd *abfd,
                                            arelent *reloc_entry,
                                            struct symbol_cache_entry *symbol,
                                            PTR data,
                                            asection *input_section,
                                            bfd *output_bfd,
                                            char **error_message));

       /* The textual name of the relocation type. */
  char *name;

       /* When performing a partial link, some formats must modify the
          relocations rather than the data - this flag signals this.*/
  boolean partial_inplace;

       /* The src_mask selects which parts of the read in data
          are to be used in the relocation sum.  E.g., if this was an 8 bit
          bit of data which we read and relocated, this would be
          0x000000ff. When we have relocs which have an addend, such as
          sun4 extended relocs, the value in the offset part of a
          relocating field is garbage so we never use it. In this case
          the mask would be 0x00000000. */
  bfd_vma src_mask;

       /* The dst_mask selects which parts of the instruction are replaced
          into the instruction. In most cases src_mask == dst_mask,
          except in the above special case, where dst_mask would be
          0x000000ff, and src_mask would be 0x00000000.   */
  bfd_vma dst_mask;

       /* When some formats create PC relative instructions, they leave
          the value of the pc of the place being relocated in the offset
          slot of the instruction, so that a PC relative relocation can
          be made just by adding in an ordinary offset (e.g., sun3 a.out).
          Some formats leave the displacement part of an instruction
          empty (e.g., m88k bcs); this flag signals the fact.*/
  boolean pcrel_offset;

};
</PRE>

<P>
<A NAME="IDX1"></A>


<H4><A NAME="SEC5" HREF="reloc_toc.html#TOC5"><CODE>The HOWTO Macro</CODE></A></H4>
<P>
<STRONG>Description</STRONG><BR>
The HOWTO define is horrible and will go away.

<PRE>
#define HOWTO(C, R,S,B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
  {(unsigned)C,R,S,B, P, BI, O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}
</PRE>

<P>
<STRONG>Description</STRONG><BR>
And will be replaced with the totally magic way. But for the
moment, we are compatible, so do it this way.

<PRE>
#define NEWHOWTO( FUNCTION, NAME,SIZE,REL,IN) HOWTO(0,0,SIZE,0,REL,0,complain_overflow_dont,FUNCTION, NAME,false,0,0,IN)

</PRE>

<P>
<STRONG>Description</STRONG><BR>
Helper routine to turn a symbol into a relocation value.

<PRE>
#define HOWTO_PREPARE(relocation, symbol)      \
  {                                            \
  if (symbol != (asymbol *)NULL) {             \
    if (bfd_is_com_section (symbol-&#62;section)) { \
      relocation = 0;                          \
    }                                          \
    else {                                     \
      relocation = symbol-&#62;value;              \
    }                                          \
  }                                            \
}
</PRE>

<P>
<A NAME="IDX2"></A>


<H4><A NAME="SEC6" HREF="reloc_toc.html#TOC6"><CODE>bfd_get_reloc_size</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
unsigned int bfd_get_reloc_size (reloc_howto_type *);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
For a reloc_howto_type that operates on a fixed number of bytes,
this returns the number of bytes operated on.

</P>
<P>
<A NAME="IDX3"></A>


<H4><A NAME="SEC7" HREF="reloc_toc.html#TOC7"><CODE>arelent_chain</CODE></A></H4>
<P>
<STRONG>Description</STRONG><BR>
How relocs are tied together in an <CODE>asection</CODE>:

<PRE>
typedef struct relent_chain {
  arelent relent;
  struct   relent_chain *next;
} arelent_chain;
</PRE>

<P>
<A NAME="IDX4"></A>


<H4><A NAME="SEC8" HREF="reloc_toc.html#TOC8"><CODE>bfd_check_overflow</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
bfd_reloc_status_type
bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    bfd_vma relocation);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
Perform overflow checking on <VAR>relocation</VAR> which has <VAR>bitsize</VAR>
significant bits and will be shifted right by <VAR>rightshift</VAR> bits.
The result is either of <CODE>bfd_reloc_ok</CODE> or
<CODE>bfd_reloc_overflow</CODE>.

</P>
<P>
<A NAME="IDX5"></A>


<H4><A NAME="SEC9" HREF="reloc_toc.html#TOC9"><CODE>bfd_perform_relocation</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
bfd_reloc_status_type
bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    PTR data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
If <VAR>output_bfd</VAR> is supplied to this function, the
generated image will be relocatable; the relocations are
copied to the output file after they have been changed to
reflect the new state of the world. There are two ways of
reflecting the results of partial linkage in an output file:
by modifying the output data in place, and by modifying the
relocation record.  Some native formats (e.g., basic a.out and
basic coff) have no way of specifying an addend in the
relocation type, so the addend has to go in the output data.
This is no big deal since in these formats the output data
slot will always be big enough for the addend. Complex reloc
types with addends were invented to solve just this problem.
The <VAR>error_message</VAR> argument is set to an error message if
this return <CODE>bfd_reloc_dangerous</CODE>.

</P>
<P>
<A NAME="IDX6"></A>


<H4><A NAME="SEC10" HREF="reloc_toc.html#TOC10"><CODE>bfd_install_relocation</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
bfd_reloc_status_type
bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    PTR data, bfd_vma data_start,
    asection *input_section,
    char **error_message);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
This looks remarkably like <CODE>bfd_perform_relocation</CODE>, except it
does not expect that the section contents have been filled in.
I.e., it's suitable for use when creating, rather than applying
a relocation.

</P>
<P>
For now, this function should be considered reserved for the
assembler.

</P>



<H2><A NAME="SEC11" HREF="reloc_toc.html#TOC11">The howto manager</A></H2>
<P>
When an application wants to create a relocation, but doesn't
know what the target machine might call it, it can find out by
using this bit of code.

</P>
<P>
<A NAME="IDX7"></A>


<H4><A NAME="SEC12" HREF="reloc_toc.html#TOC12"><CODE>bfd_reloc_code_type</CODE></A></H4>
<P>
<STRONG>Description</STRONG><BR>
The insides of a reloc code.  The idea is that, eventually, there
will be one enumerator for every type of relocation we ever do.
Pass one of these values to <CODE>bfd_reloc_type_lookup</CODE>, and it'll
return a howto pointer.

</P>
<P>
This does mean that the application must determine the correct
enumerator value; you can't get a howto pointer from a random set
of attributes.

</P>
<P>
Here are the possible values for <CODE>enum bfd_reloc_code_real</CODE>:

</P>
<P>
<DL>
<DT><U>:</U> <B>BFD_RELOC_64</B>
<DD><A NAME="IDX8"></A>
<DT><U>:</U> <B>BFD_RELOC_32</B>
<DD><A NAME="IDX9"></A>
<DT><U>:</U> <B>BFD_RELOC_26</B>
<DD><A NAME="IDX10"></A>
<DT><U>:</U> <B>BFD_RELOC_24</B>
<DD><A NAME="IDX11"></A>
<DT><U>:</U> <B>BFD_RELOC_16</B>
<DD><A NAME="IDX12"></A>
<DT><U>:</U> <B>BFD_RELOC_14</B>
<DD><A NAME="IDX13"></A>
<DT><U>:</U> <B>BFD_RELOC_8</B>
<DD><A NAME="IDX14"></A>
Basic absolute relocations of N bits.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_64_PCREL</B>
<DD><A NAME="IDX15"></A>
<DT><U>:</U> <B>BFD_RELOC_32_PCREL</B>
<DD><A NAME="IDX16"></A>
<DT><U>:</U> <B>BFD_RELOC_24_PCREL</B>
<DD><A NAME="IDX17"></A>
<DT><U>:</U> <B>BFD_RELOC_16_PCREL</B>
<DD><A NAME="IDX18"></A>
<DT><U>:</U> <B>BFD_RELOC_12_PCREL</B>
<DD><A NAME="IDX19"></A>
<DT><U>:</U> <B>BFD_RELOC_8_PCREL</B>
<DD><A NAME="IDX20"></A>
PC-relative relocations.  Sometimes these are relative to the address
of the relocation itself; sometimes they are relative to the start of
the section containing the relocation.  It depends on the specific target.

</P>
<P>
The 24-bit relocation is used in some Intel 960 configurations.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_32_GOT_PCREL</B>
<DD><A NAME="IDX21"></A>
<DT><U>:</U> <B>BFD_RELOC_16_GOT_PCREL</B>
<DD><A NAME="IDX22"></A>
<DT><U>:</U> <B>BFD_RELOC_8_GOT_PCREL</B>
<DD><A NAME="IDX23"></A>
<DT><U>:</U> <B>BFD_RELOC_32_GOTOFF</B>
<DD><A NAME="IDX24"></A>
<DT><U>:</U> <B>BFD_RELOC_16_GOTOFF</B>
<DD><A NAME="IDX25"></A>
<DT><U>:</U> <B>BFD_RELOC_LO16_GOTOFF</B>
<DD><A NAME="IDX26"></A>
<DT><U>:</U> <B>BFD_RELOC_HI16_GOTOFF</B>
<DD><A NAME="IDX27"></A>
<DT><U>:</U> <B>BFD_RELOC_HI16_S_GOTOFF</B>
<DD><A NAME="IDX28"></A>
<DT><U>:</U> <B>BFD_RELOC_8_GOTOFF</B>
<DD><A NAME="IDX29"></A>
<DT><U>:</U> <B>BFD_RELOC_32_PLT_PCREL</B>
<DD><A NAME="IDX30"></A>
<DT><U>:</U> <B>BFD_RELOC_24_PLT_PCREL</B>
<DD><A NAME="IDX31"></A>
<DT><U>:</U> <B>BFD_RELOC_16_PLT_PCREL</B>
<DD><A NAME="IDX32"></A>
<DT><U>:</U> <B>BFD_RELOC_8_PLT_PCREL</B>
<DD><A NAME="IDX33"></A>
<DT><U>:</U> <B>BFD_RELOC_32_PLTOFF</B>
<DD><A NAME="IDX34"></A>
<DT><U>:</U> <B>BFD_RELOC_16_PLTOFF</B>
<DD><A NAME="IDX35"></A>
<DT><U>:</U> <B>BFD_RELOC_LO16_PLTOFF</B>
<DD><A NAME="IDX36"></A>
<DT><U>:</U> <B>BFD_RELOC_HI16_PLTOFF</B>
<DD><A NAME="IDX37"></A>
<DT><U>:</U> <B>BFD_RELOC_HI16_S_PLTOFF</B>
<DD><A NAME="IDX38"></A>
<DT><U>:</U> <B>BFD_RELOC_8_PLTOFF</B>
<DD><A NAME="IDX39"></A>
For ELF.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_68K_GLOB_DAT</B>
<DD><A NAME="IDX40"></A>
<DT><U>:</U> <B>BFD_RELOC_68K_JMP_SLOT</B>
<DD><A NAME="IDX41"></A>
<DT><U>:</U> <B>BFD_RELOC_68K_RELATIVE</B>
<DD><A NAME="IDX42"></A>
Relocations used by 68K ELF.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_32_BASEREL</B>
<DD><A NAME="IDX43"></A>
<DT><U>:</U> <B>BFD_RELOC_16_BASEREL</B>
<DD><A NAME="IDX44"></A>
<DT><U>:</U> <B>BFD_RELOC_LO16_BASEREL</B>
<DD><A NAME="IDX45"></A>
<DT><U>:</U> <B>BFD_RELOC_HI16_BASEREL</B>
<DD><A NAME="IDX46"></A>
<DT><U>:</U> <B>BFD_RELOC_HI16_S_BASEREL</B>
<DD><A NAME="IDX47"></A>
<DT><U>:</U> <B>BFD_RELOC_8_BASEREL</B>
<DD><A NAME="IDX48"></A>
<DT><U>:</U> <B>BFD_RELOC_RVA</B>
<DD><A NAME="IDX49"></A>
Linkage-table relative.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_8_FFnn</B>
<DD><A NAME="IDX50"></A>
Absolute 8-bit relocation, but used to form an address like 0xFFnn.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_32_PCREL_S2</B>
<DD><A NAME="IDX51"></A>
<DT><U>:</U> <B>BFD_RELOC_16_PCREL_S2</B>
<DD><A NAME="IDX52"></A>
<DT><U>:</U> <B>BFD_RELOC_23_PCREL_S2</B>
<DD><A NAME="IDX53"></A>
These PC-relative relocations are stored as word displacements --
i.e., byte displacements shifted right two bits.  The 30-bit word
displacement (&#60;&#60;32_PCREL_S2&#62;&#62; -- 32 bits, shifted 2) is used on the
SPARC.  (SPARC tools generally refer to this as &#60;&#60;WDISP30&#62;&#62;.)  The
signed 16-bit displacement is used on the MIPS, and the 23-bit
displacement is used on the Alpha.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_HI22</B>
<DD><A NAME="IDX54"></A>
<DT><U>:</U> <B>BFD_RELOC_LO10</B>
<DD><A NAME="IDX55"></A>
High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
the target word.  These are used on the SPARC.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_GPREL16</B>
<DD><A NAME="IDX56"></A>
<DT><U>:</U> <B>BFD_RELOC_GPREL32</B>
<DD><A NAME="IDX57"></A>
For systems that allocate a Global Pointer register, these are
displacements off that register.  These relocation types are
handled specially, because the value the register will have is
decided relatively late.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_I960_CALLJ</B>
<DD><A NAME="IDX58"></A>
Reloc types used for i960/b.out.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_NONE</B>
<DD><A NAME="IDX59"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_WDISP22</B>
<DD><A NAME="IDX60"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC22</B>
<DD><A NAME="IDX61"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC13</B>
<DD><A NAME="IDX62"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_GOT10</B>
<DD><A NAME="IDX63"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_GOT13</B>
<DD><A NAME="IDX64"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_GOT22</B>
<DD><A NAME="IDX65"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_PC10</B>
<DD><A NAME="IDX66"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_PC22</B>
<DD><A NAME="IDX67"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_WPLT30</B>
<DD><A NAME="IDX68"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_COPY</B>
<DD><A NAME="IDX69"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_GLOB_DAT</B>
<DD><A NAME="IDX70"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_JMP_SLOT</B>
<DD><A NAME="IDX71"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_RELATIVE</B>
<DD><A NAME="IDX72"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_UA32</B>
<DD><A NAME="IDX73"></A>
SPARC ELF relocations.  There is probably some overlap with other
relocation types already defined.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_SPARC_BASE13</B>
<DD><A NAME="IDX74"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_BASE22</B>
<DD><A NAME="IDX75"></A>
I think these are specific to SPARC a.out (e.g., Sun 4).
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_SPARC_64</B>
<DD><A NAME="IDX76"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_10</B>
<DD><A NAME="IDX77"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_11</B>
<DD><A NAME="IDX78"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_OLO10</B>
<DD><A NAME="IDX79"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_HH22</B>
<DD><A NAME="IDX80"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_HM10</B>
<DD><A NAME="IDX81"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_LM22</B>
<DD><A NAME="IDX82"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_PC_HH22</B>
<DD><A NAME="IDX83"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_PC_HM10</B>
<DD><A NAME="IDX84"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_PC_LM22</B>
<DD><A NAME="IDX85"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_WDISP16</B>
<DD><A NAME="IDX86"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_WDISP19</B>
<DD><A NAME="IDX87"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_7</B>
<DD><A NAME="IDX88"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_6</B>
<DD><A NAME="IDX89"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_5</B>
<DD><A NAME="IDX90"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_DISP64</B>
<DD><A NAME="IDX91"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_PLT64</B>
<DD><A NAME="IDX92"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_HIX22</B>
<DD><A NAME="IDX93"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_LOX10</B>
<DD><A NAME="IDX94"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_H44</B>
<DD><A NAME="IDX95"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_M44</B>
<DD><A NAME="IDX96"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_L44</B>
<DD><A NAME="IDX97"></A>
<DT><U>:</U> <B>BFD_RELOC_SPARC_REGISTER</B>
<DD><A NAME="IDX98"></A>
SPARC64 relocations
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_GPDISP_HI16</B>
<DD><A NAME="IDX99"></A>
Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
"addend" in some special way.
For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
writing; when reading, it will be the absolute section symbol.  The
addend is the displacement in bytes of the "lda" instruction from
the "ldah" instruction (which is at the address of this reloc).
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_GPDISP_LO16</B>
<DD><A NAME="IDX100"></A>
For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
with GPDISP_HI16 relocs.  The addend is ignored when writing the
relocations out, and is filled in with the file's GP value on
reading, for convenience.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_GPDISP</B>
<DD><A NAME="IDX101"></A>
The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
relocation except that there is no accompanying GPDISP_LO16
relocation.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_LITERAL</B>
<DD><A NAME="IDX102"></A>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_ELF_LITERAL</B>
<DD><A NAME="IDX103"></A>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_LITUSE</B>
<DD><A NAME="IDX104"></A>
The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
the assembler turns it into a LDQ instruction to load the address of
the symbol, and then fills in a register in the real instruction.

</P>
<P>
The LITERAL reloc, at the LDQ instruction, refers to the .lita
section symbol.  The addend is ignored when writing, but is filled
in with the file's GP value on reading, for convenience, as with the
GPDISP_LO16 reloc.

</P>
<P>
The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
It should refer to the symbol to be referenced, as with 16_GOTOFF,
but it generates output not based on the position within the .got
section, but relative to the GP value chosen for the file during the
final link stage.

</P>
<P>
The LITUSE reloc, on the instruction using the loaded address, gives
information to the linker that it might be able to use to optimize
away some literal section references.  The symbol is ignored (read
as the absolute section symbol), and the "addend" indicates the type
of instruction using the register:
1 - "memory" fmt insn
2 - byte-manipulation (byte offset reg)
3 - jsr (target of branch)

</P>
<P>
The GNU linker currently doesn't do any of this optimizing.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_HINT</B>
<DD><A NAME="IDX105"></A>
The HINT relocation indicates a value that should be filled into the
"hint" field of a jmp/jsr/ret instruction, for possible branch-
prediction logic which may be provided on some processors.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_LINKAGE</B>
<DD><A NAME="IDX106"></A>
The LINKAGE relocation outputs a linkage pair in the object file,
which is filled by the linker.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ALPHA_CODEADDR</B>
<DD><A NAME="IDX107"></A>
The CODEADDR relocation outputs a STO_CA in the object file,
which is filled by the linker.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MIPS_JMP</B>
<DD><A NAME="IDX108"></A>
Bits 27..2 of the relocation address shifted right 2 bits;
simple reloc otherwise.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MIPS16_JMP</B>
<DD><A NAME="IDX109"></A>
The MIPS16 jump instruction.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MIPS16_GPREL</B>
<DD><A NAME="IDX110"></A>
MIPS16 GP relative reloc.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_HI16</B>
<DD><A NAME="IDX111"></A>
High 16 bits of 32-bit value; simple reloc.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_HI16_S</B>
<DD><A NAME="IDX112"></A>
High 16 bits of 32-bit value but the low 16 bits will be sign
extended and added to form the final result.  If the low 16
bits form a negative number, we need to add one to the high value
to compensate for the borrow when the low bits are added.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_LO16</B>
<DD><A NAME="IDX113"></A>
Low 16 bits.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_PCREL_HI16_S</B>
<DD><A NAME="IDX114"></A>
Like BFD_RELOC_HI16_S, but PC relative.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_PCREL_LO16</B>
<DD><A NAME="IDX115"></A>
Like BFD_RELOC_LO16, but PC relative.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MIPS_GPREL</B>
<DD><A NAME="IDX116"></A>
Relocation relative to the global pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MIPS_LITERAL</B>
<DD><A NAME="IDX117"></A>
Relocation against a MIPS literal section.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MIPS_GOT16</B>
<DD><A NAME="IDX118"></A>
<DT><U>:</U> <B>BFD_RELOC_MIPS_CALL16</B>
<DD><A NAME="IDX119"></A>
<DT><U>:</U> <B>BFD_RELOC_MIPS_GPREL32</B>
<DD><A NAME="IDX120"></A>
<DT><U>:</U> <B>BFD_RELOC_MIPS_GOT_HI16</B>
<DD><A NAME="IDX121"></A>
<DT><U>:</U> <B>BFD_RELOC_MIPS_GOT_LO16</B>
<DD><A NAME="IDX122"></A>
<DT><U>:</U> <B>BFD_RELOC_MIPS_CALL_HI16</B>
<DD><A NAME="IDX123"></A>
<DT><U>:</U> <B>BFD_RELOC_MIPS_CALL_LO16</B>
<DD><A NAME="IDX124"></A>
MIPS ELF relocations.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_386_GOT32</B>
<DD><A NAME="IDX125"></A>
<DT><U>:</U> <B>BFD_RELOC_386_PLT32</B>
<DD><A NAME="IDX126"></A>
<DT><U>:</U> <B>BFD_RELOC_386_COPY</B>
<DD><A NAME="IDX127"></A>
<DT><U>:</U> <B>BFD_RELOC_386_GLOB_DAT</B>
<DD><A NAME="IDX128"></A>
<DT><U>:</U> <B>BFD_RELOC_386_JUMP_SLOT</B>
<DD><A NAME="IDX129"></A>
<DT><U>:</U> <B>BFD_RELOC_386_RELATIVE</B>
<DD><A NAME="IDX130"></A>
<DT><U>:</U> <B>BFD_RELOC_386_GOTOFF</B>
<DD><A NAME="IDX131"></A>
<DT><U>:</U> <B>BFD_RELOC_386_GOTPC</B>
<DD><A NAME="IDX132"></A>
i386/elf relocations
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_NS32K_IMM_8</B>
<DD><A NAME="IDX133"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_IMM_16</B>
<DD><A NAME="IDX134"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_IMM_32</B>
<DD><A NAME="IDX135"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_IMM_8_PCREL</B>
<DD><A NAME="IDX136"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_IMM_16_PCREL</B>
<DD><A NAME="IDX137"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_IMM_32_PCREL</B>
<DD><A NAME="IDX138"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_DISP_8</B>
<DD><A NAME="IDX139"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_DISP_16</B>
<DD><A NAME="IDX140"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_DISP_32</B>
<DD><A NAME="IDX141"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_DISP_8_PCREL</B>
<DD><A NAME="IDX142"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_DISP_16_PCREL</B>
<DD><A NAME="IDX143"></A>
<DT><U>:</U> <B>BFD_RELOC_NS32K_DISP_32_PCREL</B>
<DD><A NAME="IDX144"></A>
ns32k relocations
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_PPC_B26</B>
<DD><A NAME="IDX145"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_BA26</B>
<DD><A NAME="IDX146"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_TOC16</B>
<DD><A NAME="IDX147"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_B16</B>
<DD><A NAME="IDX148"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_B16_BRTAKEN</B>
<DD><A NAME="IDX149"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_B16_BRNTAKEN</B>
<DD><A NAME="IDX150"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_BA16</B>
<DD><A NAME="IDX151"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_BA16_BRTAKEN</B>
<DD><A NAME="IDX152"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_BA16_BRNTAKEN</B>
<DD><A NAME="IDX153"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_COPY</B>
<DD><A NAME="IDX154"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_GLOB_DAT</B>
<DD><A NAME="IDX155"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_JMP_SLOT</B>
<DD><A NAME="IDX156"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_RELATIVE</B>
<DD><A NAME="IDX157"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_LOCAL24PC</B>
<DD><A NAME="IDX158"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_NADDR32</B>
<DD><A NAME="IDX159"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_NADDR16</B>
<DD><A NAME="IDX160"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_NADDR16_LO</B>
<DD><A NAME="IDX161"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_NADDR16_HI</B>
<DD><A NAME="IDX162"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_NADDR16_HA</B>
<DD><A NAME="IDX163"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_SDAI16</B>
<DD><A NAME="IDX164"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_SDA2I16</B>
<DD><A NAME="IDX165"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_SDA2REL</B>
<DD><A NAME="IDX166"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_SDA21</B>
<DD><A NAME="IDX167"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_MRKREF</B>
<DD><A NAME="IDX168"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_RELSEC16</B>
<DD><A NAME="IDX169"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_RELST_LO</B>
<DD><A NAME="IDX170"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_RELST_HI</B>
<DD><A NAME="IDX171"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_RELST_HA</B>
<DD><A NAME="IDX172"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_BIT_FLD</B>
<DD><A NAME="IDX173"></A>
<DT><U>:</U> <B>BFD_RELOC_PPC_EMB_RELSDA</B>
<DD><A NAME="IDX174"></A>
Power(rs6000) and PowerPC relocations.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_CTOR</B>
<DD><A NAME="IDX175"></A>
The type of reloc used to build a contructor table - at the moment
probably a 32 bit wide absolute relocation, but the target can choose.
It generally does map to one of the other relocation types.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ARM_PCREL_BRANCH</B>
<DD><A NAME="IDX176"></A>
ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
not stored in the instruction.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ARM_IMMEDIATE</B>
<DD><A NAME="IDX177"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_OFFSET_IMM</B>
<DD><A NAME="IDX178"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_SHIFT_IMM</B>
<DD><A NAME="IDX179"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_SWI</B>
<DD><A NAME="IDX180"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_MULTI</B>
<DD><A NAME="IDX181"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_CP_OFF_IMM</B>
<DD><A NAME="IDX182"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_ADR_IMM</B>
<DD><A NAME="IDX183"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_LDR_IMM</B>
<DD><A NAME="IDX184"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_LITERAL</B>
<DD><A NAME="IDX185"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_IN_POOL</B>
<DD><A NAME="IDX186"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_OFFSET_IMM8</B>
<DD><A NAME="IDX187"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_HWLITERAL</B>
<DD><A NAME="IDX188"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_THUMB_ADD</B>
<DD><A NAME="IDX189"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_THUMB_IMM</B>
<DD><A NAME="IDX190"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_THUMB_SHIFT</B>
<DD><A NAME="IDX191"></A>
<DT><U>:</U> <B>BFD_RELOC_ARM_THUMB_OFFSET</B>
<DD><A NAME="IDX192"></A>
These relocs are only used within the ARM assembler.  They are not
(at present) written to any object files.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_SH_PCDISP8BY2</B>
<DD><A NAME="IDX193"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_PCDISP12BY2</B>
<DD><A NAME="IDX194"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_IMM4</B>
<DD><A NAME="IDX195"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_IMM4BY2</B>
<DD><A NAME="IDX196"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_IMM4BY4</B>
<DD><A NAME="IDX197"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_IMM8</B>
<DD><A NAME="IDX198"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_IMM8BY2</B>
<DD><A NAME="IDX199"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_IMM8BY4</B>
<DD><A NAME="IDX200"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_PCRELIMM8BY2</B>
<DD><A NAME="IDX201"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_PCRELIMM8BY4</B>
<DD><A NAME="IDX202"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_SWITCH16</B>
<DD><A NAME="IDX203"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_SWITCH32</B>
<DD><A NAME="IDX204"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_USES</B>
<DD><A NAME="IDX205"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_COUNT</B>
<DD><A NAME="IDX206"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_ALIGN</B>
<DD><A NAME="IDX207"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_CODE</B>
<DD><A NAME="IDX208"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_DATA</B>
<DD><A NAME="IDX209"></A>
<DT><U>:</U> <B>BFD_RELOC_SH_LABEL</B>
<DD><A NAME="IDX210"></A>
Hitachi SH relocs.  Not all of these appear in object files.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_THUMB_PCREL_BRANCH9</B>
<DD><A NAME="IDX211"></A>
<DT><U>:</U> <B>BFD_RELOC_THUMB_PCREL_BRANCH12</B>
<DD><A NAME="IDX212"></A>
<DT><U>:</U> <B>BFD_RELOC_THUMB_PCREL_BRANCH23</B>
<DD><A NAME="IDX213"></A>
Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
be zero and is not stored in the instruction.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ARC_B22_PCREL</B>
<DD><A NAME="IDX214"></A>
Argonaut RISC Core (ARC) relocs.
ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
not stored in the instruction.  The high 20 bits are installed in bits 26
through 7 of the instruction.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_ARC_B26</B>
<DD><A NAME="IDX215"></A>
ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
stored in the instruction.  The high 24 bits are installed in bits 23
through 0.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_D10V_10_PCREL_R</B>
<DD><A NAME="IDX216"></A>
Mitsubishi D10V relocs.
This is a 10-bit reloc with the right 2 bits
assumed to be 0.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_D10V_10_PCREL_L</B>
<DD><A NAME="IDX217"></A>
Mitsubishi D10V relocs.
This is a 10-bit reloc with the right 2 bits
assumed to be 0.  This is the same as the previous reloc
except it is in the left container, i.e.,
shifted left 15 bits.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_D10V_18</B>
<DD><A NAME="IDX218"></A>
This is an 18-bit reloc with the right 2 bits
assumed to be 0.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_D10V_18_PCREL</B>
<DD><A NAME="IDX219"></A>
This is an 18-bit reloc with the right 2 bits
assumed to be 0.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_24</B>
<DD><A NAME="IDX220"></A>
Mitsubishi M32R relocs.
This is a 24 bit absolute address.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_10_PCREL</B>
<DD><A NAME="IDX221"></A>
This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_18_PCREL</B>
<DD><A NAME="IDX222"></A>
This is an 18-bit reloc with the right 2 bits assumed to be 0.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_26_PCREL</B>
<DD><A NAME="IDX223"></A>
This is a 26-bit reloc with the right 2 bits assumed to be 0.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_HI16_ULO</B>
<DD><A NAME="IDX224"></A>
This is a 16-bit reloc containing the high 16 bits of an address
used when the lower 16 bits are treated as unsigned.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_HI16_SLO</B>
<DD><A NAME="IDX225"></A>
This is a 16-bit reloc containing the high 16 bits of an address
used when the lower 16 bits are treated as signed.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_LO16</B>
<DD><A NAME="IDX226"></A>
This is a 16-bit reloc containing the lower 16 bits of an address.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_M32R_SDA16</B>
<DD><A NAME="IDX227"></A>
This is a 16-bit reloc containing the small data area offset for use in
add3, load, and store instructions.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_9_PCREL</B>
<DD><A NAME="IDX228"></A>
This is a 9-bit reloc
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_22_PCREL</B>
<DD><A NAME="IDX229"></A>
This is a 22-bit reloc
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_SDA_16_16_OFFSET</B>
<DD><A NAME="IDX230"></A>
This is a 16 bit offset from the short data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_SDA_15_16_OFFSET</B>
<DD><A NAME="IDX231"></A>
This is a 16 bit offset (of which only 15 bits are used) from the
short data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_ZDA_16_16_OFFSET</B>
<DD><A NAME="IDX232"></A>
This is a 16 bit offset from the zero data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_ZDA_15_16_OFFSET</B>
<DD><A NAME="IDX233"></A>
This is a 16 bit offset (of which only 15 bits are used) from the
zero data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_TDA_6_8_OFFSET</B>
<DD><A NAME="IDX234"></A>
This is an 8 bit offset (of which only 6 bits are used) from the
tiny data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_TDA_7_8_OFFSET</B>
<DD><A NAME="IDX235"></A>
This is an 8bit offset (of which only 7 bits are used) from the tiny
data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_TDA_7_7_OFFSET</B>
<DD><A NAME="IDX236"></A>
This is a 7 bit offset from the tiny data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_V850_TDA_16_16_OFFSET</B>
<DD><A NAME="IDX237"></A>
This is a 16 bit offset from the tiny data area pointer.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MN10300_32_PCREL</B>
<DD><A NAME="IDX238"></A>
This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
instruction.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_MN10300_16_PCREL</B>
<DD><A NAME="IDX239"></A>
This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
instruction.
</DL>
<DL>
<DT><U>:</U> <B>BFD_RELOC_TIC30_LDP</B>
<DD><A NAME="IDX240"></A>
This is a 8bit DP reloc for the tms320c30, where the most
significant 8 bits of a 24 bit word are placed into the least
significant 8 bits of the opcode.
</DL>

</P>

<PRE>

typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
</PRE>

<P>
<A NAME="IDX241"></A>


<H4><A NAME="SEC13" HREF="reloc_toc.html#TOC13"><CODE>bfd_reloc_type_lookup</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
reloc_howto_type *
bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
Return a pointer to a howto structure which, when
invoked, will perform the relocation <VAR>code</VAR> on data from the
architecture noted.

</P>
<P>
<A NAME="IDX242"></A>


<H4><A NAME="SEC14" HREF="reloc_toc.html#TOC14"><CODE>bfd_default_reloc_type_lookup</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
reloc_howto_type *bfd_default_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type  code);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
Provides a default relocation lookup routine for any architecture.

</P>
<P>
<A NAME="IDX243"></A>


<H4><A NAME="SEC15" HREF="reloc_toc.html#TOC15"><CODE>bfd_get_reloc_code_name</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
Provides a printable name for the supplied relocation code.
Useful mainly for printing error messages.

</P>
<P>
<A NAME="IDX244"></A>


<H4><A NAME="SEC16" HREF="reloc_toc.html#TOC16"><CODE>bfd_generic_relax_section</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
boolean bfd_generic_relax_section
   (bfd *abfd,
    asection *section,
    struct bfd_link_info *,
    boolean *);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
Provides default handling for relaxing for back ends which
don't do relaxing -- i.e., does nothing.

</P>
<P>
<A NAME="IDX245"></A>


<H4><A NAME="SEC17" HREF="reloc_toc.html#TOC17"><CODE>bfd_generic_get_relocated_section_contents</CODE></A></H4>
<P>
<STRONG>Synopsis</STRONG>

<PRE>
bfd_byte *
bfd_generic_get_relocated_section_contents (bfd *abfd,
    struct bfd_link_info *link_info,
    struct bfd_link_order *link_order,
    bfd_byte *data,
    boolean relocateable,
    asymbol **symbols);
</PRE>

<P>
<STRONG>Description</STRONG><BR>
Provides default handling of relocation effort for back ends
which can't be bothered to do it efficiently.

</P>
<P><HR><P>
This document was generated on 21 June 2001 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
