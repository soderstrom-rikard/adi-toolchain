<?xml version="1.0" standalone="yes"?>

<?xml-stylesheet type="text/xsl" href="AnomalyDictionary.xsl"?>

<!-- *********************************************************************** -->
<!-- ****** BLACKFIN-FRIO-anomaly.xml                                        -->
<!-- *********************************************************************** -->
<!-- ****** Common definition file for anomaly workaround/warn options for   -->
<!-- ****** the VisualDSP++ compilers and assemblers. This anomaly           -->
<!-- ****** dictionary is common to the processors in the Blackfin family    -->
<!-- ****** for the Edinborough core. It is referenced in each of the        -->
<!-- ****** applicable Blackfin *-compiler.xml file via the name in the      -->
<!-- ****** <vdsp-anomaly-dictionary> element.                               -->
<!-- ****** The uppermost elements in this file:                             -->
<!-- ****** 	<anomaly-dictionary>                                         -->
<!-- ****** 	<compiler-notes>                                             -->
<!-- ****** 	<assembler-notes>                                            -->
<!-- ****** Copyright 2006-2007 Analog Devices, Inc.  All rights reserved.   -->
<!-- *********************************************************************** -->

<visualdsp-dictionary-xml schema-version="1" name="BLACKFIN-FRIO-anomaly.xml">

<version file-version="0.26"/>

	<!-- *************************************************************** -->
	<!-- ** adi-web-link                                              ** -->
	<!-- *************************************************************** -->
	<!-- ** Position to the foremost page for the Blackfin anomalies. ** -->
	<!-- ** The programmer then selects the appropriate processor     ** -->
	<!-- ** errata sheet and searches for the anomaly id of interest. ** -->
	<!-- ** We do not directly link an anomaly id to its definition   ** -->
	<!-- ** at this time because the name of the web file contains a  ** --> 
	<!-- ** prefix that changes with each modification.               ** -->
	<!-- ** For example: "586044701BF535Anomaly11204.pdf"             ** -->
	<!-- *************************************************************** -->

	<!-- *************************************************************** -->
	<!-- ** ix                                                        ** -->
	<!-- *************************************************************** -->
	<!-- ** The ix is how it is cross-referenced from the workarounds ** -->
	<!-- ** located per silicon revision as defined in the per        ** -->
	<!-- ** processor *-compiler.xml files.                           ** -->
	<!-- *************************************************************** -->

	<!-- *************************************************************** -->	
	<!-- See below: compiler-notes and assembler-notes                ** -->
	<!-- * Compiler overview information for the anomaly-dictionary   ** -->
	<!-- * Assembler overview information for the anomaly-dictionary  ** -->
	<!-- *************************************************************** -->

<anomaly-dictionary adi-web-link="http://www.analog.com//processors//blackfin//support//ICanomalies.html" 
	title="Blackfin Family IC Anomalies" >

	<anomaly ix="1" id="05-00-0048"
		compiler-option="-workaround csync" 
		compiler-defs="-D__WORKAROUND_CSYNC"
		summary="Speculative fetch of illegal or undefined memory location causes HW error"/>

	<anomaly ix="2" id="05-00-0054"
		compiler-option="-workaround isr-ssync" 
		compiler-defs="-D__WORKAROUND_SSYNC"
		summary="Problems with data cache writeback mode"/>

	<anomaly ix="3" id="05-00-0071"
		compiler-option="-workaround isr-imask-check" 
		compiler-defs="-D__WORKAROUND_IMASK_CHECK"
		summary="CLI instruction can allow an asynchronous interrupt to occur as it is committing"/>

	<anomaly ix="4" id="05-00-0164"
		compiler-option="-workaround wt-dcache" 
		compiler-defs="-D__WORKAROUND_WT_DCACHE"
		summary="Store to Load Forwarding in Write Through Mode"/>

	<anomaly ix="5" id="05-00-0165"
		assembler-detect-option="-anomaly-detect 05000165" 
		assembler-detect-legacy-option="-anomaly-warn 05000165 or -wb_wt_warn"
		assembler-workaround-option="-anomaly-workaround 05000165" 
		assembler-workaround-legacy-option="-wb_wt_fix"
		assembler-detect-defs="-D__WORKAROUND_WB_DCACHE"
		assembler-workaround-defs="-D__WORKAROUND_WB_DCACHE"
		compiler-option="-workaround wb-dcache" 
		compiler-defs="-D__WORKAROUND_WB_DCACHE"
		compiler-behavior="(legacy) The compiler puts 2 NOPs after RTN/RTI/RTX and insert NOPs between conditional branches and stores. The SSYNC at the start of ISRs was superceded by a more complex ISR prefix)."
		assembler-behavior="The assembler workaround for -anomaly-workaround 05000165 inserts a nop before a store following a conditional branch or RTI/RTX/RTE/RTN, and also inserts a SSYNC before a store at a branch-target. The legacy command line option -wb_wt_fix corresponds to -anomaly-workaround 05000165. The legacy command line option -wb_fix does a subset of -anomaly-workaround 05000165: it inserts a nop before a store instruction after a conditional branch instruction or RTI/RTX/RTE/RTN instruction; there is no mapped anomaly ID corresponding to -wb_fix. The assembler -anomaly-detect 05000165 will detect code sequences where workaround for 05000165 might be desired, without actually modifying the assembly code. The legacy -wb_wt_warn corresponds to -anomaly-detect 05000165; -wb_warn detect code sequences where -wb_fix might be desired."
		summary="Data cache dirty bit set when a load-miss-fill is in progress"	/>

	<anomaly ix="6" id="05-00-0195"
		compiler-option="-workaround astat-rnd_mod" 
		compiler-defs="-D__WORKAROUND_ASTAT_RND_MOD"
		summary="Latency in Writes to RND_MOD bit."/>

	<anomaly ix="7" id="05-00-0104" 
		compiler-option="-workaround avoid-dag1" 
		compiler-defs="-D__WORKAROUND_AVOID_DAG1" 
		compiler-behavior="Note that avoid-dag1 is used for 05-00-0104, 05-00-0114, 05-00-0141, 05-00-0005, 05-00-0024 and 05-00-0202"
		summary="Stores to L1 Data memory incorrect when a specific sequence is followed"/>

	<anomaly ix="8" id="05-00-0157"
		compiler-option="-workaround killed-mmr-write"
		compiler-defs="-D__WORKAROUND_KILLED_MMR_WRITE"
		summary="A killed 32-bit System MMR write will lead to the next system MMR access thinking it should be 32-bit."
		compiler-behavior="The compiler works around this anomaly by inserting a dummy 32-bit MMR read at the start of C defined ISR functions (this behavior is superseded if the workaround for 05-00-0283 is enabled). Additionally the compiler will detect MMR reads in the shadow of conditional branch instructions. It will insert nop instructions to ensure that the MMR read is not in the first three instructions after such a jump. 
See the &quot;Compiler Notes&quot; section below for more information on MMR accesses."/>

	<anomaly ix="9" id="05-00-0198"
		compiler-option="-workaround sdram-mmr-read"
		compiler-defs="-D__WORKAROUND_SDRAM_MMR_READ"
		compiler-behavior="The compiler works around this anomaly by inserting a NOP instruction to avoid the anomaly condition. See note above regarding MMR accesses.
See the &quot;Compiler Notes&quot; section below for more information on MMR accesses."/>
		summary="System MMR accesses may fail when stalled by preceding memory read."/>

	<anomaly ix="10" id="05-00-0209" 
		assembler-detect-option="-anomaly-detect 05000209" 
		assembler-detect-legacy-option="-anomaly-warn 05000209"
		assembler-detect-defs="-D__WORKAROUND_DREG_COMP_LATENCY"
		compiler-option="-workaround dreg-comp-latency" 
		compiler-defs="-D__WORKAROUND_DREG_COMP_LATENCY"
		assembler-behavior="Assembler only supports detecting possible violation of anomaly 05000209; no workaround is provided. Assembler issues warnings where the first instruction writes to a DREG and the next instruction uses that DREG as a parameter to a SIGNBITS, EXTRACT, DEPOSIT or EXPADJ instruction. Review the warnings and recode where needed."
		summary="Speed-Path in computational unit affects certain instructions. The affected instructions are: EXTRACT(x) DEPOSIT(x) SIGNBITS EXPADJ."/>

	<anomaly ix="11" id="05-00-0127" 
		compiler-option="-workaround signbits" 
		compiler-defs="-D__WORKAROUND_SIGNBITS"
		summary="Signbits instruction not functional under certain conditions"/>

	<anomaly ix="12" id="05-00-0120" 
		compiler-option="-workaround testset-align" 
		compiler-defs="-D__WORKAROUND_TESTSET_ALIGN"
		summary="Testset instructions restricted to 32-bit aligned memory locations."/>

	<anomaly ix="13" id="05-00-0227"
		assembler-detect-option="-anomaly-detect 05000227" 
		assembler-detect-legacy-option="-anomaly-warn 05000227 or -sp_warn"
		assembler-workaround-option="-anomaly-workaround 05000227" 		
		assembler-workaround-legacy-option="-sp_fix"		
		assembler-detect-defs="-D__WORKAROUND_SCRATCHPAD_READ"
		assembler-workaround-defs="-D__WORKAROUND_SCRATCHPAD_READ"
		compiler-option="-workaround scratchpad-read"
		compiler-defs="-D__WORKAROUND_SCRATCHPAD_READ"
		assembler-behavior="The assembler checks any three consecutive load instructions, and if either the second or the third instruction is also a byte-load instruction, -anomaly-workaround 05000227 inserts a nop after the first instruction; -anomaly-detect 05000227 issues a warning message without actually modifying the assembly code."
		summary="Scratchpad memory bank reads may return incorrect data"/>

	<anomaly ix="14" id="05-00-0046"
		compiler-option="-workaround shift"
		compiler-defs="-D__WORKAROUND_SHIFT"
		compiler-behavior="This currently has no effect on the compiler behavior, since shifts of magnitude greater than the source bit size are undefined by the C standard."
		summary="Shifter does not consider all 32 bits when shift value is a D register."/>

	<anomaly ix="15" id="05-00-0245"
		assembler-detect-option="-anomaly-detect 05000245"
		assembler-detect-legacy-option="-anomaly-detect 05000245 or -brcc_warn"
		assembler-detect-defs="-D__WORKAROUND_SPECULATIVE_LOADS"
		assembler-behavior="The assembler warns if any of the three instructions following a conditional branch predicted not taken is a load, or if the target of a predicted branch is a load. There is no assembler workaround option available for anomaly 05000244. Review the warnings and recode where needed. Assembler legacy command line option -brcc_warn corresponds to -anomaly-detect 05000244,05000245."		
		compiler-option="-workaround speculative-loads"
		compiler-defs="-D__WORKAROUND_SPECULATIVE_LOADS"
		summary="Avoid speculative loads to reserved memory on not-taken control paths of conditional branch opcodes."/>

	<anomaly ix="16" id="05-00-0244"
		assembler-detect-option="-anomaly-detect 05000244"
		assembler-detect-legacy-option="-anomaly-warn 05000244 or -brcc_warn"
		assembler-detect-defs="-D__WORKAROUND_SPECULATIVE_SYNCS"
		assembler-behavior="The assembler warns if any of the three instructions following a conditional branch predicted not taken is a SYNC or CSYNC, or if the target of a predicted branch is a SSYNC or CSYNC. There is no assembler workaround option available for anomaly 05000244. Review the warnings and recode where needed. Assembler legacy command line option -brcc_warn corresponds to -anomaly-detect 05000244,05000245."
		compiler-option="-workaround speculative-syncs"
		compiler-defs="-D__WORKAROUND_SPECULATIVE_SYNCS"
		compiler-behavior="With the workaround enabled the compiler will insert nops to avoid the anomaly conditions. The following forms of the anomaly are avoided by the compiler:
  
		  1-
		    IF CC JUMP ...;  
		    CSYNC/SSYNC/IDLE;
		    CSYNC/SSYNC/IDLE;
		    CSYNC/SSYNC/IDLE;
  
		  2-
		    IF CC JUMP X (BP);
		    ...
		    X: CSYNC/SSYNC/IDLE;

		  3-
		    LSETUP(LT, LB) ...
		    LT:
		      CSYNC/SSYNC/IDLE;
		      CSYNC/SSYNC/IDLE;
		      IF CC JUMP X:
		    LB:	NOP;
		    X:
  
		  The VisualDSP++ runtime libraries also avoid this anomaly when necessary."
		summary="With cache enabled SSYNC, CCYNC and IDLE instructions in the shadow of conditional branches can cause incorrect operation."/>

	<anomaly ix="17" id="05-00-0103"
		compiler-option="-workaround cycles-stores"
		compiler-defs="-D__WORKAROUND_CYCLES_STORES"
		summary="Avoid writes to CYCLES and CYCLES 2 in shadow of conditional branches."/>

	<anomaly ix="18" id="05-00-0248"
		compiler-option="-workaround l2-testset-stall"
		compiler-defs="-D__WORKAROUND_L2_TESTSET_STALL"
		compiler-behavior="The avoidance is performed by the compiler automatically issuing a write to an L2 defined variable immediately following a testset instruction. This is done as part of the code generated for a __builtin_testset() call."
		summary="TestSet operation causes core stall (dual-core)."/>

	<anomaly ix="19" id="05-00-0189 05-00-0310"
		compiler-option="-workaround avoid-ldf-boundaries"
		compiler-defs="-D__WORKAROUND_AVOID_LDF_BLOCK_BOUNDARIES"
		compiler-behavior="Avoidance for both errata is done in the default LDF files under the macro __WORKAROUND_AVOID_LDF_BLOCK_BOUNDARIES using the linker RESERVE operator."
		summary="05-00-0189 - Speculative (and fetches made at boundary of reserved memory space) for instruction or data fetches may cause false protection exceptions. Similar errata 05-00-0310, results in false hardware errors caused by fetches at the boundary of reserved memory. Avoidance for both errata is done in the default LDF files under the macro __WORKAROUND_AVOID_LDF_BLOCK_BOUNDARIES using the linker RESERVE operator.  "/>


	<anomaly ix="20" id="05-00-0202"
		compiler-option="-workaround infinite-stall-202"
		compiler-defs="-D__WORKAROUND_INFINITE_STALL_202"
		summary="Possible infinite stall with specific dual dag situation."
		compiler-behavior="For the anomaly to happen the following conditions must be met:
           1 - Recent write ->
           2 - Dual dag access that collides ->
           3 - Read of location written in 1 immediately after 2 ->
           4 - no read, write or PREFETCH immediately after 3. 

         The compiler always assumes that 1 has occurred as the definition of recent is too vague to quantify. This means that for the problem to require a workaround from the compiler we have to have 2, 3, and 4 execute in sequence with no intevening instructions. The workaround used by the compiler is to insert a PREFETCH[SP] between 3 and 4."/>

	<anomaly ix="21" id="05-00-0246"
		compiler-option="-workaround no-cplbs-spec-protect-246"
		compiler-defs="-D__WORKAROUND_NO_CPLB_SPEC_PROTECT_246"
		summary="Data CPLB's were thought to provide protection from speculative load problems but for some targets this is not the case. For such targets the compiler will ignore the use of -cplbs when considering the need to apply workarounds for speculative load anomalies (such as 05-00-0245)."/>

	<anomaly ix="22" id="05-00-0257"
		compiler-option="-workaround short-loop-exceptions-257"
		compiler-defs="-D__WORKAROUND_SHORT_LOOP_EXCEPTIONS_257"
		compiler-behavior="The workaround implemented in the compiler is to include a save and restore of the LC0 and LC1 registers in interrupt and exception handlers. Such functions would be declared using one of the compiler interrupt handler pragmas or the macros defined in include file sys/exception.h. The compiler would only normally save and restore LC0 and LC1 if they were required to be saved and restored because the handler used them and this workaround means that they will always be restored whether used or not." 
		summary="Hardware loops less than 4 instructions in length may operate incorrectly if an interrupt or exception is taken at the end of the loop." />

	<anomaly ix="23" id="05-00-0264"
		compiler-option="-workaround pre-loop-end-sync-stall-264"
		compiler-defs="-D__WORKAROUND_PRE_LOOP_END_SYNC_STALL_264"
		compiler-behavior="The compiler will insert a NOP as the last instruction of the hardware loop where necessary to prevent an SSYNC, CSYNC, or IDLE being the second-to-last instruction."
		summary="If an SSYNC, CSYNC, or IDLE instruction is the second to last instruction of a hardware loop, there is a possibility that the processor will enter an infinite stall when trying to execute the sync." />

	<anomaly ix="24" id="05-00-0262"
		compiler-option="-workaround lost-stores-to-data-cache-262"
		compiler-defs="-D__WORKAROUND_LOST_STORES_TO_DATA_CACHE_262"
		compiler-behavior="The compiler will identify cases where two dual DAG instructions which may match the anomaly requirements could be executed in sequence and re-arrange the instructions such that DAG1 access of the first instruction is seperated and inserted after the remainder of the first multi-issued instruction." 
		summary="A pending store to data cache may be lost in the following circumstances: there is a dual DAG access where DAG0 is a cache miss, DAG1 is a read, and both are L2 accesses aliased to the same sub-bank as the pending commited store. This dual DAG operation must be followed immediately by another dual DAG access, where DAG1 is a read of L1 SRAM. There must also be an unpredicted change of flow within three clock cycles of the first dual DAG instruction." />

	<anomaly ix="25" id="05-00-0283"
		compiler-option="-workaround stalled-mmr-write-283"
		compiler-defs="-D__WORKAROUND_STALLED_MMR_WRITE_283"
		compiler-behavior="The problem is worked around in the compiler by adding a load of the CHIPID MMR at the start of code generated for C defined event handlers. The load is jumped around to clear the stalled write. The problem is also avoided in the VisualDSP++ default exception handler function cplb_hdr. This workaround supersedes that of anomaly 05-00-0157."
		summary="A system MMR write is stalled indefinitely when killed in a particular pipeline stage." />

	<anomaly ix="26" id="F3-F-021"
		assembler-detect-option="-anomaly-detect F3F021" 
		compiler-option="-workaround mem_branch_mem_F3_F_021"
		compiler-defs="-D__WORKAROUND_MEM_BRANCH_MEM_F3_F_021"
		summary="This workaround places a nop before the last instruction in the sequence LOAD/STORE; Conditional branch predicted not taken; LOAD/STORE;" />

	<anomaly ix="27" id="F3-F-008"
		assembler-detect-option="-anomaly-detect F3F008"
		assembler-behavior="The assembler looks for a RTI instruction immediately followed by 32-bit Multiply ."				 		
		compiler-option="-workaround spec_multiply_F3-F-008013"
		compiler-defs="-D__WORKAROUND_SPEC_MULTIPLY_F3_F_008013"
		compiler-behavior="There are 2 parts to the workaround.
		1)
			isr:
				RTI;
			func:
				32-bit mult;

		In this case, the ISR may clobber A0/A1 because of the aborted 32-bit mult. We workaround this by inserting 3 NOPS after any RTI, RTN, RTE, RTX instruction.

		2)
			Ax = y;
			if CC jump bob; //predicted not taken
			32-bit mult;
		bob:
			Use Ax;

		In this case, if the jump is taken, having the multiply in the shadow of the conditional branch could change the value of Ax, causing the use of Ax to use the wrong value.  The workaround is to make sure the 32-bit multipy isn't in the 3 instructions following the conditional branch.  The compiler will either insert NOPs or a CSYNC when the workaround is necessary."
		summary="A speculatively executed 32-bit multiply will update A0 and A1." /> 

        <anomaly ix="28" id="05-00-0312"
		assembler-detect-option="-anomaly-detect 05000312"
		assembler-detect-defs="-D__WORKAROUND_SYNC_LOOP_ANOM_312"
		assembler-behavior="The assembler looks for a non CLI instruction immediately followed by a sync or loop load."		
      compiler-option="-workaround sync-loop-anom-312"
      compiler-defs="-D__WORKAROUND_SYNC_LOOP_ANOM_312"
      summary="Errors when SSYNC, CSYNC, or loads to LT, LB and LC registers are interrupted. The compiler provides a combination of workarounds for this anomaly that it applies when deemed necessary. The workaround are as follows:
        1) The compiler builtin functions __builtin_ssync and __builting_csync have been modified to, when the workaround is enabled, ensure that interrupts are disabled before the sync instruction and enabled after.
        2) New ssync and csync builtins have been provided that do not disable interrupts. These can be used in place of the existing builtins for code that has been manually verified as safe against the anomaly. These new builtins are called __builtin_ssync_int and __builtin_csync_int.
        3) The compiler will ensure that any loads of the LBx, LTx and LCx registers are, when the workaround is enabled, executed with interrupts disabled. It does this by inserting a CLI instruction before such loads and an STI instruction after.
        4) The compiler will arrange to save and restore the loop registers (LBx, LTx and LCx) while interrupts are disabled for C/C++ nested interrupt handlers defined using the sys/exception.h EX_REENTRANT_HANDLER macro."/>

	<anomaly ix="29" id="F3-F-013"
		assembler-detect-option="-anomaly-detect F3F013" 
		assembler-behavior="The assembler looks for a Conditional Jump (predicted but not taken) immediately preceded and followed by a Load or Store."				 		
		compiler-option="-workaround spec_multiply_F3-F-008013"
		compiler-defs="-D__WORKAROUND_SPEC_MULTIPLY_F3_F_008013"
		compiler-behavior="There are 2 parts to the workaround.
		1)
			isr:
				RTI;
			func:
				32-bit mult;

		In this case, the ISR may clobber A0/A1 because of the aborted 32-bit mult. We workaround this by inserting 3 NOPS after any RTI, RTN, RTE, RTX instruction.

		2)
			Ax = y;
			if CC jump bob; //predicted not taken
			32-bit mult;
		bob:
			Use Ax;

		In this case, if the jump is taken, having the multiply in the shadow of the conditional branch could change the value of Ax, causing the use of Ax to use the wrong value.  The workaround is to make sure the 32-bit multipy isn't in the 3 instructions following the conditional branch.  The compiler will either insert NOPs or a CSYNC when the workaround is necessary."
		summary="A speculatively executed 32-bit multiply will update A0 and A1." /> 

   <anomaly ix="30" id="05-00-0311"
      compiler-option="-workaround flags-mmr-anom-311"
      compiler-defs="-D__WORKAROUND_FLAGS_MMR_ANOM_311"
		summary="Erroneous flag pin operations under specific sequences. Problem is worked around in the compiler in two ways:
        1) by adding a load of the CHIPID MMR at the start of code generated for C defined event handlers. The workaround for 05-00-0283 will be used if it is enabled at the same time as this workaround.
        2) by identifying accesses, or potential access, of any of the various System MMR Flag registers associated with the errata and generating a load of CHIPID after each such access. The compiler relies on use of literal addressing of MMRs to identify these access, such using the various pMMR macros defined in the cdefPART.h include files. Any loads and stores that do not use literal addresses and are defined qualified as volatile, will be assumed to be flag MMR accesses, unless -no-assume-vols-are-mmrs is used. If the -no-assume-vols-are-mmrs compiler switch is used the compiler will apply the workaround for suitable literal address accesses only and will make no assumptions for non-literal loads and store even if volatile."/>

   <anomaly ix="31" id="05-00-0258"
      rtl-defs="WA_05000258  (in order for this macro to be defined, the user must include the header file &lt;sys/anomaly_macros_rtl.h&gt;)"
		  rtl-behavior="This anomaly is worked around in the run-time libraries. In the _cplb_mgr and _cplb_init routines (which are part of the default cache support) bit 9 (reserved) of ICPLB_DATAx is set to the same state as bit 12 (CPLB_L1_CHBL)."
		summary="Instruction Cache is corrupted when bit 9 and 12 of
the ICPLB Data registers differ. When bit 9 and bit 12 of the ICPLB Data MMR differ, the cache may not update properly.  For example, for a particular cache line, the cache tag may be valid while the contents of that cache line are not present in the cache."/>

   <anomaly ix="32" id="05-00-0259"
      rtl-defs="WA_05000259  (in order for this macro to be defined, the user must include the header file &lt;sys/anomaly_macros_rtl.h&gt;)"
		  rtl-behavior="This anomaly is worked around in the run-time libraries. In the cplb management routines, if  disable ICPLBs are disabled via an MMR write, then the MMR write is immediately followed by a CSYNC, ensuring that both instruction occur in the same 64-bit instruction block."
		summary="Non-deterministic ICPLB descriptors delivered to hardware. Whenever ICPLBs are disabled via an MMR write, immediately follow this write with a CSYNC, and locate the MMR write and CSYNC within the same aligned 64 bit word."/>

   <anomaly ix="33" id="05-00-0122"
		compiler-behavior="The compiler automatically works round this anomaly for every revision. 
The compiler determines when a load or store is to a MMR. This requires the MMR access to use a constant address, or use one of the various MMR read/write built-ins.
See the &quot;Compiler Notes&quot; section below for more information on MMR accesses."
		summary="Rx.H Cannot Be Used to Access 16-bit System MMR Registers"/>

   <anomaly ix="34" id="05-00-0074"
		compiler-behavior="The compiler automatically works round this anomaly for every revision. The compiler works around the anomaly by always avoiding generating multi issue instructions which contain a dsp32shiftimm in slot 1 and P reg store in slot 2."
		summary="A multi issue instruction with dsp32shiftimm in slot1 and a store of a P register in slot 2 is not supported."/>

</anomaly-dictionary>

	<!-- *************************************************************** -->
	<!-- Compiler overview information for the anomaly-dictionary     ** -->
	<!-- *************************************************************** -->

<compiler-notes>
	<note text="There are various MMR related errata that the compiler supports; 05-00-0122, 05-00-0157, 05-00-0198. The compiler detects MMR accesses by checking addresses used in literal load and store instructions fall in the system MMR address range. Any loads and stores that do not use literal addresses and are defined qualified as volatile will be assumed to be MMR accesses unless the -no-assume-vols-are-mmrs is used. If the -no-assume-vols-are-mmrs compiler switch is used the compiler will apply the workaround for suitable literal address accesses and will make no assumptions for non-literal loads and store even if volatile. The various MMR read and write compiler builtins can be used in this mode to assert to the compiler that an access is to an MMR." />
</compiler-notes>

	<!-- *************************************************************** -->
	<!-- ** assembler-notes                                           ** -->
	<!-- *************************************************************** -->
	<!-- Assembler overview information for the anomaly-dictionary    ** -->
	<!-- *************************************************************** -->

<assembler-notes>
	<note text="There are no general notes on assembler anomaly behavior at this time."/>
</assembler-notes>

</visualdsp-dictionary-xml>
